<testsuites name="jest tests" tests="3054" failures="5" time="2626.056">
  <testsuite name="HasteMap" errors="0" failures="0" skipped="41" timestamp="2018-12-19T20:59:33" time="4.53" tests="42">
    <testcase classname="HasteMap does not work on Windows" name="HasteMap does not work on Windows" time="0.397">
    </testcase>
    <testcase classname="HasteMap exports constants" name="HasteMap exports constants" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap creates valid cache file paths" name="HasteMap creates valid cache file paths" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap creates different cache file paths for different roots" name="HasteMap creates different cache file paths for different roots" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap creates different cache file paths for different dependency extractor cache keys" name="HasteMap creates different cache file paths for different dependency extractor cache keys" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap creates different cache file paths for different hasteImplModulePath cache keys" name="HasteMap creates different cache file paths for different hasteImplModulePath cache keys" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap creates different cache file paths for different projects" name="HasteMap creates different cache file paths for different projects" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap matches files against a pattern" name="HasteMap matches files against a pattern" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap ignores files given a pattern" name="HasteMap ignores files given a pattern" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap builds a haste map on a fresh cache" name="HasteMap builds a haste map on a fresh cache" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap builds a haste map on a fresh cache with SHA-1s uses watchman: false" name="HasteMap builds a haste map on a fresh cache with SHA-1s uses watchman: false" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap builds a haste map on a fresh cache with SHA-1s uses watchman: true" name="HasteMap builds a haste map on a fresh cache with SHA-1s uses watchman: true" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap does not crawl native files even if requested to do so" name="HasteMap does not crawl native files even if requested to do so" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap retains all files if `retainAllFiles` is specified" name="HasteMap retains all files if `retainAllFiles` is specified" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap warns on duplicate mock files" name="HasteMap warns on duplicate mock files" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap warns on duplicate module ids" name="HasteMap warns on duplicate module ids" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap warns on duplicate module ids only once" name="HasteMap warns on duplicate module ids only once" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap throws on duplicate module ids if &quot;throwOnModuleCollision&quot; is set to true" name="HasteMap throws on duplicate module ids if &quot;throwOnModuleCollision&quot; is set to true" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap splits up modules by platform" name="HasteMap splits up modules by platform" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap does not access the file system on a warm cache with no changes" name="HasteMap does not access the file system on a warm cache with no changes" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap only does minimal file system access when files change" name="HasteMap only does minimal file system access when files change" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap correctly handles file deletions" name="HasteMap correctly handles file deletions" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap correctly handles platform-specific file additions" name="HasteMap correctly handles platform-specific file additions" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap correctly handles platform-specific file deletions" name="HasteMap correctly handles platform-specific file deletions" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap correctly handles platform-specific file renames" name="HasteMap correctly handles platform-specific file renames" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap duplicate modules recovers when a duplicate file is deleted" name="HasteMap duplicate modules recovers when a duplicate file is deleted" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap duplicate modules recovers with the correct type when a duplicate file is deleted" name="HasteMap duplicate modules recovers with the correct type when a duplicate file is deleted" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap duplicate modules recovers when a duplicate module is renamed" name="HasteMap duplicate modules recovers when a duplicate module is renamed" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap discards the cache when configuration changes" name="HasteMap discards the cache when configuration changes" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap ignores files that do not exist" name="HasteMap ignores files that do not exist" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap distributes work across workers" name="HasteMap distributes work across workers" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap tries to crawl using node as a fallback" name="HasteMap tries to crawl using node as a fallback" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap tries to crawl using node as a fallback when promise fails once" name="HasteMap tries to crawl using node as a fallback when promise fails once" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap stops crawling when both crawlers fail" name="HasteMap stops crawling when both crawlers fail" time="0.001">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap file system changes processing provides a new set of hasteHS and moduleMap" name="HasteMap file system changes processing provides a new set of hasteHS and moduleMap" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap file system changes processing handles several change events at once" name="HasteMap file system changes processing handles several change events at once" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap file system changes processing does not emit duplicate change events" name="HasteMap file system changes processing does not emit duplicate change events" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap file system changes processing emits a change even if a file in node_modules has changed" name="HasteMap file system changes processing emits a change even if a file in node_modules has changed" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap file system changes processing correctly tracks changes to both platform-specific versions of a single module name" name="HasteMap file system changes processing correctly tracks changes to both platform-specific versions of a single module name" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap file system changes processing recovery from duplicate module IDs recovers when the oldest version of the duplicates is fixed" name="HasteMap file system changes processing recovery from duplicate module IDs recovers when the oldest version of the duplicates is fixed" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap file system changes processing recovery from duplicate module IDs recovers when the most recent duplicate is fixed" name="HasteMap file system changes processing recovery from duplicate module IDs recovers when the most recent duplicate is fixed" time="0">
      <skipped/>
    </testcase>
    <testcase classname="HasteMap file system changes processing recovery from duplicate module IDs ignore directories" name="HasteMap file system changes processing recovery from duplicate module IDs ignore directories" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="moduleMocker" errors="0" failures="0" skipped="0" timestamp="2018-12-19T20:59:38" time="1.031" tests="73">
    <testcase classname="moduleMocker getMetadata returns the function `name` property" name="moduleMocker getMetadata returns the function `name` property" time="0.201">
    </testcase>
    <testcase classname="moduleMocker getMetadata mocks constant values" name="moduleMocker getMetadata mocks constant values" time="0.013">
    </testcase>
    <testcase classname="moduleMocker getMetadata does not retrieve metadata for arrays" name="moduleMocker getMetadata does not retrieve metadata for arrays" time="0.003">
    </testcase>
    <testcase classname="moduleMocker getMetadata does not retrieve metadata for undefined" name="moduleMocker getMetadata does not retrieve metadata for undefined" time="0.003">
    </testcase>
    <testcase classname="moduleMocker getMetadata does not retrieve metadata for null" name="moduleMocker getMetadata does not retrieve metadata for null" time="0.003">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata forwards the function name property" name="moduleMocker generateFromMetadata forwards the function name property" time="0.005">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata escapes illegal characters in function name property" name="moduleMocker generateFromMetadata escapes illegal characters in function name property" time="0.006">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata special cases the mockConstructor name" name="moduleMocker generateFromMetadata special cases the mockConstructor name" time="0.003">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata wont interfere with previous mocks on a shared prototype" name="moduleMocker generateFromMetadata wont interfere with previous mocks on a shared prototype" time="0.005">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata does not mock non-enumerable getters" name="moduleMocker generateFromMetadata does not mock non-enumerable getters" time="0.004">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocks getters of ES modules" name="moduleMocker generateFromMetadata mocks getters of ES modules" time="0.013">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocks ES2015 non-enumerable methods" name="moduleMocker generateFromMetadata mocks ES2015 non-enumerable methods" time="0.006">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocks ES2015 non-enumerable static properties and methods" name="moduleMocker generateFromMetadata mocks ES2015 non-enumerable static properties and methods" time="0.009">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocks methods in all the prototype chain (null prototype)" name="moduleMocker generateFromMetadata mocks methods in all the prototype chain (null prototype)" time="0.006">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata does not mock methods from Object.prototype" name="moduleMocker generateFromMetadata does not mock methods from Object.prototype" time="0.004">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata does not mock methods from Object.prototype (in mock context)" name="moduleMocker generateFromMetadata does not mock methods from Object.prototype (in mock context)" time="0.002">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata does not mock methods from Function.prototype" name="moduleMocker generateFromMetadata does not mock methods from Function.prototype" time="0.004">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata does not mock methods from Function.prototype (in mock context)" name="moduleMocker generateFromMetadata does not mock methods from Function.prototype (in mock context)" time="0.003">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata does not mock methods from RegExp.prototype" name="moduleMocker generateFromMetadata does not mock methods from RegExp.prototype" time="0.005">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata does not mock methods from RegExp.prototype (in mock context)" name="moduleMocker generateFromMetadata does not mock methods from RegExp.prototype (in mock context)" time="0.002">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocks methods that are bound multiple times" name="moduleMocker generateFromMetadata mocks methods that are bound multiple times" time="0.001">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocks methods that are bound after mocking" name="moduleMocker generateFromMetadata mocks methods that are bound after mocking" time="0.003">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocks regexp instances" name="moduleMocker generateFromMetadata mocks regexp instances" time="0.003">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocked functions tracks calls to mocks" name="moduleMocker generateFromMetadata mocked functions tracks calls to mocks" time="0.003">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocked functions tracks instances made by mocks" name="moduleMocker generateFromMetadata mocked functions tracks instances made by mocks" time="0.002">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocked functions supports clearing mock calls" name="moduleMocker generateFromMetadata mocked functions supports clearing mock calls" time="0.004">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocked functions supports clearing mocks" name="moduleMocker generateFromMetadata mocked functions supports clearing mocks" time="0.003">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocked functions supports clearing all mocks" name="moduleMocker generateFromMetadata mocked functions supports clearing all mocks" time="0.004">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocked functions supports resetting mock return values" name="moduleMocker generateFromMetadata mocked functions supports resetting mock return values" time="0.002">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocked functions supports resetting single use mock return values" name="moduleMocker generateFromMetadata mocked functions supports resetting single use mock return values" time="0.002">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocked functions supports resetting mock implementations" name="moduleMocker generateFromMetadata mocked functions supports resetting mock implementations" time="0.002">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocked functions supports resetting single use mock implementations" name="moduleMocker generateFromMetadata mocked functions supports resetting single use mock implementations" time="0.002">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocked functions supports resetting all mocks" name="moduleMocker generateFromMetadata mocked functions supports resetting all mocks" time="0.003">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mocked functions maintains function arity" name="moduleMocker generateFromMetadata mocked functions maintains function arity" time="0.002">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata supports mock value returning undefined" name="moduleMocker generateFromMetadata supports mock value returning undefined" time="0.003">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata supports mock value once returning undefined" name="moduleMocker generateFromMetadata supports mock value once returning undefined" time="0.002">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata mockReturnValueOnce mocks value just once" name="moduleMocker generateFromMetadata mockReturnValueOnce mocks value just once" time="0.004">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata supports mocking resolvable async functions" name="moduleMocker generateFromMetadata supports mocking resolvable async functions" time="0.003">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata supports mocking resolvable async functions only once" name="moduleMocker generateFromMetadata supports mocking resolvable async functions only once" time="0.002">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata supports mocking rejectable async functions" name="moduleMocker generateFromMetadata supports mocking rejectable async functions" time="0.008">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata supports mocking rejectable async functions only once" name="moduleMocker generateFromMetadata supports mocking rejectable async functions only once" time="0.003">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata return values tracks return values" name="moduleMocker generateFromMetadata return values tracks return values" time="0.003">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata return values tracks mocked return values" name="moduleMocker generateFromMetadata return values tracks mocked return values" time="0.002">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata return values supports resetting return values" name="moduleMocker generateFromMetadata return values supports resetting return values" time="0.004">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata tracks thrown errors without interfering with other tracking" name="moduleMocker generateFromMetadata tracks thrown errors without interfering with other tracking" time="0.006">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata a call that throws undefined is tracked properly" name="moduleMocker generateFromMetadata a call that throws undefined is tracked properly" time="0.02">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata results of recursive calls are tracked properly" name="moduleMocker generateFromMetadata results of recursive calls are tracked properly" time="0.004">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata test results of recursive calls from within the recursive call" name="moduleMocker generateFromMetadata test results of recursive calls from within the recursive call" time="0.005">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata call mockClear inside recursive mock" name="moduleMocker generateFromMetadata call mockClear inside recursive mock" time="0.002">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata invocationCallOrder tracks invocationCallOrder made by mocks" name="moduleMocker generateFromMetadata invocationCallOrder tracks invocationCallOrder made by mocks" time="0.016">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata invocationCallOrder supports clearing mock invocationCallOrder" name="moduleMocker generateFromMetadata invocationCallOrder supports clearing mock invocationCallOrder" time="0.015">
    </testcase>
    <testcase classname="moduleMocker generateFromMetadata invocationCallOrder supports clearing all mocks invocationCallOrder" name="moduleMocker generateFromMetadata invocationCallOrder supports clearing all mocks invocationCallOrder" time="0.008">
    </testcase>
    <testcase classname="moduleMocker getMockImplementation should mock calls to a mock function" name="moduleMocker getMockImplementation should mock calls to a mock function" time="0.002">
    </testcase>
    <testcase classname="moduleMocker mockImplementationOnce should mock constructor" name="moduleMocker mockImplementationOnce should mock constructor" time="0.005">
    </testcase>
    <testcase classname="moduleMocker mockImplementationOnce should mock single call to a mock function" name="moduleMocker mockImplementationOnce should mock single call to a mock function" time="0.003">
    </testcase>
    <testcase classname="moduleMocker mockImplementationOnce should fallback to default mock function when no specific mock is available" name="moduleMocker mockImplementationOnce should fallback to default mock function when no specific mock is available" time="0.003">
    </testcase>
    <testcase classname="moduleMocker mockImplementation resets the mock" name="moduleMocker mockImplementation resets the mock" time="0.007">
    </testcase>
    <testcase classname="moduleMocker should recognize a mocked function" name="moduleMocker should recognize a mocked function" time="0.003">
    </testcase>
    <testcase classname="moduleMocker default mockName is jest.fn()" name="moduleMocker default mockName is jest.fn()" time="0.003">
    </testcase>
    <testcase classname="moduleMocker mockName sets the mock name" name="moduleMocker mockName sets the mock name" time="0.003">
    </testcase>
    <testcase classname="moduleMocker mockName gets reset by mockReset" name="moduleMocker mockName gets reset by mockReset" time="0.002">
    </testcase>
    <testcase classname="moduleMocker mockName gets reset by mockRestore" name="moduleMocker mockName gets reset by mockRestore" time="0.001">
    </testcase>
    <testcase classname="moduleMocker mockName is not reset by mockClear" name="moduleMocker mockName is not reset by mockClear" time="0.004">
    </testcase>
    <testcase classname="moduleMocker spyOn should work" name="moduleMocker spyOn should work" time="0.003">
    </testcase>
    <testcase classname="moduleMocker spyOn should throw on invalid input" name="moduleMocker spyOn should throw on invalid input" time="0.008">
    </testcase>
    <testcase classname="moduleMocker spyOn supports restoring all spies" name="moduleMocker spyOn supports restoring all spies" time="0.01">
    </testcase>
    <testcase classname="moduleMocker spyOnProperty should work - getter" name="moduleMocker spyOnProperty should work - getter" time="0.003">
    </testcase>
    <testcase classname="moduleMocker spyOnProperty should work - setter" name="moduleMocker spyOnProperty should work - setter" time="0.002">
    </testcase>
    <testcase classname="moduleMocker spyOnProperty should throw on invalid input" name="moduleMocker spyOnProperty should throw on invalid input" time="0.003">
    </testcase>
    <testcase classname="moduleMocker spyOnProperty supports restoring all spies" name="moduleMocker spyOnProperty supports restoring all spies" time="0.003">
    </testcase>
    <testcase classname="moduleMocker spyOnProperty should work with getters on the prototype chain" name="moduleMocker spyOnProperty should work with getters on the prototype chain" time="0.003">
    </testcase>
    <testcase classname="moduleMocker spyOnProperty should work with setters on the prototype chain" name="moduleMocker spyOnProperty should work with setters on the prototype chain" time="0.002">
    </testcase>
    <testcase classname="moduleMocker spyOnProperty supports restoring all spies on the prototype chain" name="moduleMocker spyOnProperty supports restoring all spies on the prototype chain" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T20:59:39" time="1.524" tests="89">
    <testcase classname=" picks a name based on the rootDir" name=" picks a name based on the rootDir" time="0.081">
    </testcase>
    <testcase classname=" keeps custom names based on the rootDir" name=" keeps custom names based on the rootDir" time="0.001">
    </testcase>
    <testcase classname=" sets coverageReporters correctly when argv.json is set" name=" sets coverageReporters correctly when argv.json is set" time="0.002">
    </testcase>
    <testcase classname="rootDir throws if the options is missing a rootDir property" name="rootDir throws if the options is missing a rootDir property" time="0.005">
    </testcase>
    <testcase classname="automock falsy automock is not overwritten" name="automock falsy automock is not overwritten" time="0.001">
    </testcase>
    <testcase classname="browser falsy browser is not overwritten" name="browser falsy browser is not overwritten" time="0.001">
    </testcase>
    <testcase classname="collectCoverageOnlyFrom normalizes all paths relative to rootDir" name="collectCoverageOnlyFrom normalizes all paths relative to rootDir" time="0.002">
    </testcase>
    <testcase classname="collectCoverageOnlyFrom does not change absolute paths" name="collectCoverageOnlyFrom does not change absolute paths" time="0.001">
    </testcase>
    <testcase classname="collectCoverageOnlyFrom substitutes &lt;rootDir&gt; tokens" name="collectCoverageOnlyFrom substitutes &lt;rootDir&gt; tokens" time="0.001">
    </testcase>
    <testcase classname="collectCoverageFrom substitutes &lt;rootDir&gt; tokens" name="collectCoverageFrom substitutes &lt;rootDir&gt; tokens" time="0.002">
    </testcase>
    <testcase classname="findRelatedTests it generates --coverageCoverageFrom patterns when needed" name="findRelatedTests it generates --coverageCoverageFrom patterns when needed" time="0.002">
    </testcase>
    <testcase classname="roots normalizes all paths relative to rootDir" name="roots normalizes all paths relative to rootDir" time="0.002">
    </testcase>
    <testcase classname="roots does not change absolute paths" name="roots does not change absolute paths" time="0.001">
    </testcase>
    <testcase classname="roots substitutes &lt;rootDir&gt; tokens" name="roots substitutes &lt;rootDir&gt; tokens" time="0.002">
    </testcase>
    <testcase classname="transform normalizes the path" name="transform normalizes the path" time="0.009">
    </testcase>
    <testcase classname="haste normalizes the path for hasteImplModulePath" name="haste normalizes the path for hasteImplModulePath" time="0.002">
    </testcase>
    <testcase classname="setupFilesAfterEnv normalizes the path according to rootDir" name="setupFilesAfterEnv normalizes the path according to rootDir" time="0.002">
    </testcase>
    <testcase classname="setupFilesAfterEnv does not change absolute paths" name="setupFilesAfterEnv does not change absolute paths" time="0.002">
    </testcase>
    <testcase classname="setupFilesAfterEnv substitutes &lt;rootDir&gt; tokens" name="setupFilesAfterEnv substitutes &lt;rootDir&gt; tokens" time="0.002">
    </testcase>
    <testcase classname="setupTestFrameworkScriptFile logs a deprecation warning when `setupTestFrameworkScriptFile` is used" name="setupTestFrameworkScriptFile logs a deprecation warning when `setupTestFrameworkScriptFile` is used" time="0.003">
    </testcase>
    <testcase classname="setupTestFrameworkScriptFile logs an error when `setupTestFrameworkScriptFile` and `setupFilesAfterEnv` are used" name="setupTestFrameworkScriptFile logs an error when `setupTestFrameworkScriptFile` and `setupFilesAfterEnv` are used" time="0.001">
    </testcase>
    <testcase classname="coveragePathIgnorePatterns does not normalize paths relative to rootDir" name="coveragePathIgnorePatterns does not normalize paths relative to rootDir" time="0.002">
    </testcase>
    <testcase classname="coveragePathIgnorePatterns does not normalize trailing slashes" name="coveragePathIgnorePatterns does not normalize trailing slashes" time="0.008">
    </testcase>
    <testcase classname="coveragePathIgnorePatterns substitutes &lt;rootDir&gt; tokens" name="coveragePathIgnorePatterns substitutes &lt;rootDir&gt; tokens" time="0.002">
    </testcase>
    <testcase classname="watchPathIgnorePatterns does not normalize paths relative to rootDir" name="watchPathIgnorePatterns does not normalize paths relative to rootDir" time="0.004">
    </testcase>
    <testcase classname="watchPathIgnorePatterns does not normalize trailing slashes" name="watchPathIgnorePatterns does not normalize trailing slashes" time="0.001">
    </testcase>
    <testcase classname="watchPathIgnorePatterns substitutes &lt;rootDir&gt; tokens" name="watchPathIgnorePatterns substitutes &lt;rootDir&gt; tokens" time="0.002">
    </testcase>
    <testcase classname="testPathIgnorePatterns does not normalize paths relative to rootDir" name="testPathIgnorePatterns does not normalize paths relative to rootDir" time="0.002">
    </testcase>
    <testcase classname="testPathIgnorePatterns does not normalize trailing slashes" name="testPathIgnorePatterns does not normalize trailing slashes" time="0.001">
    </testcase>
    <testcase classname="testPathIgnorePatterns substitutes &lt;rootDir&gt; tokens" name="testPathIgnorePatterns substitutes &lt;rootDir&gt; tokens" time="0.001">
    </testcase>
    <testcase classname="modulePathIgnorePatterns does not normalize paths relative to rootDir" name="modulePathIgnorePatterns does not normalize paths relative to rootDir" time="0.001">
    </testcase>
    <testcase classname="modulePathIgnorePatterns does not normalize trailing slashes" name="modulePathIgnorePatterns does not normalize trailing slashes" time="0.001">
    </testcase>
    <testcase classname="modulePathIgnorePatterns substitutes &lt;rootDir&gt; tokens" name="modulePathIgnorePatterns substitutes &lt;rootDir&gt; tokens" time="0.001">
    </testcase>
    <testcase classname="testRunner defaults to Jasmine 2" name="testRunner defaults to Jasmine 2" time="0.002">
    </testcase>
    <testcase classname="testRunner is overwritten by argv" name="testRunner is overwritten by argv" time="0.002">
    </testcase>
    <testcase classname="coverageDirectory defaults to &lt;rootDir&gt;/coverage" name="coverageDirectory defaults to &lt;rootDir&gt;/coverage" time="0.004">
    </testcase>
    <testcase classname="testEnvironment resolves to an environment and prefers jest-environment-`name`" name="testEnvironment resolves to an environment and prefers jest-environment-`name`" time="0.002">
    </testcase>
    <testcase classname="testEnvironment throws on invalid environment names" name="testEnvironment throws on invalid environment names" time="0.006">
    </testcase>
    <testcase classname="testEnvironment works with rootDir" name="testEnvironment works with rootDir" time="0.003">
    </testcase>
    <testcase classname="babel-jest correctly identifies and uses babel-jest" name="babel-jest correctly identifies and uses babel-jest" time="0.001">
    </testcase>
    <testcase classname="babel-jest uses babel-jest if babel-jest is explicitly specified in a custom transform options" name="babel-jest uses babel-jest if babel-jest is explicitly specified in a custom transform options" time="0.001">
    </testcase>
    <testcase classname="babel-jest uses regenerator if babel-jest is explicitly specified" name="babel-jest uses regenerator if babel-jest is explicitly specified" time="0.001">
    </testcase>
    <testcase classname="Upgrade help logs a warning when `scriptPreprocessor` and/or `preprocessorIgnorePatterns` are used" name="Upgrade help logs a warning when `scriptPreprocessor` and/or `preprocessorIgnorePatterns` are used" time="0.003">
    </testcase>
    <testcase classname="testRegex testRegex empty string is mapped to empty array" name="testRegex testRegex empty string is mapped to empty array" time="0.001">
    </testcase>
    <testcase classname="testRegex testRegex string is mapped to an array" name="testRegex testRegex string is mapped to an array" time="0.001">
    </testcase>
    <testcase classname="testRegex testRegex array is preserved" name="testRegex testRegex array is preserved" time="0.001">
    </testcase>
    <testcase classname="testMatch testMatch default not applied if testRegex is set" name="testMatch testMatch default not applied if testRegex is set" time="0.001">
    </testcase>
    <testcase classname="testMatch testRegex default not applied if testMatch is set" name="testMatch testRegex default not applied if testMatch is set" time="0.001">
    </testcase>
    <testcase classname="testMatch throws if testRegex and testMatch are both specified" name="testMatch throws if testRegex and testMatch are both specified" time="0.002">
    </testcase>
    <testcase classname="testMatch normalizes testMatch" name="testMatch normalizes testMatch" time="0.001">
    </testcase>
    <testcase classname="moduleDirectories defaults to node_modules" name="moduleDirectories defaults to node_modules" time="0.001">
    </testcase>
    <testcase classname="moduleDirectories normalizes moduleDirectories" name="moduleDirectories normalizes moduleDirectories" time="0.001">
    </testcase>
    <testcase classname="preset throws when preset not found" name="preset throws when preset not found" time="0.005">
    </testcase>
    <testcase classname="preset throws when module was found but no &quot;jest-preset.js&quot; or &quot;jest-preset.json&quot; files" name="preset throws when module was found but no &quot;jest-preset.js&quot; or &quot;jest-preset.json&quot; files" time="0.002">
    </testcase>
    <testcase classname="preset throws when preset is invalid" name="preset throws when preset is invalid" time="0.003">
    </testcase>
    <testcase classname="preset works with &quot;react-native&quot;" name="preset works with &quot;react-native&quot;" time="0.002">
    </testcase>
    <testcase classname="preset searches for .json and .js preset files" name="preset searches for .json and .js preset files" time="0.001">
    </testcase>
    <testcase classname="preset merges with options" name="preset merges with options" time="0.002">
    </testcase>
    <testcase classname="preset merges with options and moduleNameMapper preset is overridden by options" name="preset merges with options and moduleNameMapper preset is overridden by options" time="0.002">
    </testcase>
    <testcase classname="preset merges with options and transform preset is overridden by options" name="preset merges with options and transform preset is overridden by options" time="0.001">
    </testcase>
    <testcase classname="preset without setupFiles should normalize setupFiles correctly" name="preset without setupFiles should normalize setupFiles correctly" time="0.001">
    </testcase>
    <testcase classname="runner defaults to `jest-runner`" name="runner defaults to `jest-runner`" time="0.001">
    </testcase>
    <testcase classname="runner resolves to runners that do not have the prefix" name="runner resolves to runners that do not have the prefix" time="0.004">
    </testcase>
    <testcase classname="runner resolves to runners and prefers jest-runner-`name`" name="runner resolves to runners and prefers jest-runner-`name`" time="0.001">
    </testcase>
    <testcase classname="runner throw error when a runner is not found" name="runner throw error when a runner is not found" time="0.006">
    </testcase>
    <testcase classname="watchPlugins defaults to undefined" name="watchPlugins defaults to undefined" time="0.001">
    </testcase>
    <testcase classname="watchPlugins resolves to watch plugins and prefers jest-watch-`name`" name="watchPlugins resolves to watch plugins and prefers jest-watch-`name`" time="0.001">
    </testcase>
    <testcase classname="watchPlugins resolves watch plugins that do not have the prefix" name="watchPlugins resolves watch plugins that do not have the prefix" time="0.004">
    </testcase>
    <testcase classname="watchPlugins normalizes multiple watchPlugins" name="watchPlugins normalizes multiple watchPlugins" time="0.004">
    </testcase>
    <testcase classname="watchPlugins throw error when a watch plugin is not found" name="watchPlugins throw error when a watch plugin is not found" time="0.006">
    </testcase>
    <testcase classname="testPathPattern defaults to empty" name="testPathPattern defaults to empty" time="0.001">
    </testcase>
    <testcase classname="testPathPattern --testPathPattern uses --testPathPattern if set" name="testPathPattern --testPathPattern uses --testPathPattern if set" time="0.001">
    </testcase>
    <testcase classname="testPathPattern --testPathPattern ignores invalid regular expressions and logs a warning" name="testPathPattern --testPathPattern ignores invalid regular expressions and logs a warning" time="0.002">
    </testcase>
    <testcase classname="testPathPattern --testPathPattern joins multiple --testPathPattern if set" name="testPathPattern --testPathPattern joins multiple --testPathPattern if set" time="0.001">
    </testcase>
    <testcase classname="testPathPattern --testPathPattern posix should not escape the pattern" name="testPathPattern --testPathPattern posix should not escape the pattern" time="0.001">
    </testcase>
    <testcase classname="testPathPattern --testPathPattern win32 preserves any use of &quot;\&quot;" name="testPathPattern --testPathPattern win32 preserves any use of &quot;\&quot;" time="0.001">
    </testcase>
    <testcase classname="testPathPattern --testPathPattern win32 replaces POSIX path separators" name="testPathPattern --testPathPattern win32 replaces POSIX path separators" time="0.042">
    </testcase>
    <testcase classname="testPathPattern --testPathPattern win32 replaces POSIX paths in multiple args" name="testPathPattern --testPathPattern win32 replaces POSIX paths in multiple args" time="0.046">
    </testcase>
    <testcase classname="testPathPattern &lt;regexForTestFiles&gt; uses &lt;regexForTestFiles&gt; if set" name="testPathPattern &lt;regexForTestFiles&gt; uses &lt;regexForTestFiles&gt; if set" time="0.002">
    </testcase>
    <testcase classname="testPathPattern &lt;regexForTestFiles&gt; ignores invalid regular expressions and logs a warning" name="testPathPattern &lt;regexForTestFiles&gt; ignores invalid regular expressions and logs a warning" time="0.002">
    </testcase>
    <testcase classname="testPathPattern &lt;regexForTestFiles&gt; joins multiple &lt;regexForTestFiles&gt; if set" name="testPathPattern &lt;regexForTestFiles&gt; joins multiple &lt;regexForTestFiles&gt; if set" time="0.001">
    </testcase>
    <testcase classname="testPathPattern &lt;regexForTestFiles&gt; posix should not escape the pattern" name="testPathPattern &lt;regexForTestFiles&gt; posix should not escape the pattern" time="0.001">
    </testcase>
    <testcase classname="testPathPattern &lt;regexForTestFiles&gt; win32 preserves any use of &quot;\&quot;" name="testPathPattern &lt;regexForTestFiles&gt; win32 preserves any use of &quot;\&quot;" time="0.052">
    </testcase>
    <testcase classname="testPathPattern &lt;regexForTestFiles&gt; win32 replaces POSIX path separators" name="testPathPattern &lt;regexForTestFiles&gt; win32 replaces POSIX path separators" time="0.034">
    </testcase>
    <testcase classname="testPathPattern &lt;regexForTestFiles&gt; win32 replaces POSIX paths in multiple args" name="testPathPattern &lt;regexForTestFiles&gt; win32 replaces POSIX paths in multiple args" time="0.032">
    </testcase>
    <testcase classname="testPathPattern joins multiple --testPathPatterns and &lt;regexForTestFiles&gt;" name="testPathPattern joins multiple --testPathPatterns and &lt;regexForTestFiles&gt;" time="0.003">
    </testcase>
    <testcase classname="testPathPattern gives precedence to --all" name="testPathPattern gives precedence to --all" time="0.001">
    </testcase>
    <testcase classname="moduleFileExtensions defaults to something useful" name="moduleFileExtensions defaults to something useful" time="0.001">
    </testcase>
    <testcase classname="moduleFileExtensions throws if missing `js`" name="moduleFileExtensions throws if missing `js`" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T20:59:40" time="1.48" tests="432">
    <testcase classname=" should throw if passed two arguments" name=" should throw if passed two arguments" time="0.002">
    </testcase>
    <testcase classname=".rejects should reject" name=".rejects should reject" time="0.01">
    </testcase>
    <testcase classname=".rejects should reject with toThrow" name=".rejects should reject with toThrow" time="0.001">
    </testcase>
    <testcase classname=".rejects fails non-promise value 4 synchronously" name=".rejects fails non-promise value 4 synchronously" time="0.001">
    </testcase>
    <testcase classname=".rejects fails non-promise value [1] synchronously" name=".rejects fails non-promise value [1] synchronously" time="0.002">
    </testcase>
    <testcase classname=".rejects fails non-promise value {&quot;a&quot;: 1} synchronously" name=".rejects fails non-promise value {&quot;a&quot;: 1} synchronously" time="0">
    </testcase>
    <testcase classname=".rejects fails non-promise value &quot;a&quot; synchronously" name=".rejects fails non-promise value &quot;a&quot; synchronously" time="0">
    </testcase>
    <testcase classname=".rejects fails non-promise value true synchronously" name=".rejects fails non-promise value true synchronously" time="0.001">
    </testcase>
    <testcase classname=".rejects fails non-promise value null synchronously" name=".rejects fails non-promise value null synchronously" time="0.001">
    </testcase>
    <testcase classname=".rejects fails non-promise value undefined synchronously" name=".rejects fails non-promise value undefined synchronously" time="0">
    </testcase>
    <testcase classname=".rejects fails non-promise value [Function anonymous] synchronously" name=".rejects fails non-promise value [Function anonymous] synchronously" time="0.001">
    </testcase>
    <testcase classname=".rejects fails non-promise value 4" name=".rejects fails non-promise value 4" time="0.001">
    </testcase>
    <testcase classname=".rejects fails non-promise value [1]" name=".rejects fails non-promise value [1]" time="0.001">
    </testcase>
    <testcase classname=".rejects fails non-promise value {&quot;a&quot;: 1}" name=".rejects fails non-promise value {&quot;a&quot;: 1}" time="0.001">
    </testcase>
    <testcase classname=".rejects fails non-promise value &quot;a&quot;" name=".rejects fails non-promise value &quot;a&quot;" time="0.001">
    </testcase>
    <testcase classname=".rejects fails non-promise value true" name=".rejects fails non-promise value true" time="0.001">
    </testcase>
    <testcase classname=".rejects fails non-promise value null" name=".rejects fails non-promise value null" time="0.001">
    </testcase>
    <testcase classname=".rejects fails non-promise value undefined" name=".rejects fails non-promise value undefined" time="0.001">
    </testcase>
    <testcase classname=".rejects fails non-promise value [Function anonymous]" name=".rejects fails non-promise value [Function anonymous]" time="0.001">
    </testcase>
    <testcase classname=".rejects fails for promise that resolves" name=".rejects fails for promise that resolves" time="0.004">
    </testcase>
    <testcase classname=".resolves should resolve" name=".resolves should resolve" time="0.003">
    </testcase>
    <testcase classname=".resolves fails non-promise value 4 synchronously" name=".resolves fails non-promise value 4 synchronously" time="0.002">
    </testcase>
    <testcase classname=".resolves fails non-promise value [1] synchronously" name=".resolves fails non-promise value [1] synchronously" time="0.001">
    </testcase>
    <testcase classname=".resolves fails non-promise value {&quot;a&quot;: 1} synchronously" name=".resolves fails non-promise value {&quot;a&quot;: 1} synchronously" time="0.002">
    </testcase>
    <testcase classname=".resolves fails non-promise value &quot;a&quot; synchronously" name=".resolves fails non-promise value &quot;a&quot; synchronously" time="0.002">
    </testcase>
    <testcase classname=".resolves fails non-promise value true synchronously" name=".resolves fails non-promise value true synchronously" time="0.001">
    </testcase>
    <testcase classname=".resolves fails non-promise value null synchronously" name=".resolves fails non-promise value null synchronously" time="0.001">
    </testcase>
    <testcase classname=".resolves fails non-promise value undefined synchronously" name=".resolves fails non-promise value undefined synchronously" time="0.002">
    </testcase>
    <testcase classname=".resolves fails non-promise value [Function anonymous] synchronously" name=".resolves fails non-promise value [Function anonymous] synchronously" time="0.001">
    </testcase>
    <testcase classname=".resolves fails non-promise value 4" name=".resolves fails non-promise value 4" time="0.001">
    </testcase>
    <testcase classname=".resolves fails non-promise value [1]" name=".resolves fails non-promise value [1]" time="0.001">
    </testcase>
    <testcase classname=".resolves fails non-promise value {&quot;a&quot;: 1}" name=".resolves fails non-promise value {&quot;a&quot;: 1}" time="0.001">
    </testcase>
    <testcase classname=".resolves fails non-promise value &quot;a&quot;" name=".resolves fails non-promise value &quot;a&quot;" time="0.001">
    </testcase>
    <testcase classname=".resolves fails non-promise value true" name=".resolves fails non-promise value true" time="0.001">
    </testcase>
    <testcase classname=".resolves fails non-promise value null" name=".resolves fails non-promise value null" time="0.001">
    </testcase>
    <testcase classname=".resolves fails non-promise value undefined" name=".resolves fails non-promise value undefined" time="0.001">
    </testcase>
    <testcase classname=".resolves fails non-promise value [Function anonymous]" name=".resolves fails non-promise value [Function anonymous]" time="0.001">
    </testcase>
    <testcase classname=".resolves fails for promise that rejects" name=".resolves fails for promise that rejects" time="0.001">
    </testcase>
    <testcase classname=".toBe() does not throw" name=".toBe() does not throw" time="0.004">
    </testcase>
    <testcase classname=".toBe() fails for: 1 and 2" name=".toBe() fails for: 1 and 2" time="0.001">
    </testcase>
    <testcase classname=".toBe() fails for: true and false" name=".toBe() fails for: true and false" time="0.001">
    </testcase>
    <testcase classname=".toBe() fails for: {} and {}" name=".toBe() fails for: {} and {}" time="0.003">
    </testcase>
    <testcase classname=".toBe() fails for: {&quot;a&quot;: 1} and {&quot;a&quot;: 1}" name=".toBe() fails for: {&quot;a&quot;: 1} and {&quot;a&quot;: 1}" time="0.001">
    </testcase>
    <testcase classname=".toBe() fails for: {&quot;a&quot;: 1} and {&quot;a&quot;: 5}" name=".toBe() fails for: {&quot;a&quot;: 1} and {&quot;a&quot;: 5}" time="0.003">
    </testcase>
    <testcase classname=".toBe() fails for: &quot;abc&quot; and &quot;cde&quot;" name=".toBe() fails for: &quot;abc&quot; and &quot;cde&quot;" time="0.001">
    </testcase>
    <testcase classname=".toBe() fails for: &quot;with 
trailing space&quot; and &quot;without trailing space&quot;" name=".toBe() fails for: &quot;with 
trailing space&quot; and &quot;without trailing space&quot;" time="0.001">
    </testcase>
    <testcase classname=".toBe() fails for: [] and []" name=".toBe() fails for: [] and []" time="0.001">
    </testcase>
    <testcase classname=".toBe() fails for: null and undefined" name=".toBe() fails for: null and undefined" time="0.002">
    </testcase>
    <testcase classname=".toBe() fails for: -0 and 0" name=".toBe() fails for: -0 and 0" time="0.001">
    </testcase>
    <testcase classname=".toBe() fails for &apos;false&apos; with &apos;.not&apos;" name=".toBe() fails for &apos;false&apos; with &apos;.not&apos;" time="0.001">
    </testcase>
    <testcase classname=".toBe() fails for &apos;1&apos; with &apos;.not&apos;" name=".toBe() fails for &apos;1&apos; with &apos;.not&apos;" time="0.001">
    </testcase>
    <testcase classname=".toBe() fails for &apos;&quot;a&quot;&apos; with &apos;.not&apos;" name=".toBe() fails for &apos;&quot;a&quot;&apos; with &apos;.not&apos;" time="0.001">
    </testcase>
    <testcase classname=".toBe() fails for &apos;undefined&apos; with &apos;.not&apos;" name=".toBe() fails for &apos;undefined&apos; with &apos;.not&apos;" time="0">
    </testcase>
    <testcase classname=".toBe() fails for &apos;null&apos; with &apos;.not&apos;" name=".toBe() fails for &apos;null&apos; with &apos;.not&apos;" time="0">
    </testcase>
    <testcase classname=".toBe() fails for &apos;{}&apos; with &apos;.not&apos;" name=".toBe() fails for &apos;{}&apos; with &apos;.not&apos;" time="0.001">
    </testcase>
    <testcase classname=".toBe() fails for &apos;[]&apos; with &apos;.not&apos;" name=".toBe() fails for &apos;[]&apos; with &apos;.not&apos;" time="0.001">
    </testcase>
    <testcase classname=".toBe() does not crash on circular references" name=".toBe() does not crash on circular references" time="0.002">
    </testcase>
    <testcase classname=".toBe() assertion error matcherResult property contains matcher name, expected and actual values" name=".toBe() assertion error matcherResult property contains matcher name, expected and actual values" time="0.001">
    </testcase>
    <testcase classname=".toStrictEqual() does not ignore keys with undefined values" name=".toStrictEqual() does not ignore keys with undefined values" time="0.001">
    </testcase>
    <testcase classname=".toStrictEqual() passes when comparing same type" name=".toStrictEqual() passes when comparing same type" time="0.001">
    </testcase>
    <testcase classname=".toStrictEqual() matches the expected snapshot when it fails" name=".toStrictEqual() matches the expected snapshot when it fails" time="0.002">
    </testcase>
    <testcase classname=".toStrictEqual() does not pass for different types" name=".toStrictEqual() does not pass for different types" time="0">
    </testcase>
    <testcase classname=".toStrictEqual() does not simply compare constructor names" name=".toStrictEqual() does not simply compare constructor names" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(true).toEqual(false)" name=".toEqual() {pass: false} expect(true).toEqual(false)" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(1).toEqual(2)" name=".toEqual() {pass: false} expect(1).toEqual(2)" time="0">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(0).toEqual(-0)" name=".toEqual() {pass: false} expect(0).toEqual(-0)" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect({&quot;a&quot;: 5}).toEqual({&quot;b&quot;: 6})" name=".toEqual() {pass: false} expect({&quot;a&quot;: 5}).toEqual({&quot;b&quot;: 6})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(&quot;banana&quot;).toEqual(&quot;apple&quot;)" name=".toEqual() {pass: false} expect(&quot;banana&quot;).toEqual(&quot;apple&quot;)" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(null).toEqual(undefined)" name=".toEqual() {pass: false} expect(null).toEqual(undefined)" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect([1]).toEqual([2])" name=".toEqual() {pass: false} expect([1]).toEqual([2])" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect([1, 2]).toEqual([2, 1])" name=".toEqual() {pass: false} expect([1, 2]).toEqual([2, 1])" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.List [1]).toEqual(Immutable.List [2])" name=".toEqual() {pass: false} expect(Immutable.List [1]).toEqual(Immutable.List [2])" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.List [1, 2]).toEqual(Immutable.List [2, 1])" name=".toEqual() {pass: false} expect(Immutable.List [1, 2]).toEqual(Immutable.List [2, 1])" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Map {}).toEqual(Set {})" name=".toEqual() {pass: false} expect(Map {}).toEqual(Set {})" time="0">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Set {1, 2}).toEqual(Set {})" name=".toEqual() {pass: false} expect(Set {1, 2}).toEqual(Set {})" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Set {1, 2}).toEqual(Set {1, 2, 3})" name=".toEqual() {pass: false} expect(Set {1, 2}).toEqual(Set {1, 2, 3})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Set {[1], [2]}).toEqual(Set {[1], [2], [3]})" name=".toEqual() {pass: false} expect(Set {[1], [2]}).toEqual(Set {[1], [2], [3]})" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Set {[1], [2]}).toEqual(Set {[1], [2], [2]})" name=".toEqual() {pass: false} expect(Set {[1], [2]}).toEqual(Set {[1], [2], [2]})" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Set {Set {1}, Set {2}}).toEqual(Set {Set {1}, Set {3}})" name=".toEqual() {pass: false} expect(Set {Set {1}, Set {2}}).toEqual(Set {Set {1}, Set {3}})" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.Set [1, 2]).toEqual(Immutable.Set [])" name=".toEqual() {pass: false} expect(Immutable.Set [1, 2]).toEqual(Immutable.Set [])" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.Set [1, 2]).toEqual(Immutable.Set [1, 2, 3])" name=".toEqual() {pass: false} expect(Immutable.Set [1, 2]).toEqual(Immutable.Set [1, 2, 3])" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.OrderedSet [1, 2]).toEqual(Immutable.OrderedSet [2, 1])" name=".toEqual() {pass: false} expect(Immutable.OrderedSet [1, 2]).toEqual(Immutable.OrderedSet [2, 1])" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Map {1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;}).toEqual(Map {1 =&gt; &quot;one&quot;})" name=".toEqual() {pass: false} expect(Map {1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;}).toEqual(Map {1 =&gt; &quot;one&quot;})" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Map {&quot;a&quot; =&gt; 0}).toEqual(Map {&quot;b&quot; =&gt; 0})" name=".toEqual() {pass: false} expect(Map {&quot;a&quot; =&gt; 0}).toEqual(Map {&quot;b&quot; =&gt; 0})" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Map {&quot;v&quot; =&gt; 1}).toEqual(Map {&quot;v&quot; =&gt; 2})" name=".toEqual() {pass: false} expect(Map {&quot;v&quot; =&gt; 1}).toEqual(Map {&quot;v&quot; =&gt; 2})" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Map {[&quot;v&quot;] =&gt; 1}).toEqual(Map {[&quot;v&quot;] =&gt; 2})" name=".toEqual() {pass: false} expect(Map {[&quot;v&quot;] =&gt; 1}).toEqual(Map {[&quot;v&quot;] =&gt; 2})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Map {[1] =&gt; Map {[1] =&gt; &quot;one&quot;}}).toEqual(Map {[1] =&gt; Map {[1] =&gt; &quot;two&quot;}})" name=".toEqual() {pass: false} expect(Map {[1] =&gt; Map {[1] =&gt; &quot;one&quot;}}).toEqual(Map {[1] =&gt; Map {[1] =&gt; &quot;two&quot;}})" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.Map {&quot;a&quot;: 0}).toEqual(Immutable.Map {&quot;b&quot;: 0})" name=".toEqual() {pass: false} expect(Immutable.Map {&quot;a&quot;: 0}).toEqual(Immutable.Map {&quot;b&quot;: 0})" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.Map {&quot;v&quot;: 1}).toEqual(Immutable.Map {&quot;v&quot;: 2})" name=".toEqual() {pass: false} expect(Immutable.Map {&quot;v&quot;: 1}).toEqual(Immutable.Map {&quot;v&quot;: 2})" time="0.003">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.OrderedMap {1: &quot;one&quot;, 2: &quot;two&quot;}).toEqual(Immutable.OrderedMap {2: &quot;two&quot;, 1: &quot;one&quot;})" name=".toEqual() {pass: false} expect(Immutable.OrderedMap {1: &quot;one&quot;, 2: &quot;two&quot;}).toEqual(Immutable.OrderedMap {2: &quot;two&quot;, 1: &quot;one&quot;})" time="0.003">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.Map {&quot;1&quot;: Immutable.Map {&quot;2&quot;: {&quot;a&quot;: 99}}}).toEqual(Immutable.Map {&quot;1&quot;: Immutable.Map {&quot;2&quot;: {&quot;a&quot;: 11}}})" name=".toEqual() {pass: false} expect(Immutable.Map {&quot;1&quot;: Immutable.Map {&quot;2&quot;: {&quot;a&quot;: 99}}}).toEqual(Immutable.Map {&quot;1&quot;: Immutable.Map {&quot;2&quot;: {&quot;a&quot;: 11}}})" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect({&quot;a&quot;: 1, &quot;b&quot;: 2}).toEqual(ObjectContaining {&quot;a&quot;: 2})" name=".toEqual() {pass: false} expect({&quot;a&quot;: 1, &quot;b&quot;: 2}).toEqual(ObjectContaining {&quot;a&quot;: 2})" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(false).toEqual(ObjectContaining {&quot;a&quot;: 2})" name=".toEqual() {pass: false} expect(false).toEqual(ObjectContaining {&quot;a&quot;: 2})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect([1, 3]).toEqual(ArrayContaining [1, 2])" name=".toEqual() {pass: false} expect([1, 3]).toEqual(ArrayContaining [1, 2])" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(1).toEqual(ArrayContaining [1, 2])" name=".toEqual() {pass: false} expect(1).toEqual(ArrayContaining [1, 2])" time="0">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(&quot;abd&quot;).toEqual(StringContaining &quot;bc&quot;)" name=".toEqual() {pass: false} expect(&quot;abd&quot;).toEqual(StringContaining &quot;bc&quot;)" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(&quot;abd&quot;).toEqual(StringMatching /bc/i)" name=".toEqual() {pass: false} expect(&quot;abd&quot;).toEqual(StringMatching /bc/i)" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(undefined).toEqual(Anything)" name=".toEqual() {pass: false} expect(undefined).toEqual(Anything)" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(undefined).toEqual(Any&lt;Function&gt;)" name=".toEqual() {pass: false} expect(undefined).toEqual(Any&lt;Function&gt;)" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(&quot;Eve&quot;).toEqual({&quot;asymmetricMatch&quot;: [Function asymmetricMatch]})" name=".toEqual() {pass: false} expect(&quot;Eve&quot;).toEqual({&quot;asymmetricMatch&quot;: [Function asymmetricMatch]})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect({&quot;target&quot;: {&quot;nodeType&quot;: 1, &quot;value&quot;: &quot;a&quot;}}).toEqual({&quot;target&quot;: {&quot;nodeType&quot;: 1, &quot;value&quot;: &quot;b&quot;}})" name=".toEqual() {pass: false} expect({&quot;target&quot;: {&quot;nodeType&quot;: 1, &quot;value&quot;: &quot;a&quot;}}).toEqual({&quot;target&quot;: {&quot;nodeType&quot;: 1, &quot;value&quot;: &quot;b&quot;}})" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(true).not.toEqual(true)" name=".toEqual() {pass: false} expect(true).not.toEqual(true)" time="0">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(1).not.toEqual(1)" name=".toEqual() {pass: false} expect(1).not.toEqual(1)" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(&quot;abc&quot;).not.toEqual(&quot;abc&quot;)" name=".toEqual() {pass: false} expect(&quot;abc&quot;).not.toEqual(&quot;abc&quot;)" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect([1]).not.toEqual([1])" name=".toEqual() {pass: false} expect([1]).not.toEqual([1])" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect([1, 2]).not.toEqual([1, 2])" name=".toEqual() {pass: false} expect([1, 2]).not.toEqual([1, 2])" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.List [1]).not.toEqual(Immutable.List [1])" name=".toEqual() {pass: false} expect(Immutable.List [1]).not.toEqual(Immutable.List [1])" time="0.005">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.List [1, 2]).not.toEqual(Immutable.List [1, 2])" name=".toEqual() {pass: false} expect(Immutable.List [1, 2]).not.toEqual(Immutable.List [1, 2])" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect({}).not.toEqual({})" name=".toEqual() {pass: false} expect({}).not.toEqual({})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect({&quot;a&quot;: 99}).not.toEqual({&quot;a&quot;: 99})" name=".toEqual() {pass: false} expect({&quot;a&quot;: 99}).not.toEqual({&quot;a&quot;: 99})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Set {}).not.toEqual(Set {})" name=".toEqual() {pass: false} expect(Set {}).not.toEqual(Set {})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Set {1, 2}).not.toEqual(Set {1, 2})" name=".toEqual() {pass: false} expect(Set {1, 2}).not.toEqual(Set {1, 2})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Set {1, 2}).not.toEqual(Set {2, 1})" name=".toEqual() {pass: false} expect(Set {1, 2}).not.toEqual(Set {2, 1})" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Set {[1], [2]}).not.toEqual(Set {[2], [1]})" name=".toEqual() {pass: false} expect(Set {[1], [2]}).not.toEqual(Set {[2], [1]})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Set {Set {[1]}, Set {[2]}}).not.toEqual(Set {Set {[2]}, Set {[1]}})" name=".toEqual() {pass: false} expect(Set {Set {[1]}, Set {[2]}}).not.toEqual(Set {Set {[2]}, Set {[1]}})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Set {[1], [2], [3], [3]}).not.toEqual(Set {[3], [3], [2], [1]})" name=".toEqual() {pass: false} expect(Set {[1], [2], [3], [3]}).not.toEqual(Set {[3], [3], [2], [1]})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Set {{&quot;a&quot;: 1}, {&quot;b&quot;: 2}}).not.toEqual(Set {{&quot;b&quot;: 2}, {&quot;a&quot;: 1}})" name=".toEqual() {pass: false} expect(Set {{&quot;a&quot;: 1}, {&quot;b&quot;: 2}}).not.toEqual(Set {{&quot;b&quot;: 2}, {&quot;a&quot;: 1}})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.Set []).not.toEqual(Immutable.Set [])" name=".toEqual() {pass: false} expect(Immutable.Set []).not.toEqual(Immutable.Set [])" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.Set [1, 2]).not.toEqual(Immutable.Set [1, 2])" name=".toEqual() {pass: false} expect(Immutable.Set [1, 2]).not.toEqual(Immutable.Set [1, 2])" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.Set [1, 2]).not.toEqual(Immutable.Set [2, 1])" name=".toEqual() {pass: false} expect(Immutable.Set [1, 2]).not.toEqual(Immutable.Set [2, 1])" time="0">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.OrderedSet []).not.toEqual(Immutable.OrderedSet [])" name=".toEqual() {pass: false} expect(Immutable.OrderedSet []).not.toEqual(Immutable.OrderedSet [])" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.OrderedSet [1, 2]).not.toEqual(Immutable.OrderedSet [1, 2])" name=".toEqual() {pass: false} expect(Immutable.OrderedSet [1, 2]).not.toEqual(Immutable.OrderedSet [1, 2])" time="0">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Map {}).not.toEqual(Map {})" name=".toEqual() {pass: false} expect(Map {}).not.toEqual(Map {})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Map {1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;}).not.toEqual(Map {1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;})" name=".toEqual() {pass: false} expect(Map {1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;}).not.toEqual(Map {1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Map {1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;}).not.toEqual(Map {2 =&gt; &quot;two&quot;, 1 =&gt; &quot;one&quot;})" name=".toEqual() {pass: false} expect(Map {1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;}).not.toEqual(Map {2 =&gt; &quot;two&quot;, 1 =&gt; &quot;one&quot;})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Map {[1] =&gt; &quot;one&quot;, [2] =&gt; &quot;two&quot;, [3] =&gt; &quot;three&quot;, [3] =&gt; &quot;four&quot;}).not.toEqual(Map {[3] =&gt; &quot;three&quot;, [3] =&gt; &quot;four&quot;, [2] =&gt; &quot;two&quot;, [1] =&gt; &quot;one&quot;})" name=".toEqual() {pass: false} expect(Map {[1] =&gt; &quot;one&quot;, [2] =&gt; &quot;two&quot;, [3] =&gt; &quot;three&quot;, [3] =&gt; &quot;four&quot;}).not.toEqual(Map {[3] =&gt; &quot;three&quot;, [3] =&gt; &quot;four&quot;, [2] =&gt; &quot;two&quot;, [1] =&gt; &quot;one&quot;})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Map {[1] =&gt; Map {[1] =&gt; &quot;one&quot;}, [2] =&gt; Map {[2] =&gt; &quot;two&quot;}}).not.toEqual(Map {[2] =&gt; Map {[2] =&gt; &quot;two&quot;}, [1] =&gt; Map {[1] =&gt; &quot;one&quot;}})" name=".toEqual() {pass: false} expect(Map {[1] =&gt; Map {[1] =&gt; &quot;one&quot;}, [2] =&gt; Map {[2] =&gt; &quot;two&quot;}}).not.toEqual(Map {[2] =&gt; Map {[2] =&gt; &quot;two&quot;}, [1] =&gt; Map {[1] =&gt; &quot;one&quot;}})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Map {[1] =&gt; &quot;one&quot;, [2] =&gt; &quot;two&quot;}).not.toEqual(Map {[2] =&gt; &quot;two&quot;, [1] =&gt; &quot;one&quot;})" name=".toEqual() {pass: false} expect(Map {[1] =&gt; &quot;one&quot;, [2] =&gt; &quot;two&quot;}).not.toEqual(Map {[2] =&gt; &quot;two&quot;, [1] =&gt; &quot;one&quot;})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Map {{&quot;a&quot;: 1} =&gt; &quot;one&quot;, {&quot;b&quot;: 2} =&gt; &quot;two&quot;}).not.toEqual(Map {{&quot;b&quot;: 2} =&gt; &quot;two&quot;, {&quot;a&quot;: 1} =&gt; &quot;one&quot;})" name=".toEqual() {pass: false} expect(Map {{&quot;a&quot;: 1} =&gt; &quot;one&quot;, {&quot;b&quot;: 2} =&gt; &quot;two&quot;}).not.toEqual(Map {{&quot;b&quot;: 2} =&gt; &quot;two&quot;, {&quot;a&quot;: 1} =&gt; &quot;one&quot;})" time="0">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Map {1 =&gt; [&quot;one&quot;], 2 =&gt; [&quot;two&quot;]}).not.toEqual(Map {2 =&gt; [&quot;two&quot;], 1 =&gt; [&quot;one&quot;]})" name=".toEqual() {pass: false} expect(Map {1 =&gt; [&quot;one&quot;], 2 =&gt; [&quot;two&quot;]}).not.toEqual(Map {2 =&gt; [&quot;two&quot;], 1 =&gt; [&quot;one&quot;]})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.Map {}).not.toEqual(Immutable.Map {})" name=".toEqual() {pass: false} expect(Immutable.Map {}).not.toEqual(Immutable.Map {})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.Map {1: &quot;one&quot;, 2: &quot;two&quot;}).not.toEqual(Immutable.Map {1: &quot;one&quot;, 2: &quot;two&quot;})" name=".toEqual() {pass: false} expect(Immutable.Map {1: &quot;one&quot;, 2: &quot;two&quot;}).not.toEqual(Immutable.Map {1: &quot;one&quot;, 2: &quot;two&quot;})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.Map {1: &quot;one&quot;, 2: &quot;two&quot;}).not.toEqual(Immutable.Map {2: &quot;two&quot;, 1: &quot;one&quot;})" name=".toEqual() {pass: false} expect(Immutable.Map {1: &quot;one&quot;, 2: &quot;two&quot;}).not.toEqual(Immutable.Map {2: &quot;two&quot;, 1: &quot;one&quot;})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.OrderedMap {1: &quot;one&quot;, 2: &quot;two&quot;}).not.toEqual(Immutable.OrderedMap {1: &quot;one&quot;, 2: &quot;two&quot;})" name=".toEqual() {pass: false} expect(Immutable.OrderedMap {1: &quot;one&quot;, 2: &quot;two&quot;}).not.toEqual(Immutable.OrderedMap {1: &quot;one&quot;, 2: &quot;two&quot;})" time="0">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(Immutable.Map {&quot;1&quot;: Immutable.Map {&quot;2&quot;: {&quot;a&quot;: 99}}}).not.toEqual(Immutable.Map {&quot;1&quot;: Immutable.Map {&quot;2&quot;: {&quot;a&quot;: 99}}})" name=".toEqual() {pass: false} expect(Immutable.Map {&quot;1&quot;: Immutable.Map {&quot;2&quot;: {&quot;a&quot;: 99}}}).not.toEqual(Immutable.Map {&quot;1&quot;: Immutable.Map {&quot;2&quot;: {&quot;a&quot;: 99}}})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect({&quot;a&quot;: 1, &quot;b&quot;: 2}).not.toEqual(ObjectContaining {&quot;a&quot;: 1})" name=".toEqual() {pass: false} expect({&quot;a&quot;: 1, &quot;b&quot;: 2}).not.toEqual(ObjectContaining {&quot;a&quot;: 1})" time="0.002">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect([1, 2, 3]).not.toEqual(ArrayContaining [2, 3])" name=".toEqual() {pass: false} expect([1, 2, 3]).not.toEqual(ArrayContaining [2, 3])" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(&quot;abcd&quot;).not.toEqual(StringContaining &quot;bc&quot;)" name=".toEqual() {pass: false} expect(&quot;abcd&quot;).not.toEqual(StringContaining &quot;bc&quot;)" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(&quot;abcd&quot;).not.toEqual(StringMatching /bc/)" name=".toEqual() {pass: false} expect(&quot;abcd&quot;).not.toEqual(StringMatching /bc/)" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(true).not.toEqual(Anything)" name=".toEqual() {pass: false} expect(true).not.toEqual(Anything)" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect([Function anonymous]).not.toEqual(Any&lt;Function&gt;)" name=".toEqual() {pass: false} expect([Function anonymous]).not.toEqual(Any&lt;Function&gt;)" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect({&quot;a&quot;: 1, &quot;b&quot;: [Function b], &quot;c&quot;: true}).not.toEqual({&quot;a&quot;: 1, &quot;b&quot;: Any&lt;Function&gt;, &quot;c&quot;: Anything})" name=".toEqual() {pass: false} expect({&quot;a&quot;: 1, &quot;b&quot;: [Function b], &quot;c&quot;: true}).not.toEqual({&quot;a&quot;: 1, &quot;b&quot;: Any&lt;Function&gt;, &quot;c&quot;: Anything})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() {pass: false} expect(&quot;Alice&quot;).not.toEqual({&quot;asymmetricMatch&quot;: [Function asymmetricMatch]})" name=".toEqual() {pass: false} expect(&quot;Alice&quot;).not.toEqual({&quot;asymmetricMatch&quot;: [Function asymmetricMatch]})" time="0.001">
    </testcase>
    <testcase classname=".toEqual() assertion error matcherResult property contains matcher name, expected and actual values" name=".toEqual() assertion error matcherResult property contains matcher name, expected and actual values" time="0.002">
    </testcase>
    <testcase classname=".toEqual() symbol based keys in arrays are processed correctly" name=".toEqual() symbol based keys in arrays are processed correctly" time="0">
    </testcase>
    <testcase classname=".toEqual() non-enumerable members should be skipped during equal" name=".toEqual() non-enumerable members should be skipped during equal" time="0.001">
    </testcase>
    <testcase classname=".toEqual() non-enumerable symbolic members should be skipped during equal" name=".toEqual() non-enumerable symbolic members should be skipped during equal" time="0">
    </testcase>
    <testcase classname=".toBeInstanceOf() passing Map {} and [Function Map]" name=".toBeInstanceOf() passing Map {} and [Function Map]" time="0.001">
    </testcase>
    <testcase classname=".toBeInstanceOf() passing [] and [Function Array]" name=".toBeInstanceOf() passing [] and [Function Array]" time="0.001">
    </testcase>
    <testcase classname=".toBeInstanceOf() passing {} and [Function A]" name=".toBeInstanceOf() passing {} and [Function A]" time="0.001">
    </testcase>
    <testcase classname=".toBeInstanceOf() failing &quot;a&quot; and [Function String]" name=".toBeInstanceOf() failing &quot;a&quot; and [Function String]" time="0.002">
    </testcase>
    <testcase classname=".toBeInstanceOf() failing 1 and [Function Number]" name=".toBeInstanceOf() failing 1 and [Function Number]" time="0.001">
    </testcase>
    <testcase classname=".toBeInstanceOf() failing true and [Function Boolean]" name=".toBeInstanceOf() failing true and [Function Boolean]" time="0.001">
    </testcase>
    <testcase classname=".toBeInstanceOf() failing {} and [Function B]" name=".toBeInstanceOf() failing {} and [Function B]" time="0.001">
    </testcase>
    <testcase classname=".toBeInstanceOf() failing {} and [Function A]" name=".toBeInstanceOf() failing {} and [Function A]" time="0.001">
    </testcase>
    <testcase classname=".toBeInstanceOf() failing undefined and [Function String]" name=".toBeInstanceOf() failing undefined and [Function String]" time="0.002">
    </testcase>
    <testcase classname=".toBeInstanceOf() failing null and [Function String]" name=".toBeInstanceOf() failing null and [Function String]" time="0.001">
    </testcase>
    <testcase classname=".toBeInstanceOf() throws if constructor is not a function" name=".toBeInstanceOf() throws if constructor is not a function" time="0">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() does not accept arguments" name=".toBeTruthy(), .toBeFalsy() does not accept arguments" time="0.001">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;{}&apos; is truthy" name=".toBeTruthy(), .toBeFalsy() &apos;{}&apos; is truthy" time="0.002">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;[]&apos; is truthy" name=".toBeTruthy(), .toBeFalsy() &apos;[]&apos; is truthy" time="0.002">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;true&apos; is truthy" name=".toBeTruthy(), .toBeFalsy() &apos;true&apos; is truthy" time="0.001">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;1&apos; is truthy" name=".toBeTruthy(), .toBeFalsy() &apos;1&apos; is truthy" time="0.001">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;&quot;a&quot;&apos; is truthy" name=".toBeTruthy(), .toBeFalsy() &apos;&quot;a&quot;&apos; is truthy" time="0.001">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;0.5&apos; is truthy" name=".toBeTruthy(), .toBeFalsy() &apos;0.5&apos; is truthy" time="0.001">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;Map {}&apos; is truthy" name=".toBeTruthy(), .toBeFalsy() &apos;Map {}&apos; is truthy" time="0.006">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;[Function anonymous]&apos; is truthy" name=".toBeTruthy(), .toBeFalsy() &apos;[Function anonymous]&apos; is truthy" time="0.003">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;Infinity&apos; is truthy" name=".toBeTruthy(), .toBeFalsy() &apos;Infinity&apos; is truthy" time="0.004">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;false&apos; is falsy" name=".toBeTruthy(), .toBeFalsy() &apos;false&apos; is falsy" time="0.003">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;null&apos; is falsy" name=".toBeTruthy(), .toBeFalsy() &apos;null&apos; is falsy" time="0.002">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;NaN&apos; is falsy" name=".toBeTruthy(), .toBeFalsy() &apos;NaN&apos; is falsy" time="0.003">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;0&apos; is falsy" name=".toBeTruthy(), .toBeFalsy() &apos;0&apos; is falsy" time="0.004">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;&quot;&quot;&apos; is falsy" name=".toBeTruthy(), .toBeFalsy() &apos;&quot;&quot;&apos; is falsy" time="0.003">
    </testcase>
    <testcase classname=".toBeTruthy(), .toBeFalsy() &apos;undefined&apos; is falsy" name=".toBeTruthy(), .toBeFalsy() &apos;undefined&apos; is falsy" time="0.002">
    </testcase>
    <testcase classname=".toBeNaN() {pass: true} expect(NaN).toBeNaN()" name=".toBeNaN() {pass: true} expect(NaN).toBeNaN()" time="0.006">
    </testcase>
    <testcase classname=".toBeNaN() throws" name=".toBeNaN() throws" time="0.023">
    </testcase>
    <testcase classname=".toBeNull() fails for &apos;{}&apos; with .not" name=".toBeNull() fails for &apos;{}&apos; with .not" time="0.002">
    </testcase>
    <testcase classname=".toBeNull() fails for &apos;[]&apos; with .not" name=".toBeNull() fails for &apos;[]&apos; with .not" time="0.001">
    </testcase>
    <testcase classname=".toBeNull() fails for &apos;true&apos; with .not" name=".toBeNull() fails for &apos;true&apos; with .not" time="0.002">
    </testcase>
    <testcase classname=".toBeNull() fails for &apos;1&apos; with .not" name=".toBeNull() fails for &apos;1&apos; with .not" time="0.001">
    </testcase>
    <testcase classname=".toBeNull() fails for &apos;&quot;a&quot;&apos; with .not" name=".toBeNull() fails for &apos;&quot;a&quot;&apos; with .not" time="0.002">
    </testcase>
    <testcase classname=".toBeNull() fails for &apos;0.5&apos; with .not" name=".toBeNull() fails for &apos;0.5&apos; with .not" time="0.001">
    </testcase>
    <testcase classname=".toBeNull() fails for &apos;Map {}&apos; with .not" name=".toBeNull() fails for &apos;Map {}&apos; with .not" time="0.001">
    </testcase>
    <testcase classname=".toBeNull() fails for &apos;[Function anonymous]&apos; with .not" name=".toBeNull() fails for &apos;[Function anonymous]&apos; with .not" time="0.002">
    </testcase>
    <testcase classname=".toBeNull() fails for &apos;Infinity&apos; with .not" name=".toBeNull() fails for &apos;Infinity&apos; with .not" time="0.003">
    </testcase>
    <testcase classname=".toBeNull() pass for null" name=".toBeNull() pass for null" time="0.001">
    </testcase>
    <testcase classname=".toBeDefined(), .toBeUndefined() &apos;{}&apos; is defined" name=".toBeDefined(), .toBeUndefined() &apos;{}&apos; is defined" time="0.002">
    </testcase>
    <testcase classname=".toBeDefined(), .toBeUndefined() &apos;[]&apos; is defined" name=".toBeDefined(), .toBeUndefined() &apos;[]&apos; is defined" time="0.002">
    </testcase>
    <testcase classname=".toBeDefined(), .toBeUndefined() &apos;true&apos; is defined" name=".toBeDefined(), .toBeUndefined() &apos;true&apos; is defined" time="0.002">
    </testcase>
    <testcase classname=".toBeDefined(), .toBeUndefined() &apos;1&apos; is defined" name=".toBeDefined(), .toBeUndefined() &apos;1&apos; is defined" time="0.002">
    </testcase>
    <testcase classname=".toBeDefined(), .toBeUndefined() &apos;&quot;a&quot;&apos; is defined" name=".toBeDefined(), .toBeUndefined() &apos;&quot;a&quot;&apos; is defined" time="0.008">
    </testcase>
    <testcase classname=".toBeDefined(), .toBeUndefined() &apos;0.5&apos; is defined" name=".toBeDefined(), .toBeUndefined() &apos;0.5&apos; is defined" time="0.015">
    </testcase>
    <testcase classname=".toBeDefined(), .toBeUndefined() &apos;Map {}&apos; is defined" name=".toBeDefined(), .toBeUndefined() &apos;Map {}&apos; is defined" time="0.002">
    </testcase>
    <testcase classname=".toBeDefined(), .toBeUndefined() &apos;[Function anonymous]&apos; is defined" name=".toBeDefined(), .toBeUndefined() &apos;[Function anonymous]&apos; is defined" time="0.002">
    </testcase>
    <testcase classname=".toBeDefined(), .toBeUndefined() &apos;Infinity&apos; is defined" name=".toBeDefined(), .toBeUndefined() &apos;Infinity&apos; is defined" time="0.002">
    </testcase>
    <testcase classname=".toBeDefined(), .toBeUndefined() undefined is undefined" name=".toBeDefined(), .toBeUndefined() undefined is undefined" time="0.004">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(1).toBeLessThan(2)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(1).toBeLessThan(2)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(2).toBeLessThan(1)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(2).toBeLessThan(1)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(2).toBeGreaterThan(1)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(2).toBeGreaterThan(1)" time="0.001">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(1).toBeGreaterThan(2)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(1).toBeGreaterThan(2)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(1).toBeLessThanOrEqual(2)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(1).toBeLessThanOrEqual(2)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(2).toBeLessThanOrEqual(1)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(2).toBeLessThanOrEqual(1)" time="0.001">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(2).toBeGreaterThanOrEqual(1)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(2).toBeGreaterThanOrEqual(1)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(1).toBeGreaterThanOrEqual(2)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(1).toBeGreaterThanOrEqual(2)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [1, 2]" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [1, 2]" time="0.008">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(-Infinity).toBeLessThan(Infinity)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(-Infinity).toBeLessThan(Infinity)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(Infinity).toBeLessThan(-Infinity)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(Infinity).toBeLessThan(-Infinity)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(Infinity).toBeGreaterThan(-Infinity)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(Infinity).toBeGreaterThan(-Infinity)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(-Infinity).toBeGreaterThan(Infinity)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(-Infinity).toBeGreaterThan(Infinity)" time="0.001">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(-Infinity).toBeLessThanOrEqual(Infinity)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(-Infinity).toBeLessThanOrEqual(Infinity)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(Infinity).toBeLessThanOrEqual(-Infinity)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(Infinity).toBeLessThanOrEqual(-Infinity)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(Infinity).toBeGreaterThanOrEqual(-Infinity)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(Infinity).toBeGreaterThanOrEqual(-Infinity)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(-Infinity).toBeGreaterThanOrEqual(Infinity)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(-Infinity).toBeGreaterThanOrEqual(Infinity)" time="0.001">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [-Infinity, Infinity]" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [-Infinity, Infinity]" time="0.006">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(5e-324).toBeLessThan(1.7976931348623157e+308)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(5e-324).toBeLessThan(1.7976931348623157e+308)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(1.7976931348623157e+308).toBeLessThan(5e-324)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(1.7976931348623157e+308).toBeLessThan(5e-324)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(1.7976931348623157e+308).toBeGreaterThan(5e-324)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(1.7976931348623157e+308).toBeGreaterThan(5e-324)" time="0.001">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(5e-324).toBeGreaterThan(1.7976931348623157e+308)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(5e-324).toBeGreaterThan(1.7976931348623157e+308)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(5e-324).toBeLessThanOrEqual(1.7976931348623157e+308)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(5e-324).toBeLessThanOrEqual(1.7976931348623157e+308)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(1.7976931348623157e+308).toBeLessThanOrEqual(5e-324)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(1.7976931348623157e+308).toBeLessThanOrEqual(5e-324)" time="0.001">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(1.7976931348623157e+308).toBeGreaterThanOrEqual(5e-324)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(1.7976931348623157e+308).toBeGreaterThanOrEqual(5e-324)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(5e-324).toBeGreaterThanOrEqual(1.7976931348623157e+308)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(5e-324).toBeGreaterThanOrEqual(1.7976931348623157e+308)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [5e-324, 1.7976931348623157e+308]" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [5e-324, 1.7976931348623157e+308]" time="0.006">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(17).toBeLessThan(34)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(17).toBeLessThan(34)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(34).toBeLessThan(17)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(34).toBeLessThan(17)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(34).toBeGreaterThan(17)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(34).toBeGreaterThan(17)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(17).toBeGreaterThan(34)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(17).toBeGreaterThan(34)" time="0.001">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(17).toBeLessThanOrEqual(34)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(17).toBeLessThanOrEqual(34)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(34).toBeLessThanOrEqual(17)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(34).toBeLessThanOrEqual(17)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(34).toBeGreaterThanOrEqual(17)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(34).toBeGreaterThanOrEqual(17)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(17).toBeGreaterThanOrEqual(34)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(17).toBeGreaterThanOrEqual(34)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [17, 34]" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [17, 34]" time="0.006">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(3).toBeLessThan(7)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(3).toBeLessThan(7)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(7).toBeLessThan(3)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(7).toBeLessThan(3)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(7).toBeGreaterThan(3)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(7).toBeGreaterThan(3)" time="0.001">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(3).toBeGreaterThan(7)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(3).toBeGreaterThan(7)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(3).toBeLessThanOrEqual(7)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(3).toBeLessThanOrEqual(7)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(7).toBeLessThanOrEqual(3)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(7).toBeLessThanOrEqual(3)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(7).toBeGreaterThanOrEqual(3)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(7).toBeGreaterThanOrEqual(3)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(3).toBeGreaterThanOrEqual(7)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(3).toBeGreaterThanOrEqual(7)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [3, 7]" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [3, 7]" time="0.005">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(9).toBeLessThan(18)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(9).toBeLessThan(18)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(18).toBeLessThan(9)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(18).toBeLessThan(9)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(18).toBeGreaterThan(9)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(18).toBeGreaterThan(9)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(9).toBeGreaterThan(18)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(9).toBeGreaterThan(18)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(9).toBeLessThanOrEqual(18)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(9).toBeLessThanOrEqual(18)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(18).toBeLessThanOrEqual(9)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(18).toBeLessThanOrEqual(9)" time="0.001">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(18).toBeGreaterThanOrEqual(9)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(18).toBeGreaterThanOrEqual(9)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(9).toBeGreaterThanOrEqual(18)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(9).toBeGreaterThanOrEqual(18)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [9, 18]" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [9, 18]" time="0.004">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(0.1).toBeLessThan(0.2)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(0.1).toBeLessThan(0.2)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(0.2).toBeLessThan(0.1)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(0.2).toBeLessThan(0.1)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(0.2).toBeGreaterThan(0.1)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(0.2).toBeGreaterThan(0.1)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(0.1).toBeGreaterThan(0.2)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(0.1).toBeGreaterThan(0.2)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(0.1).toBeLessThanOrEqual(0.2)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(0.1).toBeLessThanOrEqual(0.2)" time="0.001">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(0.2).toBeLessThanOrEqual(0.1)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(0.2).toBeLessThanOrEqual(0.1)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(0.2).toBeGreaterThanOrEqual(0.1)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: true} expect(0.2).toBeGreaterThanOrEqual(0.1)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(0.1).toBeGreaterThanOrEqual(0.2)" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() {pass: false} expect(0.1).toBeGreaterThanOrEqual(0.2)" time="0">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [0.1, 0.2]" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [0.1, 0.2]" time="0.004">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [1, 1]" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [1, 1]" time="0.004">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [5e-324, 5e-324]" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [5e-324, 5e-324]" time="0.001">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [1.7976931348623157e+308, 1.7976931348623157e+308]" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [1.7976931348623157e+308, 1.7976931348623157e+308]" time="0.001">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [Infinity, Infinity]" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [Infinity, Infinity]" time="0.001">
    </testcase>
    <testcase classname=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [-Infinity, -Infinity]" name=".toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [-Infinity, -Infinity]" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() iterable" name=".toContain(), .toContainEqual() iterable" time="0.002">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[1, 2, 3, 4]&apos; contains &apos;1&apos;" name=".toContain(), .toContainEqual() &apos;[1, 2, 3, 4]&apos; contains &apos;1&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]&apos; contains &apos;&quot;a&quot;&apos;" name=".toContain(), .toContainEqual() &apos;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]&apos; contains &apos;&quot;a&quot;&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[undefined, null]&apos; contains &apos;null&apos;" name=".toContain(), .toContainEqual() &apos;[undefined, null]&apos; contains &apos;null&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[undefined, null]&apos; contains &apos;undefined&apos;" name=".toContain(), .toContainEqual() &apos;[undefined, null]&apos; contains &apos;undefined&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[Symbol(a)]&apos; contains &apos;Symbol(a)&apos;" name=".toContain(), .toContainEqual() &apos;[Symbol(a)]&apos; contains &apos;Symbol(a)&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;&quot;abcdef&quot;&apos; contains &apos;&quot;abc&quot;&apos;" name=".toContain(), .toContainEqual() &apos;&quot;abcdef&quot;&apos; contains &apos;&quot;abc&quot;&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;&quot;11112111&quot;&apos; contains &apos;&quot;2&quot;&apos;" name=".toContain(), .toContainEqual() &apos;&quot;11112111&quot;&apos; contains &apos;&quot;2&quot;&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;Set {&quot;abc&quot;, &quot;def&quot;}&apos; contains &apos;&quot;abc&quot;&apos;" name=".toContain(), .toContainEqual() &apos;Set {&quot;abc&quot;, &quot;def&quot;}&apos; contains &apos;&quot;abc&quot;&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[0, 1]&apos; contains &apos;1&apos;" name=".toContain(), .toContainEqual() &apos;[0, 1]&apos; contains &apos;1&apos;" time="0.002">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[1, 2, 3]&apos; does not contain &apos;4&apos;" name=".toContain(), .toContainEqual() &apos;[1, 2, 3]&apos; does not contain &apos;4&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[null, undefined]&apos; does not contain &apos;1&apos;" name=".toContain(), .toContainEqual() &apos;[null, undefined]&apos; does not contain &apos;1&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[{}, []]&apos; does not contain &apos;[]&apos;" name=".toContain(), .toContainEqual() &apos;[{}, []]&apos; does not contain &apos;[]&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[{}, []]&apos; does not contain &apos;{}&apos;" name=".toContain(), .toContainEqual() &apos;[{}, []]&apos; does not contain &apos;{}&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() error cases" name=".toContain(), .toContainEqual() error cases" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[1, 2, 3, 4]&apos; contains a value equal to &apos;1&apos;" name=".toContain(), .toContainEqual() &apos;[1, 2, 3, 4]&apos; contains a value equal to &apos;1&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]&apos; contains a value equal to &apos;&quot;a&quot;&apos;" name=".toContain(), .toContainEqual() &apos;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]&apos; contains a value equal to &apos;&quot;a&quot;&apos;" time="0">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[undefined, null]&apos; contains a value equal to &apos;null&apos;" name=".toContain(), .toContainEqual() &apos;[undefined, null]&apos; contains a value equal to &apos;null&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[undefined, null]&apos; contains a value equal to &apos;undefined&apos;" name=".toContain(), .toContainEqual() &apos;[undefined, null]&apos; contains a value equal to &apos;undefined&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[Symbol(a)]&apos; contains a value equal to &apos;Symbol(a)&apos;" name=".toContain(), .toContainEqual() &apos;[Symbol(a)]&apos; contains a value equal to &apos;Symbol(a)&apos;" time="0">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[{&quot;a&quot;: &quot;b&quot;}, {&quot;a&quot;: &quot;c&quot;}]&apos; contains a value equal to &apos;{&quot;a&quot;: &quot;b&quot;}&apos;" name=".toContain(), .toContainEqual() &apos;[{&quot;a&quot;: &quot;b&quot;}, {&quot;a&quot;: &quot;c&quot;}]&apos; contains a value equal to &apos;{&quot;a&quot;: &quot;b&quot;}&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;Set {1, 2, 3, 4}&apos; contains a value equal to &apos;1&apos;" name=".toContain(), .toContainEqual() &apos;Set {1, 2, 3, 4}&apos; contains a value equal to &apos;1&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[0, 1]&apos; contains a value equal to &apos;1&apos;" name=".toContain(), .toContainEqual() &apos;[0, 1]&apos; contains a value equal to &apos;1&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() &apos;[{&quot;a&quot;: &quot;b&quot;}, {&quot;a&quot;: &quot;c&quot;}]&apos; does not contain a value equal to&apos;{&quot;a&quot;: &quot;d&quot;}&apos;" name=".toContain(), .toContainEqual() &apos;[{&quot;a&quot;: &quot;b&quot;}, {&quot;a&quot;: &quot;c&quot;}]&apos; does not contain a value equal to&apos;{&quot;a&quot;: &quot;d&quot;}&apos;" time="0.001">
    </testcase>
    <testcase classname=".toContain(), .toContainEqual() error cases for toContainEqual" name=".toContain(), .toContainEqual() error cases for toContainEqual" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() {pass: true} expect(0)toBeCloseTo( 0)" name=".toBeCloseTo() {pass: true} expect(0)toBeCloseTo( 0)" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() {pass: true} expect(0)toBeCloseTo( 0.001)" name=".toBeCloseTo() {pass: true} expect(0)toBeCloseTo( 0.001)" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() {pass: true} expect(1.23)toBeCloseTo( 1.229)" name=".toBeCloseTo() {pass: true} expect(1.23)toBeCloseTo( 1.229)" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() {pass: true} expect(1.23)toBeCloseTo( 1.226)" name=".toBeCloseTo() {pass: true} expect(1.23)toBeCloseTo( 1.226)" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() {pass: true} expect(1.23)toBeCloseTo( 1.225)" name=".toBeCloseTo() {pass: true} expect(1.23)toBeCloseTo( 1.225)" time="0">
    </testcase>
    <testcase classname=".toBeCloseTo() {pass: true} expect(1.23)toBeCloseTo( 1.234)" name=".toBeCloseTo() {pass: true} expect(1.23)toBeCloseTo( 1.234)" time="0">
    </testcase>
    <testcase classname=".toBeCloseTo() throws: [0, 0.01]" name=".toBeCloseTo() throws: [0, 0.01]" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() throws: [1, 1.23]" name=".toBeCloseTo() throws: [1, 1.23]" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() throws: [1.23, 1.2249999]" name=".toBeCloseTo() throws: [1.23, 1.2249999]" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() {pass: true} expect(Infinity)toBeCloseTo( Infinity)" name=".toBeCloseTo() {pass: true} expect(Infinity)toBeCloseTo( Infinity)" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() {pass: true} expect(-Infinity)toBeCloseTo( -Infinity)" name=".toBeCloseTo() {pass: true} expect(-Infinity)toBeCloseTo( -Infinity)" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() {pass: false} expect(Infinity)toBeCloseTo( -Infinity)" name=".toBeCloseTo() {pass: false} expect(Infinity)toBeCloseTo( -Infinity)" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() {pass: false} expect(Infinity)toBeCloseTo( 1.23)" name=".toBeCloseTo() {pass: false} expect(Infinity)toBeCloseTo( 1.23)" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() {pass: false} expect(-Infinity)toBeCloseTo( -1.23)" name=".toBeCloseTo() {pass: false} expect(-Infinity)toBeCloseTo( -1.23)" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() accepts an optional precision argument: [0, 0.1, 0]" name=".toBeCloseTo() accepts an optional precision argument: [0, 0.1, 0]" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() accepts an optional precision argument: [0, 0.0001, 3]" name=".toBeCloseTo() accepts an optional precision argument: [0, 0.0001, 3]" time="0.001">
    </testcase>
    <testcase classname=".toBeCloseTo() accepts an optional precision argument: [0, 0.000004, 5]" name=".toBeCloseTo() accepts an optional precision argument: [0, 0.000004, 5]" time="0">
    </testcase>
    <testcase classname=".toMatch() {pass: true} expect(foo).toMatch(foo)" name=".toMatch() {pass: true} expect(foo).toMatch(foo)" time="0.001">
    </testcase>
    <testcase classname=".toMatch() {pass: true} expect(Foo bar).toMatch(/^foo/i)" name=".toMatch() {pass: true} expect(Foo bar).toMatch(/^foo/i)" time="0.001">
    </testcase>
    <testcase classname=".toMatch() throws: [bar, foo]" name=".toMatch() throws: [bar, foo]" time="0.002">
    </testcase>
    <testcase classname=".toMatch() throws: [bar, /foo/]" name=".toMatch() throws: [bar, /foo/]" time="0">
    </testcase>
    <testcase classname=".toMatch() throws if non String actual value passed: [1, &quot;foo&quot;]" name=".toMatch() throws if non String actual value passed: [1, &quot;foo&quot;]" time="0.003">
    </testcase>
    <testcase classname=".toMatch() throws if non String actual value passed: [{}, &quot;foo&quot;]" name=".toMatch() throws if non String actual value passed: [{}, &quot;foo&quot;]" time="0.001">
    </testcase>
    <testcase classname=".toMatch() throws if non String actual value passed: [[], &quot;foo&quot;]" name=".toMatch() throws if non String actual value passed: [[], &quot;foo&quot;]" time="0">
    </testcase>
    <testcase classname=".toMatch() throws if non String actual value passed: [true, &quot;foo&quot;]" name=".toMatch() throws if non String actual value passed: [true, &quot;foo&quot;]" time="0.001">
    </testcase>
    <testcase classname=".toMatch() throws if non String actual value passed: [/foo/i, &quot;foo&quot;]" name=".toMatch() throws if non String actual value passed: [/foo/i, &quot;foo&quot;]" time="0.001">
    </testcase>
    <testcase classname=".toMatch() throws if non String actual value passed: [[Function anonymous], &quot;foo&quot;]" name=".toMatch() throws if non String actual value passed: [[Function anonymous], &quot;foo&quot;]" time="0">
    </testcase>
    <testcase classname=".toMatch() throws if non String actual value passed: [undefined, &quot;foo&quot;]" name=".toMatch() throws if non String actual value passed: [undefined, &quot;foo&quot;]" time="0.001">
    </testcase>
    <testcase classname=".toMatch() throws if non String/RegExp expected value passed: [&quot;foo&quot;, 1]" name=".toMatch() throws if non String/RegExp expected value passed: [&quot;foo&quot;, 1]" time="0">
    </testcase>
    <testcase classname=".toMatch() throws if non String/RegExp expected value passed: [&quot;foo&quot;, {}]" name=".toMatch() throws if non String/RegExp expected value passed: [&quot;foo&quot;, {}]" time="0.001">
    </testcase>
    <testcase classname=".toMatch() throws if non String/RegExp expected value passed: [&quot;foo&quot;, []]" name=".toMatch() throws if non String/RegExp expected value passed: [&quot;foo&quot;, []]" time="0.001">
    </testcase>
    <testcase classname=".toMatch() throws if non String/RegExp expected value passed: [&quot;foo&quot;, true]" name=".toMatch() throws if non String/RegExp expected value passed: [&quot;foo&quot;, true]" time="0">
    </testcase>
    <testcase classname=".toMatch() throws if non String/RegExp expected value passed: [&quot;foo&quot;, [Function anonymous]]" name=".toMatch() throws if non String/RegExp expected value passed: [&quot;foo&quot;, [Function anonymous]]" time="0.001">
    </testcase>
    <testcase classname=".toMatch() throws if non String/RegExp expected value passed: [&quot;foo&quot;, undefined]" name=".toMatch() throws if non String/RegExp expected value passed: [&quot;foo&quot;, undefined]" time="0.001">
    </testcase>
    <testcase classname=".toMatch() escapes strings properly" name=".toMatch() escapes strings properly" time="0">
    </testcase>
    <testcase classname=".toHaveLength {pass: true} expect([1, 2]).toHaveLength(2)" name=".toHaveLength {pass: true} expect([1, 2]).toHaveLength(2)" time="0.001">
    </testcase>
    <testcase classname=".toHaveLength {pass: true} expect([]).toHaveLength(0)" name=".toHaveLength {pass: true} expect([]).toHaveLength(0)" time="0.001">
    </testcase>
    <testcase classname=".toHaveLength {pass: true} expect([&quot;a&quot;, &quot;b&quot;]).toHaveLength(2)" name=".toHaveLength {pass: true} expect([&quot;a&quot;, &quot;b&quot;]).toHaveLength(2)" time="0.001">
    </testcase>
    <testcase classname=".toHaveLength {pass: true} expect(&quot;abc&quot;).toHaveLength(3)" name=".toHaveLength {pass: true} expect(&quot;abc&quot;).toHaveLength(3)" time="0.001">
    </testcase>
    <testcase classname=".toHaveLength {pass: true} expect(&quot;&quot;).toHaveLength(0)" name=".toHaveLength {pass: true} expect(&quot;&quot;).toHaveLength(0)" time="0.001">
    </testcase>
    <testcase classname=".toHaveLength {pass: false} expect([1, 2]).toHaveLength(3)" name=".toHaveLength {pass: false} expect([1, 2]).toHaveLength(3)" time="0.001">
    </testcase>
    <testcase classname=".toHaveLength {pass: false} expect([]).toHaveLength(1)" name=".toHaveLength {pass: false} expect([]).toHaveLength(1)" time="0.001">
    </testcase>
    <testcase classname=".toHaveLength {pass: false} expect([&quot;a&quot;, &quot;b&quot;]).toHaveLength(99)" name=".toHaveLength {pass: false} expect([&quot;a&quot;, &quot;b&quot;]).toHaveLength(99)" time="0.001">
    </testcase>
    <testcase classname=".toHaveLength {pass: false} expect(&quot;abc&quot;).toHaveLength(66)" name=".toHaveLength {pass: false} expect(&quot;abc&quot;).toHaveLength(66)" time="0.001">
    </testcase>
    <testcase classname=".toHaveLength {pass: false} expect(&quot;&quot;).toHaveLength(1)" name=".toHaveLength {pass: false} expect(&quot;&quot;).toHaveLength(1)" time="0">
    </testcase>
    <testcase classname=".toHaveLength error cases" name=".toHaveLength error cases" time="0.002">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;d&quot;: 1}}}}).toHaveProperty(&apos;a.b.c.d&apos;, 1)" name=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;d&quot;: 1}}}}).toHaveProperty(&apos;a.b.c.d&apos;, 1)" time="0.002">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;d&quot;: 1}}}}).toHaveProperty(&apos;a,b,c,d&apos;, 1)" name=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;d&quot;: 1}}}}).toHaveProperty(&apos;a,b,c,d&apos;, 1)" time="0.002">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({&quot;a.b.c.d&quot;: 1}).toHaveProperty(&apos;a.b.c.d&apos;, 1)" name=".toHaveProperty() {pass: true} expect({&quot;a.b.c.d&quot;: 1}).toHaveProperty(&apos;a.b.c.d&apos;, 1)" time="0">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: [1, 2, 3]}}).toHaveProperty(&apos;a,b,1&apos;, 2)" name=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: [1, 2, 3]}}).toHaveProperty(&apos;a,b,1&apos;, 2)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({&quot;a&quot;: 0}).toHaveProperty(&apos;a&apos;, 0)" name=".toHaveProperty() {pass: true} expect({&quot;a&quot;: 0}).toHaveProperty(&apos;a&apos;, 0)" time="0">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: undefined}}).toHaveProperty(&apos;a.b&apos;, undefined)" name=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: undefined}}).toHaveProperty(&apos;a.b&apos;, undefined)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: 5}}}).toHaveProperty(&apos;a.b&apos;, {&quot;c&quot;: 5})" name=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: 5}}}).toHaveProperty(&apos;a.b&apos;, {&quot;c&quot;: 5})" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({&quot;property&quot;: 1}).toHaveProperty(&apos;property&apos;, 1)" name=".toHaveProperty() {pass: true} expect({&quot;property&quot;: 1}).toHaveProperty(&apos;property&apos;, 1)" time="0.002">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({}).toHaveProperty(&apos;a&apos;, undefined)" name=".toHaveProperty() {pass: true} expect({}).toHaveProperty(&apos;a&apos;, undefined)" time="0.002">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({}).toHaveProperty(&apos;b&apos;, &quot;b&quot;)" name=".toHaveProperty() {pass: true} expect({}).toHaveProperty(&apos;b&apos;, &quot;b&quot;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;d&quot;: 1}}}}).toHaveProperty(&apos;a.b.ttt.d&apos;, 1)" name=".toHaveProperty() {pass: false} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;d&quot;: 1}}}}).toHaveProperty(&apos;a.b.ttt.d&apos;, 1)" time="0.002">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;d&quot;: 1}}}}).toHaveProperty(&apos;a.b.c.d&apos;, 2)" name=".toHaveProperty() {pass: false} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;d&quot;: 1}}}}).toHaveProperty(&apos;a.b.c.d&apos;, 2)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({&quot;a.b.c.d&quot;: 1}).toHaveProperty(&apos;a.b.c.d&apos;, 2)" name=".toHaveProperty() {pass: false} expect({&quot;a.b.c.d&quot;: 1}).toHaveProperty(&apos;a.b.c.d&apos;, 2)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({&quot;a.b.c.d&quot;: 1}).toHaveProperty(&apos;a.b.c.d&apos;, 2)" name=".toHaveProperty() {pass: false} expect({&quot;a.b.c.d&quot;: 1}).toHaveProperty(&apos;a.b.c.d&apos;, 2)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;d&quot;: 1}}}}).toHaveProperty(&apos;a,b,c,d&apos;, 2)" name=".toHaveProperty() {pass: false} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;d&quot;: 1}}}}).toHaveProperty(&apos;a,b,c,d&apos;, 2)" time="0.002">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {}}}}).toHaveProperty(&apos;a.b.c.d&apos;, 1)" name=".toHaveProperty() {pass: false} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {}}}}).toHaveProperty(&apos;a.b.c.d&apos;, 1)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({&quot;a&quot;: 1}).toHaveProperty(&apos;a.b.c.d&apos;, 5)" name=".toHaveProperty() {pass: false} expect({&quot;a&quot;: 1}).toHaveProperty(&apos;a.b.c.d&apos;, 5)" time="0.002">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({}).toHaveProperty(&apos;a&apos;, &quot;test&quot;)" name=".toHaveProperty() {pass: false} expect({}).toHaveProperty(&apos;a&apos;, &quot;test&quot;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({&quot;a&quot;: {&quot;b&quot;: 3}}).toHaveProperty(&apos;a.b&apos;, undefined)" name=".toHaveProperty() {pass: false} expect({&quot;a&quot;: {&quot;b&quot;: 3}}).toHaveProperty(&apos;a.b&apos;, undefined)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect(1).toHaveProperty(&apos;a.b.c&apos;, &quot;test&quot;)" name=".toHaveProperty() {pass: false} expect(1).toHaveProperty(&apos;a.b.c&apos;, &quot;test&quot;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect(&quot;abc&quot;).toHaveProperty(&apos;a.b.c&apos;, {&quot;a&quot;: 5})" name=".toHaveProperty() {pass: false} expect(&quot;abc&quot;).toHaveProperty(&apos;a.b.c&apos;, {&quot;a&quot;: 5})" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: 5}}}).toHaveProperty(&apos;a.b&apos;, {&quot;c&quot;: 4})" name=".toHaveProperty() {pass: false} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: 5}}}).toHaveProperty(&apos;a.b&apos;, {&quot;c&quot;: 4})" time="0.002">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({}).toHaveProperty(&apos;a&apos;, &quot;a&quot;)" name=".toHaveProperty() {pass: false} expect({}).toHaveProperty(&apos;a&apos;, &quot;a&quot;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({}).toHaveProperty(&apos;b&apos;, undefined)" name=".toHaveProperty() {pass: false} expect({}).toHaveProperty(&apos;b&apos;, undefined)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;d&quot;: 1}}}}).toHaveProperty(&apos;a.b.c.d&apos;)" name=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;d&quot;: 1}}}}).toHaveProperty(&apos;a.b.c.d&apos;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;d&quot;: 1}}}}).toHaveProperty(&apos;a,b,c,d&apos;)" name=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;d&quot;: 1}}}}).toHaveProperty(&apos;a,b,c,d&apos;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({&quot;a.b.c.d&quot;: 1}).toHaveProperty(&apos;a.b.c.d&apos;)" name=".toHaveProperty() {pass: true} expect({&quot;a.b.c.d&quot;: 1}).toHaveProperty(&apos;a.b.c.d&apos;)" time="0">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: [1, 2, 3]}}).toHaveProperty(&apos;a,b,1&apos;)" name=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: [1, 2, 3]}}).toHaveProperty(&apos;a,b,1&apos;)" time="0">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({&quot;a&quot;: 0}).toHaveProperty(&apos;a&apos;)" name=".toHaveProperty() {pass: true} expect({&quot;a&quot;: 0}).toHaveProperty(&apos;a&apos;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: undefined}}).toHaveProperty(&apos;a.b&apos;)" name=".toHaveProperty() {pass: true} expect({&quot;a&quot;: {&quot;b&quot;: undefined}}).toHaveProperty(&apos;a.b&apos;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {}}}}).toHaveProperty(&apos;a.b.c.d&apos;)" name=".toHaveProperty() {pass: false} expect({&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {}}}}).toHaveProperty(&apos;a.b.c.d&apos;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({&quot;a&quot;: 1}).toHaveProperty(&apos;a.b.c.d&apos;)" name=".toHaveProperty() {pass: false} expect({&quot;a&quot;: 1}).toHaveProperty(&apos;a.b.c.d&apos;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect({}).toHaveProperty(&apos;a&apos;)" name=".toHaveProperty() {pass: false} expect({}).toHaveProperty(&apos;a&apos;)" time="0.002">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect(1).toHaveProperty(&apos;a.b.c&apos;)" name=".toHaveProperty() {pass: false} expect(1).toHaveProperty(&apos;a.b.c&apos;)" time="0.002">
    </testcase>
    <testcase classname=".toHaveProperty() {pass: false} expect(&quot;abc&quot;).toHaveProperty(&apos;a.b.c&apos;)" name=".toHaveProperty() {pass: false} expect(&quot;abc&quot;).toHaveProperty(&apos;a.b.c&apos;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {error} expect(null).toHaveProperty(&apos;a.b&apos;)" name=".toHaveProperty() {error} expect(null).toHaveProperty(&apos;a.b&apos;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {error} expect(undefined).toHaveProperty(&apos;a&apos;)" name=".toHaveProperty() {error} expect(undefined).toHaveProperty(&apos;a&apos;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {error} expect({&quot;a&quot;: {&quot;b&quot;: {}}}).toHaveProperty(&apos;undefined&apos;)" name=".toHaveProperty() {error} expect({&quot;a&quot;: {&quot;b&quot;: {}}}).toHaveProperty(&apos;undefined&apos;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {error} expect({&quot;a&quot;: {&quot;b&quot;: {}}}).toHaveProperty(&apos;null&apos;)" name=".toHaveProperty() {error} expect({&quot;a&quot;: {&quot;b&quot;: {}}}).toHaveProperty(&apos;null&apos;)" time="0.001">
    </testcase>
    <testcase classname=".toHaveProperty() {error} expect({&quot;a&quot;: {&quot;b&quot;: {}}}).toHaveProperty(&apos;1&apos;)" name=".toHaveProperty() {error} expect({&quot;a&quot;: {&quot;b&quot;: {}}}).toHaveProperty(&apos;1&apos;)" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;}).toMatchObject({&quot;a&quot;: &quot;b&quot;})" name="toMatchObject() {pass: true} expect({&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;}).toMatchObject({&quot;a&quot;: &quot;b&quot;})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;}).toMatchObject({&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;})" name="toMatchObject() {pass: true} expect({&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;}).toMatchObject({&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({&quot;a&quot;: &quot;b&quot;, &quot;t&quot;: {&quot;x&quot;: {&quot;r&quot;: &quot;r&quot;}, &quot;z&quot;: &quot;z&quot;}}).toMatchObject({&quot;a&quot;: &quot;b&quot;, &quot;t&quot;: {&quot;z&quot;: &quot;z&quot;}})" name="toMatchObject() {pass: true} expect({&quot;a&quot;: &quot;b&quot;, &quot;t&quot;: {&quot;x&quot;: {&quot;r&quot;: &quot;r&quot;}, &quot;z&quot;: &quot;z&quot;}}).toMatchObject({&quot;a&quot;: &quot;b&quot;, &quot;t&quot;: {&quot;z&quot;: &quot;z&quot;}})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({&quot;a&quot;: &quot;b&quot;, &quot;t&quot;: {&quot;x&quot;: {&quot;r&quot;: &quot;r&quot;}, &quot;z&quot;: &quot;z&quot;}}).toMatchObject({&quot;t&quot;: {&quot;x&quot;: {&quot;r&quot;: &quot;r&quot;}}})" name="toMatchObject() {pass: true} expect({&quot;a&quot;: &quot;b&quot;, &quot;t&quot;: {&quot;x&quot;: {&quot;r&quot;: &quot;r&quot;}, &quot;z&quot;: &quot;z&quot;}}).toMatchObject({&quot;t&quot;: {&quot;x&quot;: {&quot;r&quot;: &quot;r&quot;}}})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({&quot;a&quot;: [3, 4, 5], &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: [3, 4, 5]})" name="toMatchObject() {pass: true} expect({&quot;a&quot;: [3, 4, 5], &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: [3, 4, 5]})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({&quot;a&quot;: [3, 4, 5, &quot;v&quot;], &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: [3, 4, 5, &quot;v&quot;]})" name="toMatchObject() {pass: true} expect({&quot;a&quot;: [3, 4, 5, &quot;v&quot;], &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: [3, 4, 5, &quot;v&quot;]})" time="0">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({&quot;a&quot;: 1, &quot;c&quot;: 2}).toMatchObject({&quot;a&quot;: Any&lt;Number&gt;})" name="toMatchObject() {pass: true} expect({&quot;a&quot;: 1, &quot;c&quot;: 2}).toMatchObject({&quot;a&quot;: Any&lt;Number&gt;})" time="0">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({&quot;a&quot;: {&quot;x&quot;: &quot;x&quot;, &quot;y&quot;: &quot;y&quot;}}).toMatchObject({&quot;a&quot;: {&quot;x&quot;: Any&lt;String&gt;}})" name="toMatchObject() {pass: true} expect({&quot;a&quot;: {&quot;x&quot;: &quot;x&quot;, &quot;y&quot;: &quot;y&quot;}}).toMatchObject({&quot;a&quot;: {&quot;x&quot;: Any&lt;String&gt;}})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect(Set {1, 2}).toMatchObject(Set {1, 2})" name="toMatchObject() {pass: true} expect(Set {1, 2}).toMatchObject(Set {1, 2})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect(Set {1, 2}).toMatchObject(Set {2, 1})" name="toMatchObject() {pass: true} expect(Set {1, 2}).toMatchObject(Set {2, 1})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect(2015-11-30T00:00:00.000Z).toMatchObject(2015-11-30T00:00:00.000Z)" name="toMatchObject() {pass: true} expect(2015-11-30T00:00:00.000Z).toMatchObject(2015-11-30T00:00:00.000Z)" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({&quot;a&quot;: 2015-11-30T00:00:00.000Z, &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: 2015-11-30T00:00:00.000Z})" name="toMatchObject() {pass: true} expect({&quot;a&quot;: 2015-11-30T00:00:00.000Z, &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: 2015-11-30T00:00:00.000Z})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({&quot;a&quot;: null, &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: null})" name="toMatchObject() {pass: true} expect({&quot;a&quot;: null, &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: null})" time="0">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({&quot;a&quot;: undefined, &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: undefined})" name="toMatchObject() {pass: true} expect({&quot;a&quot;: undefined, &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: undefined})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({&quot;a&quot;: [{&quot;a&quot;: &quot;a&quot;, &quot;b&quot;: &quot;b&quot;}]}).toMatchObject({&quot;a&quot;: [{&quot;a&quot;: &quot;a&quot;}]})" name="toMatchObject() {pass: true} expect({&quot;a&quot;: [{&quot;a&quot;: &quot;a&quot;, &quot;b&quot;: &quot;b&quot;}]}).toMatchObject({&quot;a&quot;: [{&quot;a&quot;: &quot;a&quot;}]})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect([1, 2]).toMatchObject([1, 2])" name="toMatchObject() {pass: true} expect([1, 2]).toMatchObject([1, 2])" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({&quot;a&quot;: undefined}).toMatchObject({&quot;a&quot;: undefined})" name="toMatchObject() {pass: true} expect({&quot;a&quot;: undefined}).toMatchObject({&quot;a&quot;: undefined})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect([]).toMatchObject([])" name="toMatchObject() {pass: true} expect([]).toMatchObject([])" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect([Error: foo]).toMatchObject([Error: foo])" name="toMatchObject() {pass: true} expect([Error: foo]).toMatchObject([Error: foo])" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect([Error: bar]).toMatchObject({&quot;message&quot;: &quot;bar&quot;})" name="toMatchObject() {pass: true} expect([Error: bar]).toMatchObject({&quot;message&quot;: &quot;bar&quot;})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({}).toMatchObject({&quot;a&quot;: undefined, &quot;b&quot;: &quot;b&quot;})" name="toMatchObject() {pass: true} expect({}).toMatchObject({&quot;a&quot;: undefined, &quot;b&quot;: &quot;b&quot;})" time="0">
    </testcase>
    <testcase classname="toMatchObject() {pass: true} expect({&quot;a&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: &quot;b&quot;})" name="toMatchObject() {pass: true} expect({&quot;a&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: &quot;b&quot;})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;}).toMatchObject({&quot;e&quot;: &quot;b&quot;})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;}).toMatchObject({&quot;e&quot;: &quot;b&quot;})" time="0.003">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;}).toMatchObject({&quot;a&quot;: &quot;b!&quot;, &quot;c&quot;: &quot;d&quot;})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;}).toMatchObject({&quot;a&quot;: &quot;b!&quot;, &quot;c&quot;: &quot;d&quot;})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: &quot;a&quot;, &quot;c&quot;: &quot;d&quot;}).toMatchObject({&quot;a&quot;: Any&lt;Number&gt;})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: &quot;a&quot;, &quot;c&quot;: &quot;d&quot;}).toMatchObject({&quot;a&quot;: Any&lt;Number&gt;})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: &quot;b&quot;, &quot;t&quot;: {&quot;x&quot;: {&quot;r&quot;: &quot;r&quot;}, &quot;z&quot;: &quot;z&quot;}}).toMatchObject({&quot;a&quot;: &quot;b&quot;, &quot;t&quot;: {&quot;z&quot;: [3]}})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: &quot;b&quot;, &quot;t&quot;: {&quot;x&quot;: {&quot;r&quot;: &quot;r&quot;}, &quot;z&quot;: &quot;z&quot;}}).toMatchObject({&quot;a&quot;: &quot;b&quot;, &quot;t&quot;: {&quot;z&quot;: [3]}})" time="0.003">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: &quot;b&quot;, &quot;t&quot;: {&quot;x&quot;: {&quot;r&quot;: &quot;r&quot;}, &quot;z&quot;: &quot;z&quot;}}).toMatchObject({&quot;t&quot;: {&quot;l&quot;: {&quot;r&quot;: &quot;r&quot;}}})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: &quot;b&quot;, &quot;t&quot;: {&quot;x&quot;: {&quot;r&quot;: &quot;r&quot;}, &quot;z&quot;: &quot;z&quot;}}).toMatchObject({&quot;t&quot;: {&quot;l&quot;: {&quot;r&quot;: &quot;r&quot;}}})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: [3, 4, 5], &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: [3, 4, 5, 6]})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: [3, 4, 5], &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: [3, 4, 5, 6]})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: [3, 4, 5], &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: [3, 4]})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: [3, 4, 5], &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: [3, 4]})" time="0.003">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: [3, 4, &quot;v&quot;], &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: [&quot;v&quot;]})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: [3, 4, &quot;v&quot;], &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: [&quot;v&quot;]})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: [3, 4, 5], &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: {&quot;b&quot;: 4}})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: [3, 4, 5], &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: {&quot;b&quot;: 4}})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: [3, 4, 5], &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: {&quot;b&quot;: Any&lt;String&gt;}})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: [3, 4, 5], &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: {&quot;b&quot;: Any&lt;String&gt;}})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect([1, 2]).toMatchObject([1, 3])" name="toMatchObject() {pass: false} expect([1, 2]).toMatchObject([1, 3])" time="0.003">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect([0]).toMatchObject([-0])" name="toMatchObject() {pass: false} expect([0]).toMatchObject([-0])" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect(Set {1, 2}).toMatchObject(Set {2})" name="toMatchObject() {pass: false} expect(Set {1, 2}).toMatchObject(Set {2})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect(2015-11-30T00:00:00.000Z).toMatchObject(2015-10-10T00:00:00.000Z)" name="toMatchObject() {pass: false} expect(2015-11-30T00:00:00.000Z).toMatchObject(2015-10-10T00:00:00.000Z)" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: 2015-11-30T00:00:00.000Z, &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: 2015-10-10T00:00:00.000Z})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: 2015-11-30T00:00:00.000Z, &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: 2015-10-10T00:00:00.000Z})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: null, &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: &quot;4&quot;})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: null, &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: &quot;4&quot;})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: null, &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: undefined})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: null, &quot;b&quot;: &quot;b&quot;}).toMatchObject({&quot;a&quot;: undefined})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: undefined}).toMatchObject({&quot;a&quot;: null})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: undefined}).toMatchObject({&quot;a&quot;: null})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: [{&quot;a&quot;: &quot;a&quot;, &quot;b&quot;: &quot;b&quot;}]}).toMatchObject({&quot;a&quot;: [{&quot;a&quot;: &quot;c&quot;}]})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: [{&quot;a&quot;: &quot;a&quot;, &quot;b&quot;: &quot;b&quot;}]}).toMatchObject({&quot;a&quot;: [{&quot;a&quot;: &quot;c&quot;}]})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: 1, &quot;b&quot;: 1, &quot;c&quot;: 1, &quot;d&quot;: {&quot;e&quot;: {&quot;f&quot;: 555}}}).toMatchObject({&quot;d&quot;: {&quot;e&quot;: {&quot;f&quot;: 222}}})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: 1, &quot;b&quot;: 1, &quot;c&quot;: 1, &quot;d&quot;: {&quot;e&quot;: {&quot;f&quot;: 555}}}).toMatchObject({&quot;d&quot;: {&quot;e&quot;: {&quot;f&quot;: 222}}})" time="0.003">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({}).toMatchObject({&quot;a&quot;: undefined})" name="toMatchObject() {pass: false} expect({}).toMatchObject({&quot;a&quot;: undefined})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect([1, 2, 3]).toMatchObject([2, 3, 1])" name="toMatchObject() {pass: false} expect([1, 2, 3]).toMatchObject([2, 3, 1])" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect([1, 2, 3]).toMatchObject([1, 2, 2])" name="toMatchObject() {pass: false} expect([1, 2, 3]).toMatchObject([1, 2, 2])" time="0.004">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect([Error: foo]).toMatchObject([Error: bar])" name="toMatchObject() {pass: false} expect([Error: foo]).toMatchObject([Error: bar])" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() {pass: false} expect({&quot;a&quot;: &quot;b&quot;}).toMatchObject({&quot;c&quot;: &quot;d&quot;})" name="toMatchObject() {pass: false} expect({&quot;a&quot;: &quot;b&quot;}).toMatchObject({&quot;c&quot;: &quot;d&quot;})" time="0.002">
    </testcase>
    <testcase classname="toMatchObject() throws expect(null).toMatchObject({})" name="toMatchObject() throws expect(null).toMatchObject({})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() throws expect(4).toMatchObject({})" name="toMatchObject() throws expect(4).toMatchObject({})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() throws expect(&quot;44&quot;).toMatchObject({})" name="toMatchObject() throws expect(&quot;44&quot;).toMatchObject({})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() throws expect(true).toMatchObject({})" name="toMatchObject() throws expect(true).toMatchObject({})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() throws expect(undefined).toMatchObject({})" name="toMatchObject() throws expect(undefined).toMatchObject({})" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() throws expect({}).toMatchObject(null)" name="toMatchObject() throws expect({}).toMatchObject(null)" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() throws expect({}).toMatchObject(4)" name="toMatchObject() throws expect({}).toMatchObject(4)" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() throws expect({}).toMatchObject(&quot;some string&quot;)" name="toMatchObject() throws expect({}).toMatchObject(&quot;some string&quot;)" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() throws expect({}).toMatchObject(true)" name="toMatchObject() throws expect({}).toMatchObject(true)" time="0.001">
    </testcase>
    <testcase classname="toMatchObject() throws expect({}).toMatchObject(undefined)" name="toMatchObject() throws expect({}).toMatchObject(undefined)" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T20:59:42" time="0.73" tests="111">
    <testcase classname=" does not incorrectly match identity-obj-proxy as Immutable object" name=" does not incorrectly match identity-obj-proxy as Immutable object" time="0.003">
    </testcase>
    <testcase classname="Immutable.OrderedSet supports an empty collection {min: true}" name="Immutable.OrderedSet supports an empty collection {min: true}" time="0.001">
    </testcase>
    <testcase classname="Immutable.OrderedSet supports an empty collection {min: false}" name="Immutable.OrderedSet supports an empty collection {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.OrderedSet supports a single string element" name="Immutable.OrderedSet supports a single string element" time="0">
    </testcase>
    <testcase classname="Immutable.OrderedSet supports a single integer element" name="Immutable.OrderedSet supports a single integer element" time="0.001">
    </testcase>
    <testcase classname="Immutable.OrderedSet supports multiple string elements {min: true}" name="Immutable.OrderedSet supports multiple string elements {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.OrderedSet supports multiple string elements {min: false}" name="Immutable.OrderedSet supports multiple string elements {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.OrderedSet supports multiple integer elements {min: true}" name="Immutable.OrderedSet supports multiple integer elements {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.OrderedSet supports multiple integer elements {min: false}" name="Immutable.OrderedSet supports multiple integer elements {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.OrderedSet supports object elements {min: true}" name="Immutable.OrderedSet supports object elements {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.OrderedSet supports object elements {min: false}" name="Immutable.OrderedSet supports object elements {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.OrderedSet supports React elements {min: true}" name="Immutable.OrderedSet supports React elements {min: true}" time="0.007">
    </testcase>
    <testcase classname="Immutable.OrderedSet supports React elements {min: false}" name="Immutable.OrderedSet supports React elements {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.List supports an empty collection {min: true}" name="Immutable.List supports an empty collection {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.List supports an empty collection {min: false}" name="Immutable.List supports an empty collection {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.List supports a single string element" name="Immutable.List supports a single string element" time="0">
    </testcase>
    <testcase classname="Immutable.List supports a single integer element" name="Immutable.List supports a single integer element" time="0.001">
    </testcase>
    <testcase classname="Immutable.List supports multiple string elements {min: true}" name="Immutable.List supports multiple string elements {min: true}" time="0.001">
    </testcase>
    <testcase classname="Immutable.List supports multiple string elements {min: false}" name="Immutable.List supports multiple string elements {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.List supports multiple integer elements {min: true}" name="Immutable.List supports multiple integer elements {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.List supports multiple integer elements {min: false}" name="Immutable.List supports multiple integer elements {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.List supports object elements {min: true}" name="Immutable.List supports object elements {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.List supports object elements {min: false}" name="Immutable.List supports object elements {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.List supports React elements {min: true}" name="Immutable.List supports React elements {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.List supports React elements {min: false}" name="Immutable.List supports React elements {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Stack supports an empty collection {min: true}" name="Immutable.Stack supports an empty collection {min: true}" time="0.002">
    </testcase>
    <testcase classname="Immutable.Stack supports an empty collection {min: false}" name="Immutable.Stack supports an empty collection {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Stack supports a single string element" name="Immutable.Stack supports a single string element" time="0">
    </testcase>
    <testcase classname="Immutable.Stack supports a single integer element" name="Immutable.Stack supports a single integer element" time="0.001">
    </testcase>
    <testcase classname="Immutable.Stack supports multiple string elements {min: true}" name="Immutable.Stack supports multiple string elements {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.Stack supports multiple string elements {min: false}" name="Immutable.Stack supports multiple string elements {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Stack supports multiple integer elements {min: true}" name="Immutable.Stack supports multiple integer elements {min: true}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Stack supports multiple integer elements {min: false}" name="Immutable.Stack supports multiple integer elements {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.Stack supports object elements {min: true}" name="Immutable.Stack supports object elements {min: true}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Stack supports object elements {min: false}" name="Immutable.Stack supports object elements {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.Stack supports React elements {min: true}" name="Immutable.Stack supports React elements {min: true}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Stack supports React elements {min: false}" name="Immutable.Stack supports React elements {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Set supports an empty collection {min: true}" name="Immutable.Set supports an empty collection {min: true}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Set supports an empty collection {min: false}" name="Immutable.Set supports an empty collection {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Set supports a single string element" name="Immutable.Set supports a single string element" time="0">
    </testcase>
    <testcase classname="Immutable.Set supports a single integer element" name="Immutable.Set supports a single integer element" time="0">
    </testcase>
    <testcase classname="Immutable.Set supports multiple string elements {min: true}" name="Immutable.Set supports multiple string elements {min: true}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Set supports multiple string elements {min: false}" name="Immutable.Set supports multiple string elements {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.Set supports multiple integer elements {min: true}" name="Immutable.Set supports multiple integer elements {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.Set supports multiple integer elements {min: false}" name="Immutable.Set supports multiple integer elements {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Set supports object elements {min: true}" name="Immutable.Set supports object elements {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.Set supports object elements {min: false}" name="Immutable.Set supports object elements {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.Set supports React elements {min: true}" name="Immutable.Set supports React elements {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.Set supports React elements {min: false}" name="Immutable.Set supports React elements {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Map supports an empty collection {min: true}" name="Immutable.Map supports an empty collection {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.Map supports an empty collection {min: false}" name="Immutable.Map supports an empty collection {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.Map supports an object with single key" name="Immutable.Map supports an object with single key" time="0.001">
    </testcase>
    <testcase classname="Immutable.Map supports an object with multiple keys {min: true}" name="Immutable.Map supports an object with multiple keys {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.Map supports an object with multiple keys {min: false}" name="Immutable.Map supports an object with multiple keys {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.Map supports object elements {min: true}" name="Immutable.Map supports object elements {min: true}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Map supports object elements {min: false}" name="Immutable.Map supports object elements {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.Map supports React elements {min: true}" name="Immutable.Map supports React elements {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.Map supports React elements {min: false}" name="Immutable.Map supports React elements {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.OrderedMap supports an empty collection {min: true}" name="Immutable.OrderedMap supports an empty collection {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.OrderedMap supports an empty collection {min: false}" name="Immutable.OrderedMap supports an empty collection {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.OrderedMap supports an object with single key" name="Immutable.OrderedMap supports an object with single key" time="0">
    </testcase>
    <testcase classname="Immutable.OrderedMap supports an object with multiple keys {min: true}" name="Immutable.OrderedMap supports an object with multiple keys {min: true}" time="0.001">
    </testcase>
    <testcase classname="Immutable.OrderedMap supports an object with multiple keys {min: false}" name="Immutable.OrderedMap supports an object with multiple keys {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.OrderedMap supports object elements {min: true}" name="Immutable.OrderedMap supports object elements {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.OrderedMap supports object elements {min: false}" name="Immutable.OrderedMap supports object elements {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.OrderedMap supports React elements {min: true}" name="Immutable.OrderedMap supports React elements {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.OrderedMap supports React elements {min: false}" name="Immutable.OrderedMap supports React elements {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.OrderedMap supports non-string keys" name="Immutable.OrderedMap supports non-string keys" time="0.005">
    </testcase>
    <testcase classname="Immutable.Record supports an empty record {min: true}" name="Immutable.Record supports an empty record {min: true}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Record supports an empty record {min: false}" name="Immutable.Record supports an empty record {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.Record supports a record with descriptive name" name="Immutable.Record supports a record with descriptive name" time="0">
    </testcase>
    <testcase classname="Immutable.Record supports a record without descriptive name" name="Immutable.Record supports a record without descriptive name" time="0">
    </testcase>
    <testcase classname="Immutable.Record supports a record with values {min: true}" name="Immutable.Record supports a record with values {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.Record supports a record with values {min: false}" name="Immutable.Record supports a record with values {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Record supports a record with Map value {min: true}" name="Immutable.Record supports a record with Map value {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.Record supports a record with Map value {min: false}" name="Immutable.Record supports a record with Map value {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Record supports imbricated Record {min: true}" name="Immutable.Record supports imbricated Record {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.Record supports imbricated Record {min: false}" name="Immutable.Record supports imbricated Record {min: false}" time="0">
    </testcase>
    <testcase classname="indentation of heterogeneous collections empty Immutable.List as child of Object" name="indentation of heterogeneous collections empty Immutable.List as child of Object" time="0.001">
    </testcase>
    <testcase classname="indentation of heterogeneous collections empty Immutable.Map as child of Array" name="indentation of heterogeneous collections empty Immutable.Map as child of Array" time="0">
    </testcase>
    <testcase classname="indentation of heterogeneous collections non-empty Array as child of Immutable.Map" name="indentation of heterogeneous collections non-empty Array as child of Immutable.Map" time="0">
    </testcase>
    <testcase classname="indentation of heterogeneous collections non-empty Object as child of Immutable.List" name="indentation of heterogeneous collections non-empty Object as child of Immutable.List" time="0">
    </testcase>
    <testcase classname="indent option default implicit: 2 spaces" name="indent option default implicit: 2 spaces" time="0">
    </testcase>
    <testcase classname="indent option default explicit: 2 spaces" name="indent option default explicit: 2 spaces" time="0">
    </testcase>
    <testcase classname="indent option non-default: 0 spaces" name="indent option non-default: 0 spaces" time="0.001">
    </testcase>
    <testcase classname="indent option non-default: 4 spaces" name="indent option non-default: 4 spaces" time="0">
    </testcase>
    <testcase classname="maxDepth option Immutable.List as child of Object" name="maxDepth option Immutable.List as child of Object" time="0.001">
    </testcase>
    <testcase classname="maxDepth option Immutable.Map as child of Array" name="maxDepth option Immutable.Map as child of Array" time="0">
    </testcase>
    <testcase classname="maxDepth option Immutable.Seq as child of Immutable.Map" name="maxDepth option Immutable.Seq as child of Immutable.Map" time="0.001">
    </testcase>
    <testcase classname="maxDepth option Immutable.Map as descendants in immutable collection" name="maxDepth option Immutable.Map as descendants in immutable collection" time="0.001">
    </testcase>
    <testcase classname="Immutable.Seq supports an empty sequence from array {min: true}" name="Immutable.Seq supports an empty sequence from array {min: true}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Seq supports an empty sequence from array {min: false}" name="Immutable.Seq supports an empty sequence from array {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Seq supports a non-empty sequence from array {min: true}" name="Immutable.Seq supports a non-empty sequence from array {min: true}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Seq supports a non-empty sequence from array {min: false}" name="Immutable.Seq supports a non-empty sequence from array {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.Seq supports a non-empty sequence from arguments" name="Immutable.Seq supports a non-empty sequence from arguments" time="0.001">
    </testcase>
    <testcase classname="Immutable.Seq supports an empty sequence from object {min: true}" name="Immutable.Seq supports an empty sequence from object {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.Seq supports an empty sequence from object {min: false}" name="Immutable.Seq supports an empty sequence from object {min: false}" time="0">
    </testcase>
    <testcase classname="Immutable.Seq supports a non-empty sequence from object {min: true}" name="Immutable.Seq supports a non-empty sequence from object {min: true}" time="0">
    </testcase>
    <testcase classname="Immutable.Seq supports a non-empty sequence from object {min: false}" name="Immutable.Seq supports a non-empty sequence from object {min: false}" time="0.001">
    </testcase>
    <testcase classname="Immutable.Seq supports a sequence of entries from Immutable.Map" name="Immutable.Seq supports a sequence of entries from Immutable.Map" time="0.001">
    </testcase>
    <testcase classname="Immutable.Seq supports a sequence of values from ECMAScript Set" name="Immutable.Seq supports a sequence of values from ECMAScript Set" time="0.002">
    </testcase>
    <testcase classname="Immutable.Seq supports a sequence of values from Immutable.List" name="Immutable.Seq supports a sequence of values from Immutable.List" time="0">
    </testcase>
    <testcase classname="Immutable.Seq supports a sequence of values from Immutable.Set" name="Immutable.Seq supports a sequence of values from Immutable.Set" time="0.001">
    </testcase>
    <testcase classname="Immutable.Seq supports a sequence of values from Immutable.Stack" name="Immutable.Seq supports a sequence of values from Immutable.Stack" time="0.001">
    </testcase>
    <testcase classname="Immutable.Seq lazy entries from object properties" name="Immutable.Seq lazy entries from object properties" time="0.001">
    </testcase>
    <testcase classname="Immutable.Seq lazy entries from Immutable.Map entries" name="Immutable.Seq lazy entries from Immutable.Map entries" time="0.001">
    </testcase>
    <testcase classname="Immutable.Seq lazy values from Immutable.Range" name="Immutable.Seq lazy values from Immutable.Range" time="0.001">
    </testcase>
    <testcase classname="Immutable.Seq lazy values from iterator" name="Immutable.Seq lazy values from iterator" time="0.001">
    </testcase>
    <testcase classname="Immutable.Seq lazy values from array items" name="Immutable.Seq lazy values from array items" time="0">
    </testcase>
    <testcase classname="Immutable.Seq lazy values from Immutable.List values" name="Immutable.Seq lazy values from Immutable.List values" time="0.001">
    </testcase>
    <testcase classname="Immutable.Seq lazy values from ECMAScript Set values" name="Immutable.Seq lazy values from ECMAScript Set values" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="toBeCalled" errors="0" failures="0" skipped="0" timestamp="2018-12-19T20:59:43" time="0.995" tests="244">
    <testcase classname="toBeCalled works only on spies or jest.fn" name="toBeCalled works only on spies or jest.fn" time="0.002">
    </testcase>
    <testcase classname="toBeCalled passes when called" name="toBeCalled passes when called" time="0.003">
    </testcase>
    <testcase classname="toBeCalled .not passes when called" name="toBeCalled .not passes when called" time="0.002">
    </testcase>
    <testcase classname="toBeCalled fails with any argument passed" name="toBeCalled fails with any argument passed" time="0.002">
    </testcase>
    <testcase classname="toBeCalled .not fails with any argument passed" name="toBeCalled .not fails with any argument passed" time="0.002">
    </testcase>
    <testcase classname="toBeCalled includes the custom mock name in the error message" name="toBeCalled includes the custom mock name in the error message" time="0.002">
    </testcase>
    <testcase classname="toHaveBeenCalled works only on spies or jest.fn" name="toHaveBeenCalled works only on spies or jest.fn" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenCalled passes when called" name="toHaveBeenCalled passes when called" time="0.002">
    </testcase>
    <testcase classname="toHaveBeenCalled .not passes when called" name="toHaveBeenCalled .not passes when called" time="0.002">
    </testcase>
    <testcase classname="toHaveBeenCalled fails with any argument passed" name="toHaveBeenCalled fails with any argument passed" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenCalled .not fails with any argument passed" name="toHaveBeenCalled .not fails with any argument passed" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenCalled includes the custom mock name in the error message" name="toHaveBeenCalled includes the custom mock name in the error message" time="0.002">
    </testcase>
    <testcase classname="toBeCalledTimes works only on spies or jest.fn" name="toBeCalledTimes works only on spies or jest.fn" time="0.001">
    </testcase>
    <testcase classname="toBeCalledTimes only accepts a number argument" name="toBeCalledTimes only accepts a number argument" time="0.009">
    </testcase>
    <testcase classname="toBeCalledTimes .not only accepts a number argument" name="toBeCalledTimes .not only accepts a number argument" time="0.006">
    </testcase>
    <testcase classname="toBeCalledTimes passes if function called equal to expected times" name="toBeCalledTimes passes if function called equal to expected times" time="0.001">
    </testcase>
    <testcase classname="toBeCalledTimes .not passes if function called more than expected times" name="toBeCalledTimes .not passes if function called more than expected times" time="0.001">
    </testcase>
    <testcase classname="toBeCalledTimes .not passes if function called less than expected times" name="toBeCalledTimes .not passes if function called less than expected times" time="0.007">
    </testcase>
    <testcase classname="toBeCalledTimes includes the custom mock name in the error message" name="toBeCalledTimes includes the custom mock name in the error message" time="0.002">
    </testcase>
    <testcase classname="toHaveBeenCalledTimes works only on spies or jest.fn" name="toHaveBeenCalledTimes works only on spies or jest.fn" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenCalledTimes only accepts a number argument" name="toHaveBeenCalledTimes only accepts a number argument" time="0.007">
    </testcase>
    <testcase classname="toHaveBeenCalledTimes .not only accepts a number argument" name="toHaveBeenCalledTimes .not only accepts a number argument" time="0.006">
    </testcase>
    <testcase classname="toHaveBeenCalledTimes passes if function called equal to expected times" name="toHaveBeenCalledTimes passes if function called equal to expected times" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenCalledTimes .not passes if function called more than expected times" name="toHaveBeenCalledTimes .not passes if function called more than expected times" time="0.002">
    </testcase>
    <testcase classname="toHaveBeenCalledTimes .not passes if function called less than expected times" name="toHaveBeenCalledTimes .not passes if function called less than expected times" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenCalledTimes includes the custom mock name in the error message" name="toHaveBeenCalledTimes includes the custom mock name in the error message" time="0.001">
    </testcase>
    <testcase classname="lastCalledWith works only on spies or jest.fn" name="lastCalledWith works only on spies or jest.fn" time="0.001">
    </testcase>
    <testcase classname="lastCalledWith works when not called" name="lastCalledWith works when not called" time="0.001">
    </testcase>
    <testcase classname="lastCalledWith works with no arguments" name="lastCalledWith works with no arguments" time="0.001">
    </testcase>
    <testcase classname="lastCalledWith works with arguments that don&apos;t match" name="lastCalledWith works with arguments that don&apos;t match" time="0.002">
    </testcase>
    <testcase classname="lastCalledWith works with arguments that match" name="lastCalledWith works with arguments that match" time="0.002">
    </testcase>
    <testcase classname="lastCalledWith works with trailing undefined arguments" name="lastCalledWith works with trailing undefined arguments" time="0.001">
    </testcase>
    <testcase classname="lastCalledWith works with Map" name="lastCalledWith works with Map" time="0.006">
    </testcase>
    <testcase classname="lastCalledWith works with Set" name="lastCalledWith works with Set" time="0.004">
    </testcase>
    <testcase classname="lastCalledWith works with Immutable.js objects" name="lastCalledWith works with Immutable.js objects" time="0.002">
    </testcase>
    <testcase classname="lastCalledWith works with many arguments" name="lastCalledWith works with many arguments" time="0.002">
    </testcase>
    <testcase classname="lastCalledWith works with many arguments that don&apos;t match" name="lastCalledWith works with many arguments that don&apos;t match" time="0.003">
    </testcase>
    <testcase classname="lastCalledWith includes the custom mock name in the error message" name="lastCalledWith includes the custom mock name in the error message" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenLastCalledWith works only on spies or jest.fn" name="toHaveBeenLastCalledWith works only on spies or jest.fn" time="0">
    </testcase>
    <testcase classname="toHaveBeenLastCalledWith works when not called" name="toHaveBeenLastCalledWith works when not called" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenLastCalledWith works with no arguments" name="toHaveBeenLastCalledWith works with no arguments" time="0">
    </testcase>
    <testcase classname="toHaveBeenLastCalledWith works with arguments that don&apos;t match" name="toHaveBeenLastCalledWith works with arguments that don&apos;t match" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenLastCalledWith works with arguments that match" name="toHaveBeenLastCalledWith works with arguments that match" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenLastCalledWith works with trailing undefined arguments" name="toHaveBeenLastCalledWith works with trailing undefined arguments" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenLastCalledWith works with Map" name="toHaveBeenLastCalledWith works with Map" time="0.002">
    </testcase>
    <testcase classname="toHaveBeenLastCalledWith works with Set" name="toHaveBeenLastCalledWith works with Set" time="0.002">
    </testcase>
    <testcase classname="toHaveBeenLastCalledWith works with Immutable.js objects" name="toHaveBeenLastCalledWith works with Immutable.js objects" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenLastCalledWith works with many arguments" name="toHaveBeenLastCalledWith works with many arguments" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenLastCalledWith works with many arguments that don&apos;t match" name="toHaveBeenLastCalledWith works with many arguments that don&apos;t match" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenLastCalledWith includes the custom mock name in the error message" name="toHaveBeenLastCalledWith includes the custom mock name in the error message" time="0.001">
    </testcase>
    <testcase classname="nthCalledWith works only on spies or jest.fn" name="nthCalledWith works only on spies or jest.fn" time="0.002">
    </testcase>
    <testcase classname="nthCalledWith works when not called" name="nthCalledWith works when not called" time="0.001">
    </testcase>
    <testcase classname="nthCalledWith works with no arguments" name="nthCalledWith works with no arguments" time="0">
    </testcase>
    <testcase classname="nthCalledWith works with arguments that don&apos;t match" name="nthCalledWith works with arguments that don&apos;t match" time="0.001">
    </testcase>
    <testcase classname="nthCalledWith works with arguments that match" name="nthCalledWith works with arguments that match" time="0.002">
    </testcase>
    <testcase classname="nthCalledWith works with trailing undefined arguments" name="nthCalledWith works with trailing undefined arguments" time="0.001">
    </testcase>
    <testcase classname="nthCalledWith works with Map" name="nthCalledWith works with Map" time="0.004">
    </testcase>
    <testcase classname="nthCalledWith works with Set" name="nthCalledWith works with Set" time="0.002">
    </testcase>
    <testcase classname="nthCalledWith works with Immutable.js objects" name="nthCalledWith works with Immutable.js objects" time="0.005">
    </testcase>
    <testcase classname="nthCalledWith works with three calls" name="nthCalledWith works with three calls" time="0.002">
    </testcase>
    <testcase classname="nthCalledWith should replace 1st, 2nd, 3rd with first, second, third" name="nthCalledWith should replace 1st, 2nd, 3rd with first, second, third" time="0.002">
    </testcase>
    <testcase classname="nthCalledWith should reject nth value smaller than 1" name="nthCalledWith should reject nth value smaller than 1" time="0.001">
    </testcase>
    <testcase classname="nthCalledWith should reject non integer nth value" name="nthCalledWith should reject non integer nth value" time="0">
    </testcase>
    <testcase classname="nthCalledWith includes the custom mock name in the error message" name="nthCalledWith includes the custom mock name in the error message" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenNthCalledWith works only on spies or jest.fn" name="toHaveBeenNthCalledWith works only on spies or jest.fn" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenNthCalledWith works when not called" name="toHaveBeenNthCalledWith works when not called" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenNthCalledWith works with no arguments" name="toHaveBeenNthCalledWith works with no arguments" time="0">
    </testcase>
    <testcase classname="toHaveBeenNthCalledWith works with arguments that don&apos;t match" name="toHaveBeenNthCalledWith works with arguments that don&apos;t match" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenNthCalledWith works with arguments that match" name="toHaveBeenNthCalledWith works with arguments that match" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenNthCalledWith works with trailing undefined arguments" name="toHaveBeenNthCalledWith works with trailing undefined arguments" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenNthCalledWith works with Map" name="toHaveBeenNthCalledWith works with Map" time="0.003">
    </testcase>
    <testcase classname="toHaveBeenNthCalledWith works with Set" name="toHaveBeenNthCalledWith works with Set" time="0.003">
    </testcase>
    <testcase classname="toHaveBeenNthCalledWith works with Immutable.js objects" name="toHaveBeenNthCalledWith works with Immutable.js objects" time="0.002">
    </testcase>
    <testcase classname="toHaveBeenNthCalledWith works with three calls" name="toHaveBeenNthCalledWith works with three calls" time="0.003">
    </testcase>
    <testcase classname="toHaveBeenNthCalledWith should replace 1st, 2nd, 3rd with first, second, third" name="toHaveBeenNthCalledWith should replace 1st, 2nd, 3rd with first, second, third" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenNthCalledWith should reject nth value smaller than 1" name="toHaveBeenNthCalledWith should reject nth value smaller than 1" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenNthCalledWith should reject non integer nth value" name="toHaveBeenNthCalledWith should reject non integer nth value" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenNthCalledWith includes the custom mock name in the error message" name="toHaveBeenNthCalledWith includes the custom mock name in the error message" time="0.001">
    </testcase>
    <testcase classname="toBeCalledWith works only on spies or jest.fn" name="toBeCalledWith works only on spies or jest.fn" time="0.001">
    </testcase>
    <testcase classname="toBeCalledWith works when not called" name="toBeCalledWith works when not called" time="0.001">
    </testcase>
    <testcase classname="toBeCalledWith works with no arguments" name="toBeCalledWith works with no arguments" time="0.001">
    </testcase>
    <testcase classname="toBeCalledWith works with arguments that don&apos;t match" name="toBeCalledWith works with arguments that don&apos;t match" time="0.001">
    </testcase>
    <testcase classname="toBeCalledWith works with arguments that match" name="toBeCalledWith works with arguments that match" time="0.001">
    </testcase>
    <testcase classname="toBeCalledWith works with trailing undefined arguments" name="toBeCalledWith works with trailing undefined arguments" time="0.001">
    </testcase>
    <testcase classname="toBeCalledWith works with Map" name="toBeCalledWith works with Map" time="0.002">
    </testcase>
    <testcase classname="toBeCalledWith works with Set" name="toBeCalledWith works with Set" time="0.002">
    </testcase>
    <testcase classname="toBeCalledWith works with Immutable.js objects" name="toBeCalledWith works with Immutable.js objects" time="0.001">
    </testcase>
    <testcase classname="toBeCalledWith works with many arguments" name="toBeCalledWith works with many arguments" time="0.001">
    </testcase>
    <testcase classname="toBeCalledWith works with many arguments that don&apos;t match" name="toBeCalledWith works with many arguments that don&apos;t match" time="0.002">
    </testcase>
    <testcase classname="toBeCalledWith includes the custom mock name in the error message" name="toBeCalledWith includes the custom mock name in the error message" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenCalledWith works only on spies or jest.fn" name="toHaveBeenCalledWith works only on spies or jest.fn" time="0">
    </testcase>
    <testcase classname="toHaveBeenCalledWith works when not called" name="toHaveBeenCalledWith works when not called" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenCalledWith works with no arguments" name="toHaveBeenCalledWith works with no arguments" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenCalledWith works with arguments that don&apos;t match" name="toHaveBeenCalledWith works with arguments that don&apos;t match" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenCalledWith works with arguments that match" name="toHaveBeenCalledWith works with arguments that match" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenCalledWith works with trailing undefined arguments" name="toHaveBeenCalledWith works with trailing undefined arguments" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenCalledWith works with Map" name="toHaveBeenCalledWith works with Map" time="0.005">
    </testcase>
    <testcase classname="toHaveBeenCalledWith works with Set" name="toHaveBeenCalledWith works with Set" time="0.003">
    </testcase>
    <testcase classname="toHaveBeenCalledWith works with Immutable.js objects" name="toHaveBeenCalledWith works with Immutable.js objects" time="0.001">
    </testcase>
    <testcase classname="toHaveBeenCalledWith works with many arguments" name="toHaveBeenCalledWith works with many arguments" time="0.002">
    </testcase>
    <testcase classname="toHaveBeenCalledWith works with many arguments that don&apos;t match" name="toHaveBeenCalledWith works with many arguments that don&apos;t match" time="0.002">
    </testcase>
    <testcase classname="toHaveBeenCalledWith includes the custom mock name in the error message" name="toHaveBeenCalledWith includes the custom mock name in the error message" time="0.001">
    </testcase>
    <testcase classname="toReturn works only on spies or jest.fn" name="toReturn works only on spies or jest.fn" time="0.001">
    </testcase>
    <testcase classname="toReturn passes when returned" name="toReturn passes when returned" time="0.001">
    </testcase>
    <testcase classname="toReturn passes when undefined is returned" name="toReturn passes when undefined is returned" time="0.002">
    </testcase>
    <testcase classname="toReturn passes when at least one call does not throw" name="toReturn passes when at least one call does not throw" time="0.001">
    </testcase>
    <testcase classname="toReturn .not passes when not returned" name="toReturn .not passes when not returned" time="0.001">
    </testcase>
    <testcase classname="toReturn .not passes when all calls throw" name="toReturn .not passes when all calls throw" time="0.003">
    </testcase>
    <testcase classname="toReturn .not passes when a call throws undefined" name="toReturn .not passes when a call throws undefined" time="0.001">
    </testcase>
    <testcase classname="toReturn fails with any argument passed" name="toReturn fails with any argument passed" time="0.001">
    </testcase>
    <testcase classname="toReturn .not fails with any argument passed" name="toReturn .not fails with any argument passed" time="0">
    </testcase>
    <testcase classname="toReturn includes the custom mock name in the error message" name="toReturn includes the custom mock name in the error message" time="0.001">
    </testcase>
    <testcase classname="toReturn incomplete recursive calls are handled properly" name="toReturn incomplete recursive calls are handled properly" time="0.001">
    </testcase>
    <testcase classname="toHaveReturned works only on spies or jest.fn" name="toHaveReturned works only on spies or jest.fn" time="0.001">
    </testcase>
    <testcase classname="toHaveReturned passes when returned" name="toHaveReturned passes when returned" time="0">
    </testcase>
    <testcase classname="toHaveReturned passes when undefined is returned" name="toHaveReturned passes when undefined is returned" time="0.001">
    </testcase>
    <testcase classname="toHaveReturned passes when at least one call does not throw" name="toHaveReturned passes when at least one call does not throw" time="0.001">
    </testcase>
    <testcase classname="toHaveReturned .not passes when not returned" name="toHaveReturned .not passes when not returned" time="0.001">
    </testcase>
    <testcase classname="toHaveReturned .not passes when all calls throw" name="toHaveReturned .not passes when all calls throw" time="0">
    </testcase>
    <testcase classname="toHaveReturned .not passes when a call throws undefined" name="toHaveReturned .not passes when a call throws undefined" time="0.001">
    </testcase>
    <testcase classname="toHaveReturned fails with any argument passed" name="toHaveReturned fails with any argument passed" time="0.001">
    </testcase>
    <testcase classname="toHaveReturned .not fails with any argument passed" name="toHaveReturned .not fails with any argument passed" time="0">
    </testcase>
    <testcase classname="toHaveReturned includes the custom mock name in the error message" name="toHaveReturned includes the custom mock name in the error message" time="0.001">
    </testcase>
    <testcase classname="toHaveReturned incomplete recursive calls are handled properly" name="toHaveReturned incomplete recursive calls are handled properly" time="0.001">
    </testcase>
    <testcase classname="toReturnTimes works only on spies or jest.fn" name="toReturnTimes works only on spies or jest.fn" time="0">
    </testcase>
    <testcase classname="toReturnTimes only accepts a number argument" name="toReturnTimes only accepts a number argument" time="0.004">
    </testcase>
    <testcase classname="toReturnTimes .not only accepts a number argument" name="toReturnTimes .not only accepts a number argument" time="0.005">
    </testcase>
    <testcase classname="toReturnTimes passes if function returned equal to expected times" name="toReturnTimes passes if function returned equal to expected times" time="0.001">
    </testcase>
    <testcase classname="toReturnTimes calls that return undefined are counted as returns" name="toReturnTimes calls that return undefined are counted as returns" time="0.002">
    </testcase>
    <testcase classname="toReturnTimes .not passes if function returned more than expected times" name="toReturnTimes .not passes if function returned more than expected times" time="0.001">
    </testcase>
    <testcase classname="toReturnTimes .not passes if function called less than expected times" name="toReturnTimes .not passes if function called less than expected times" time="0.002">
    </testcase>
    <testcase classname="toReturnTimes calls that throw are not counted" name="toReturnTimes calls that throw are not counted" time="0.003">
    </testcase>
    <testcase classname="toReturnTimes calls that throw undefined are not counted" name="toReturnTimes calls that throw undefined are not counted" time="0.001">
    </testcase>
    <testcase classname="toReturnTimes includes the custom mock name in the error message" name="toReturnTimes includes the custom mock name in the error message" time="0.001">
    </testcase>
    <testcase classname="toReturnTimes incomplete recursive calls are handled properly" name="toReturnTimes incomplete recursive calls are handled properly" time="0.002">
    </testcase>
    <testcase classname="toHaveReturnedTimes works only on spies or jest.fn" name="toHaveReturnedTimes works only on spies or jest.fn" time="0.001">
    </testcase>
    <testcase classname="toHaveReturnedTimes only accepts a number argument" name="toHaveReturnedTimes only accepts a number argument" time="0.004">
    </testcase>
    <testcase classname="toHaveReturnedTimes .not only accepts a number argument" name="toHaveReturnedTimes .not only accepts a number argument" time="0.004">
    </testcase>
    <testcase classname="toHaveReturnedTimes passes if function returned equal to expected times" name="toHaveReturnedTimes passes if function returned equal to expected times" time="0.001">
    </testcase>
    <testcase classname="toHaveReturnedTimes calls that return undefined are counted as returns" name="toHaveReturnedTimes calls that return undefined are counted as returns" time="0.001">
    </testcase>
    <testcase classname="toHaveReturnedTimes .not passes if function returned more than expected times" name="toHaveReturnedTimes .not passes if function returned more than expected times" time="0.001">
    </testcase>
    <testcase classname="toHaveReturnedTimes .not passes if function called less than expected times" name="toHaveReturnedTimes .not passes if function called less than expected times" time="0.001">
    </testcase>
    <testcase classname="toHaveReturnedTimes calls that throw are not counted" name="toHaveReturnedTimes calls that throw are not counted" time="0.001">
    </testcase>
    <testcase classname="toHaveReturnedTimes calls that throw undefined are not counted" name="toHaveReturnedTimes calls that throw undefined are not counted" time="0.001">
    </testcase>
    <testcase classname="toHaveReturnedTimes includes the custom mock name in the error message" name="toHaveReturnedTimes includes the custom mock name in the error message" time="0.002">
    </testcase>
    <testcase classname="toHaveReturnedTimes incomplete recursive calls are handled properly" name="toHaveReturnedTimes incomplete recursive calls are handled properly" time="0">
    </testcase>
    <testcase classname="lastReturnedWith works only on spies or jest.fn" name="lastReturnedWith works only on spies or jest.fn" time="0.001">
    </testcase>
    <testcase classname="lastReturnedWith works when not called" name="lastReturnedWith works when not called" time="0.001">
    </testcase>
    <testcase classname="lastReturnedWith works with no arguments" name="lastReturnedWith works with no arguments" time="0.001">
    </testcase>
    <testcase classname="lastReturnedWith works with argument that does not match" name="lastReturnedWith works with argument that does not match" time="0.001">
    </testcase>
    <testcase classname="lastReturnedWith works with argument that does match" name="lastReturnedWith works with argument that does match" time="0.001">
    </testcase>
    <testcase classname="lastReturnedWith works with undefined" name="lastReturnedWith works with undefined" time="0.003">
    </testcase>
    <testcase classname="lastReturnedWith works with Map" name="lastReturnedWith works with Map" time="0.003">
    </testcase>
    <testcase classname="lastReturnedWith works with Set" name="lastReturnedWith works with Set" time="0.002">
    </testcase>
    <testcase classname="lastReturnedWith works with Immutable.js objects directly created" name="lastReturnedWith works with Immutable.js objects directly created" time="0.001">
    </testcase>
    <testcase classname="lastReturnedWith works with Immutable.js objects indirectly created" name="lastReturnedWith works with Immutable.js objects indirectly created" time="0.001">
    </testcase>
    <testcase classname="lastReturnedWith a call that throws is not considered to have returned" name="lastReturnedWith a call that throws is not considered to have returned" time="0.001">
    </testcase>
    <testcase classname="lastReturnedWith a call that throws undefined is not considered to have returned" name="lastReturnedWith a call that throws undefined is not considered to have returned" time="0.001">
    </testcase>
    <testcase classname="lastReturnedWith works with three calls" name="lastReturnedWith works with three calls" time="0.001">
    </testcase>
    <testcase classname="lastReturnedWith incomplete recursive calls are handled properly" name="lastReturnedWith incomplete recursive calls are handled properly" time="0.001">
    </testcase>
    <testcase classname="lastReturnedWith includes the custom mock name in the error message" name="lastReturnedWith includes the custom mock name in the error message" time="0.001">
    </testcase>
    <testcase classname="toHaveLastReturnedWith works only on spies or jest.fn" name="toHaveLastReturnedWith works only on spies or jest.fn" time="0.001">
    </testcase>
    <testcase classname="toHaveLastReturnedWith works when not called" name="toHaveLastReturnedWith works when not called" time="0.001">
    </testcase>
    <testcase classname="toHaveLastReturnedWith works with no arguments" name="toHaveLastReturnedWith works with no arguments" time="0">
    </testcase>
    <testcase classname="toHaveLastReturnedWith works with argument that does not match" name="toHaveLastReturnedWith works with argument that does not match" time="0.001">
    </testcase>
    <testcase classname="toHaveLastReturnedWith works with argument that does match" name="toHaveLastReturnedWith works with argument that does match" time="0.001">
    </testcase>
    <testcase classname="toHaveLastReturnedWith works with undefined" name="toHaveLastReturnedWith works with undefined" time="0.001">
    </testcase>
    <testcase classname="toHaveLastReturnedWith works with Map" name="toHaveLastReturnedWith works with Map" time="0.003">
    </testcase>
    <testcase classname="toHaveLastReturnedWith works with Set" name="toHaveLastReturnedWith works with Set" time="0.002">
    </testcase>
    <testcase classname="toHaveLastReturnedWith works with Immutable.js objects directly created" name="toHaveLastReturnedWith works with Immutable.js objects directly created" time="0.001">
    </testcase>
    <testcase classname="toHaveLastReturnedWith works with Immutable.js objects indirectly created" name="toHaveLastReturnedWith works with Immutable.js objects indirectly created" time="0.001">
    </testcase>
    <testcase classname="toHaveLastReturnedWith a call that throws is not considered to have returned" name="toHaveLastReturnedWith a call that throws is not considered to have returned" time="0.001">
    </testcase>
    <testcase classname="toHaveLastReturnedWith a call that throws undefined is not considered to have returned" name="toHaveLastReturnedWith a call that throws undefined is not considered to have returned" time="0.001">
    </testcase>
    <testcase classname="toHaveLastReturnedWith works with three calls" name="toHaveLastReturnedWith works with three calls" time="0.001">
    </testcase>
    <testcase classname="toHaveLastReturnedWith incomplete recursive calls are handled properly" name="toHaveLastReturnedWith incomplete recursive calls are handled properly" time="0.002">
    </testcase>
    <testcase classname="toHaveLastReturnedWith includes the custom mock name in the error message" name="toHaveLastReturnedWith includes the custom mock name in the error message" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith works only on spies or jest.fn" name="nthReturnedWith works only on spies or jest.fn" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith works when not called" name="nthReturnedWith works when not called" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith works with no arguments" name="nthReturnedWith works with no arguments" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith works with argument that does not match" name="nthReturnedWith works with argument that does not match" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith works with argument that does match" name="nthReturnedWith works with argument that does match" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith works with undefined" name="nthReturnedWith works with undefined" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith works with Map" name="nthReturnedWith works with Map" time="0.002">
    </testcase>
    <testcase classname="nthReturnedWith works with Set" name="nthReturnedWith works with Set" time="0.002">
    </testcase>
    <testcase classname="nthReturnedWith works with Immutable.js objects directly created" name="nthReturnedWith works with Immutable.js objects directly created" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith works with Immutable.js objects indirectly created" name="nthReturnedWith works with Immutable.js objects indirectly created" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith a call that throws is not considered to have returned" name="nthReturnedWith a call that throws is not considered to have returned" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith a call that throws undefined is not considered to have returned" name="nthReturnedWith a call that throws undefined is not considered to have returned" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith works with three calls" name="nthReturnedWith works with three calls" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith should replace 1st, 2nd, 3rd with first, second, third" name="nthReturnedWith should replace 1st, 2nd, 3rd with first, second, third" time="0.002">
    </testcase>
    <testcase classname="nthReturnedWith should reject nth value smaller than 1" name="nthReturnedWith should reject nth value smaller than 1" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith should reject nth value greater than number of calls" name="nthReturnedWith should reject nth value greater than number of calls" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith should reject non integer nth value" name="nthReturnedWith should reject non integer nth value" time="0.001">
    </testcase>
    <testcase classname="nthReturnedWith incomplete recursive calls are handled properly" name="nthReturnedWith incomplete recursive calls are handled properly" time="0.004">
    </testcase>
    <testcase classname="nthReturnedWith includes the custom mock name in the error message" name="nthReturnedWith includes the custom mock name in the error message" time="0.001">
    </testcase>
    <testcase classname="toHaveNthReturnedWith works only on spies or jest.fn" name="toHaveNthReturnedWith works only on spies or jest.fn" time="0.001">
    </testcase>
    <testcase classname="toHaveNthReturnedWith works when not called" name="toHaveNthReturnedWith works when not called" time="0.003">
    </testcase>
    <testcase classname="toHaveNthReturnedWith works with no arguments" name="toHaveNthReturnedWith works with no arguments" time="0.001">
    </testcase>
    <testcase classname="toHaveNthReturnedWith works with argument that does not match" name="toHaveNthReturnedWith works with argument that does not match" time="0.001">
    </testcase>
    <testcase classname="toHaveNthReturnedWith works with argument that does match" name="toHaveNthReturnedWith works with argument that does match" time="0.001">
    </testcase>
    <testcase classname="toHaveNthReturnedWith works with undefined" name="toHaveNthReturnedWith works with undefined" time="0">
    </testcase>
    <testcase classname="toHaveNthReturnedWith works with Map" name="toHaveNthReturnedWith works with Map" time="0.003">
    </testcase>
    <testcase classname="toHaveNthReturnedWith works with Set" name="toHaveNthReturnedWith works with Set" time="0.003">
    </testcase>
    <testcase classname="toHaveNthReturnedWith works with Immutable.js objects directly created" name="toHaveNthReturnedWith works with Immutable.js objects directly created" time="0.002">
    </testcase>
    <testcase classname="toHaveNthReturnedWith works with Immutable.js objects indirectly created" name="toHaveNthReturnedWith works with Immutable.js objects indirectly created" time="0.001">
    </testcase>
    <testcase classname="toHaveNthReturnedWith a call that throws is not considered to have returned" name="toHaveNthReturnedWith a call that throws is not considered to have returned" time="0.002">
    </testcase>
    <testcase classname="toHaveNthReturnedWith a call that throws undefined is not considered to have returned" name="toHaveNthReturnedWith a call that throws undefined is not considered to have returned" time="0.003">
    </testcase>
    <testcase classname="toHaveNthReturnedWith works with three calls" name="toHaveNthReturnedWith works with three calls" time="0.003">
    </testcase>
    <testcase classname="toHaveNthReturnedWith should replace 1st, 2nd, 3rd with first, second, third" name="toHaveNthReturnedWith should replace 1st, 2nd, 3rd with first, second, third" time="0.003">
    </testcase>
    <testcase classname="toHaveNthReturnedWith should reject nth value smaller than 1" name="toHaveNthReturnedWith should reject nth value smaller than 1" time="0.001">
    </testcase>
    <testcase classname="toHaveNthReturnedWith should reject nth value greater than number of calls" name="toHaveNthReturnedWith should reject nth value greater than number of calls" time="0.001">
    </testcase>
    <testcase classname="toHaveNthReturnedWith should reject non integer nth value" name="toHaveNthReturnedWith should reject non integer nth value" time="0.002">
    </testcase>
    <testcase classname="toHaveNthReturnedWith incomplete recursive calls are handled properly" name="toHaveNthReturnedWith incomplete recursive calls are handled properly" time="0.006">
    </testcase>
    <testcase classname="toHaveNthReturnedWith includes the custom mock name in the error message" name="toHaveNthReturnedWith includes the custom mock name in the error message" time="0.002">
    </testcase>
    <testcase classname="toReturnWith works only on spies or jest.fn" name="toReturnWith works only on spies or jest.fn" time="0.003">
    </testcase>
    <testcase classname="toReturnWith works when not called" name="toReturnWith works when not called" time="0.005">
    </testcase>
    <testcase classname="toReturnWith works with no arguments" name="toReturnWith works with no arguments" time="0.002">
    </testcase>
    <testcase classname="toReturnWith works with argument that does not match" name="toReturnWith works with argument that does not match" time="0.002">
    </testcase>
    <testcase classname="toReturnWith works with argument that does match" name="toReturnWith works with argument that does match" time="0.003">
    </testcase>
    <testcase classname="toReturnWith works with undefined" name="toReturnWith works with undefined" time="0.003">
    </testcase>
    <testcase classname="toReturnWith works with Map" name="toReturnWith works with Map" time="0.005">
    </testcase>
    <testcase classname="toReturnWith works with Set" name="toReturnWith works with Set" time="0.003">
    </testcase>
    <testcase classname="toReturnWith works with Immutable.js objects directly created" name="toReturnWith works with Immutable.js objects directly created" time="0.003">
    </testcase>
    <testcase classname="toReturnWith works with Immutable.js objects indirectly created" name="toReturnWith works with Immutable.js objects indirectly created" time="0.005">
    </testcase>
    <testcase classname="toReturnWith a call that throws is not considered to have returned" name="toReturnWith a call that throws is not considered to have returned" time="0.002">
    </testcase>
    <testcase classname="toReturnWith a call that throws undefined is not considered to have returned" name="toReturnWith a call that throws undefined is not considered to have returned" time="0.016">
    </testcase>
    <testcase classname="toReturnWith works with more calls than the limit" name="toReturnWith works with more calls than the limit" time="0.005">
    </testcase>
    <testcase classname="toReturnWith incomplete recursive calls are handled properly" name="toReturnWith incomplete recursive calls are handled properly" time="0.004">
    </testcase>
    <testcase classname="toReturnWith includes the custom mock name in the error message" name="toReturnWith includes the custom mock name in the error message" time="0.001">
    </testcase>
    <testcase classname="toHaveReturnedWith works only on spies or jest.fn" name="toHaveReturnedWith works only on spies or jest.fn" time="0.001">
    </testcase>
    <testcase classname="toHaveReturnedWith works when not called" name="toHaveReturnedWith works when not called" time="0.004">
    </testcase>
    <testcase classname="toHaveReturnedWith works with no arguments" name="toHaveReturnedWith works with no arguments" time="0">
    </testcase>
    <testcase classname="toHaveReturnedWith works with argument that does not match" name="toHaveReturnedWith works with argument that does not match" time="0.001">
    </testcase>
    <testcase classname="toHaveReturnedWith works with argument that does match" name="toHaveReturnedWith works with argument that does match" time="0.012">
    </testcase>
    <testcase classname="toHaveReturnedWith works with undefined" name="toHaveReturnedWith works with undefined" time="0.003">
    </testcase>
    <testcase classname="toHaveReturnedWith works with Map" name="toHaveReturnedWith works with Map" time="0.006">
    </testcase>
    <testcase classname="toHaveReturnedWith works with Set" name="toHaveReturnedWith works with Set" time="0.006">
    </testcase>
    <testcase classname="toHaveReturnedWith works with Immutable.js objects directly created" name="toHaveReturnedWith works with Immutable.js objects directly created" time="0.002">
    </testcase>
    <testcase classname="toHaveReturnedWith works with Immutable.js objects indirectly created" name="toHaveReturnedWith works with Immutable.js objects indirectly created" time="0.01">
    </testcase>
    <testcase classname="toHaveReturnedWith a call that throws is not considered to have returned" name="toHaveReturnedWith a call that throws is not considered to have returned" time="0.001">
    </testcase>
    <testcase classname="toHaveReturnedWith a call that throws undefined is not considered to have returned" name="toHaveReturnedWith a call that throws undefined is not considered to have returned" time="0.002">
    </testcase>
    <testcase classname="toHaveReturnedWith works with more calls than the limit" name="toHaveReturnedWith works with more calls than the limit" time="0.004">
    </testcase>
    <testcase classname="toHaveReturnedWith incomplete recursive calls are handled properly" name="toHaveReturnedWith incomplete recursive calls are handled properly" time="0.002">
    </testcase>
    <testcase classname="toHaveReturnedWith includes the custom mock name in the error message" name="toHaveReturnedWith includes the custom mock name in the error message" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="FakeTimers" errors="0" failures="0" skipped="0" timestamp="2018-12-19T20:59:44" time="0.656" tests="43">
    <testcase classname="FakeTimers construction installs setTimeout mock" name="FakeTimers construction installs setTimeout mock" time="0.105">
    </testcase>
    <testcase classname="FakeTimers construction installs clearTimeout mock" name="FakeTimers construction installs clearTimeout mock" time="0.001">
    </testcase>
    <testcase classname="FakeTimers construction installs setInterval mock" name="FakeTimers construction installs setInterval mock" time="0.002">
    </testcase>
    <testcase classname="FakeTimers construction installs clearInterval mock" name="FakeTimers construction installs clearInterval mock" time="0.001">
    </testcase>
    <testcase classname="FakeTimers construction mocks process.nextTick if it exists on global" name="FakeTimers construction mocks process.nextTick if it exists on global" time="0.002">
    </testcase>
    <testcase classname="FakeTimers construction mocks setImmediate if it exists on global" name="FakeTimers construction mocks setImmediate if it exists on global" time="0.002">
    </testcase>
    <testcase classname="FakeTimers construction mocks clearImmediate if setImmediate is on global" name="FakeTimers construction mocks clearImmediate if setImmediate is on global" time="0.002">
    </testcase>
    <testcase classname="FakeTimers runAllTicks runs all ticks, in order" name="FakeTimers runAllTicks runs all ticks, in order" time="0.01">
    </testcase>
    <testcase classname="FakeTimers runAllTicks does nothing when no ticks have been scheduled" name="FakeTimers runAllTicks does nothing when no ticks have been scheduled" time="0.002">
    </testcase>
    <testcase classname="FakeTimers runAllTicks only runs a scheduled callback once" name="FakeTimers runAllTicks only runs a scheduled callback once" time="0.002">
    </testcase>
    <testcase classname="FakeTimers runAllTicks cancels a callback even from native nextTick" name="FakeTimers runAllTicks cancels a callback even from native nextTick" time="0.002">
    </testcase>
    <testcase classname="FakeTimers runAllTicks cancels a callback even from native setImmediate" name="FakeTimers runAllTicks cancels a callback even from native setImmediate" time="0.003">
    </testcase>
    <testcase classname="FakeTimers runAllTicks doesnt run a tick callback if native nextTick already did" name="FakeTimers runAllTicks doesnt run a tick callback if native nextTick already did" time="0.004">
    </testcase>
    <testcase classname="FakeTimers runAllTicks doesnt run immediate if native setImmediate already did" name="FakeTimers runAllTicks doesnt run immediate if native setImmediate already did" time="0.002">
    </testcase>
    <testcase classname="FakeTimers runAllTicks native doesnt run immediate if fake already did" name="FakeTimers runAllTicks native doesnt run immediate if fake already did" time="0.001">
    </testcase>
    <testcase classname="FakeTimers runAllTicks throws before allowing infinite recursion" name="FakeTimers runAllTicks throws before allowing infinite recursion" time="0.002">
    </testcase>
    <testcase classname="FakeTimers runAllTimers runs all timers in order" name="FakeTimers runAllTimers runs all timers in order" time="0.004">
    </testcase>
    <testcase classname="FakeTimers runAllTimers warns when trying to advance timers while real timers are used" name="FakeTimers runAllTimers warns when trying to advance timers while real timers are used" time="0.093">
    </testcase>
    <testcase classname="FakeTimers runAllTimers does nothing when no timers have been scheduled" name="FakeTimers runAllTimers does nothing when no timers have been scheduled" time="0.002">
    </testcase>
    <testcase classname="FakeTimers runAllTimers only runs a setTimeout callback once (ever)" name="FakeTimers runAllTimers only runs a setTimeout callback once (ever)" time="0.003">
    </testcase>
    <testcase classname="FakeTimers runAllTimers runs callbacks with arguments after the interval" name="FakeTimers runAllTimers runs callbacks with arguments after the interval" time="0.003">
    </testcase>
    <testcase classname="FakeTimers runAllTimers doesnt pass the callback to native setTimeout" name="FakeTimers runAllTimers doesnt pass the callback to native setTimeout" time="0.002">
    </testcase>
    <testcase classname="FakeTimers runAllTimers throws before allowing infinite recursion" name="FakeTimers runAllTimers throws before allowing infinite recursion" time="0.004">
    </testcase>
    <testcase classname="FakeTimers runAllTimers also clears ticks" name="FakeTimers runAllTimers also clears ticks" time="0.003">
    </testcase>
    <testcase classname="FakeTimers advanceTimersByTime runs timers in order" name="FakeTimers advanceTimersByTime runs timers in order" time="0.004">
    </testcase>
    <testcase classname="FakeTimers advanceTimersByTime does nothing when no timers have been scheduled" name="FakeTimers advanceTimersByTime does nothing when no timers have been scheduled" time="0.001">
    </testcase>
    <testcase classname="FakeTimers advanceTimersByTime throws before allowing infinite recursion" name="FakeTimers advanceTimersByTime throws before allowing infinite recursion" time="0.003">
    </testcase>
    <testcase classname="FakeTimers reset resets all pending setTimeouts" name="FakeTimers reset resets all pending setTimeouts" time="0.002">
    </testcase>
    <testcase classname="FakeTimers reset resets all pending setIntervals" name="FakeTimers reset resets all pending setIntervals" time="0.003">
    </testcase>
    <testcase classname="FakeTimers reset resets all pending ticks callbacks &amp; immediates" name="FakeTimers reset resets all pending ticks callbacks &amp; immediates" time="0.003">
    </testcase>
    <testcase classname="FakeTimers reset resets current advanceTimersByTime time cursor" name="FakeTimers reset resets current advanceTimersByTime time cursor" time="0.002">
    </testcase>
    <testcase classname="FakeTimers runOnlyPendingTimers runs all timers in order" name="FakeTimers runOnlyPendingTimers runs all timers in order" time="0.004">
    </testcase>
    <testcase classname="FakeTimers runOnlyPendingTimers does not run timers that were cleared in another timer" name="FakeTimers runOnlyPendingTimers does not run timers that were cleared in another timer" time="0.002">
    </testcase>
    <testcase classname="FakeTimers runWithRealTimers executes callback with native timers" name="FakeTimers runWithRealTimers executes callback with native timers" time="0.017">
    </testcase>
    <testcase classname="FakeTimers runWithRealTimers resets mock timers after executing callback" name="FakeTimers runWithRealTimers resets mock timers after executing callback" time="0.008">
    </testcase>
    <testcase classname="FakeTimers runWithRealTimers resets mock timer functions even if callback throws" name="FakeTimers runWithRealTimers resets mock timer functions even if callback throws" time="0.005">
    </testcase>
    <testcase classname="FakeTimers useRealTimers resets native timer APIs" name="FakeTimers useRealTimers resets native timer APIs" time="0.007">
    </testcase>
    <testcase classname="FakeTimers useRealTimers resets native process.nextTick when present" name="FakeTimers useRealTimers resets native process.nextTick when present" time="0.004">
    </testcase>
    <testcase classname="FakeTimers useRealTimers resets native setImmediate when present" name="FakeTimers useRealTimers resets native setImmediate when present" time="0.004">
    </testcase>
    <testcase classname="FakeTimers useFakeTimers resets mock timer APIs" name="FakeTimers useFakeTimers resets mock timer APIs" time="0.063">
    </testcase>
    <testcase classname="FakeTimers useFakeTimers resets mock process.nextTick when present" name="FakeTimers useFakeTimers resets mock process.nextTick when present" time="0.002">
    </testcase>
    <testcase classname="FakeTimers useFakeTimers resets mock setImmediate when present" name="FakeTimers useFakeTimers resets mock setImmediate when present" time="0.004">
    </testcase>
    <testcase classname="FakeTimers getTimerCount returns the correct count" name="FakeTimers getTimerCount returns the correct count" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="invalid arg" errors="0" failures="0" skipped="0" timestamp="2018-12-19T20:59:44" time="0.454" tests="48">
    <testcase classname="invalid arg length is not a number" name="invalid arg length is not a number" time="0.003">
    </testcase>
    <testcase classname="invalid arg length Infinity is not a safe integer" name="invalid arg length Infinity is not a safe integer" time="0.001">
    </testcase>
    <testcase classname="invalid arg length Not a Number is not a safe integer" name="invalid arg length Not a Number is not a safe integer" time="0.001">
    </testcase>
    <testcase classname="invalid arg length MAX_SAFE_INTEGER + 1 is not a safe integer" name="invalid arg length MAX_SAFE_INTEGER + 1 is not a safe integer" time="0">
    </testcase>
    <testcase classname="invalid arg length MIN_SAFE_INTEGER - 1 is not a safe integer" name="invalid arg length MIN_SAFE_INTEGER - 1 is not a safe integer" time="0.001">
    </testcase>
    <testcase classname="invalid arg length is a negative integer" name="invalid arg length is a negative integer" time="0.001">
    </testcase>
    <testcase classname="invalid arg callback null is not a function" name="invalid arg callback null is not a function" time="0.001">
    </testcase>
    <testcase classname="invalid arg callback undefined is not a function" name="invalid arg callback undefined is not a function" time="0">
    </testcase>
    <testcase classname="input callback encapsulates comparison zero and negative zero are not common according to Object.is method" name="input callback encapsulates comparison zero and negative zero are not common according to Object.is method" time="0.003">
    </testcase>
    <testcase classname="input callback encapsulates comparison zero and negative zero are common according to === operator" name="input callback encapsulates comparison zero and negative zero are common according to === operator" time="0.001">
    </testcase>
    <testcase classname="input callback encapsulates comparison Not a Number is common according to Object.is method" name="input callback encapsulates comparison Not a Number is common according to Object.is method" time="0">
    </testcase>
    <testcase classname="input callback encapsulates comparison Not a Number is not common according to === operator" name="input callback encapsulates comparison Not a Number is not common according to === operator" time="0.001">
    </testcase>
    <testcase classname="input callback encapsulates sequences arrays of strings" name="input callback encapsulates sequences arrays of strings" time="0.01">
    </testcase>
    <testcase classname="input callback encapsulates sequences string and array of strings" name="input callback encapsulates sequences string and array of strings" time="0.002">
    </testcase>
    <testcase classname="input callback encapsulates sequences strings" name="input callback encapsulates sequences strings" time="0.002">
    </testcase>
    <testcase classname="no common items negative zero is equivalent to zero for length of a" name="no common items negative zero is equivalent to zero for length of a" time="0.002">
    </testcase>
    <testcase classname="no common items negative zero is equivalent to zero for length of b" name="no common items negative zero is equivalent to zero for length of b" time="0.001">
    </testcase>
    <testcase classname="no common items negative zero is equivalent to zero for length of a and b" name="no common items negative zero is equivalent to zero for length of a and b" time="0">
    </testcase>
    <testcase classname="no common items a empty and b empty" name="no common items a empty and b empty" time="0.001">
    </testcase>
    <testcase classname="no common items a empty and b non-empty" name="no common items a empty and b non-empty" time="0.001">
    </testcase>
    <testcase classname="no common items a non-empty and b empty" name="no common items a non-empty and b empty" time="0.001">
    </testcase>
    <testcase classname="no common items a non-empty and b non-empty baDeltaLength 0 even" name="no common items a non-empty and b non-empty baDeltaLength 0 even" time="0.001">
    </testcase>
    <testcase classname="no common items a non-empty and b non-empty baDeltaLength 1 odd" name="no common items a non-empty and b non-empty baDeltaLength 1 odd" time="0.001">
    </testcase>
    <testcase classname="no common items a non-empty and b non-empty baDeltaLength 2 even" name="no common items a non-empty and b non-empty baDeltaLength 2 even" time="0.002">
    </testcase>
    <testcase classname="no common items a non-empty and b non-empty baDeltaLength 7 odd" name="no common items a non-empty and b non-empty baDeltaLength 7 odd" time="0.002">
    </testcase>
    <testcase classname="only common items length 1" name="only common items length 1" time="0.001">
    </testcase>
    <testcase classname="only common items length 2" name="only common items length 2" time="0">
    </testcase>
    <testcase classname="all common items outside preceding changes" name="all common items outside preceding changes" time="0.001">
    </testcase>
    <testcase classname="all common items outside following change" name="all common items outside following change" time="0.001">
    </testcase>
    <testcase classname="all common items outside preceding and following changes in one sequence" name="all common items outside preceding and following changes in one sequence" time="0.001">
    </testcase>
    <testcase classname="some common items inside and outside preceding changes adjacent to common in both sequences" name="some common items inside and outside preceding changes adjacent to common in both sequences" time="0.001">
    </testcase>
    <testcase classname="some common items inside and outside following changes adjacent to common in both sequences" name="some common items inside and outside following changes adjacent to common in both sequences" time="0.001">
    </testcase>
    <testcase classname="all common items inside non-recursive move from start to end relative to change" name="all common items inside non-recursive move from start to end relative to change" time="0">
    </testcase>
    <testcase classname="all common items inside non-recursive move from start to end relative to common" name="all common items inside non-recursive move from start to end relative to common" time="0.001">
    </testcase>
    <testcase classname="all common items inside non-recursive move from start to end relative to change and common" name="all common items inside non-recursive move from start to end relative to change and common" time="0">
    </testcase>
    <testcase classname="all common items inside non-recursive reverse relative to change" name="all common items inside non-recursive reverse relative to change" time="0.001">
    </testcase>
    <testcase classname="all common items inside non-recursive preceding middle" name="all common items inside non-recursive preceding middle" time="0.001">
    </testcase>
    <testcase classname="all common items inside non-recursive following middle" name="all common items inside non-recursive following middle" time="0.001">
    </testcase>
    <testcase classname="all common items inside recursive prev reverse at depth 1 and preceding at depth 2" name="all common items inside recursive prev reverse at depth 1 and preceding at depth 2" time="0.001">
    </testcase>
    <testcase classname="all common items inside recursive last forward at depth 1 and following at depth 2" name="all common items inside recursive last forward at depth 1 and following at depth 2" time="0">
    </testcase>
    <testcase classname="all common items inside recursive preceding at depth 2 and both at depth 3 of following" name="all common items inside recursive preceding at depth 2 and both at depth 3 of following" time="0.001">
    </testcase>
    <testcase classname="all common items inside recursive interleaved single change" name="all common items inside recursive interleaved single change" time="0.001">
    </testcase>
    <testcase classname="all common items inside recursive interleaved double changes" name="all common items inside recursive interleaved double changes" time="0.002">
    </testcase>
    <testcase classname="all common items inside recursive optimization decreases iMaxF" name="all common items inside recursive optimization decreases iMaxF" time="0.002">
    </testcase>
    <testcase classname="all common items inside recursive optimization decreases iMaxR" name="all common items inside recursive optimization decreases iMaxR" time="0.002">
    </testcase>
    <testcase classname="common substrings progress" name="common substrings progress" time="0.002">
    </testcase>
    <testcase classname="common substrings regression" name="common substrings regression" time="0.027">
    </testcase>
    <testcase classname="common substrings wrapping" name="common substrings wrapping" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="Watch mode flows" errors="0" failures="0" skipped="0" timestamp="2018-12-19T20:59:45" time="1.506" tests="80">
    <testcase classname="Watch mode flows Correctly passing test path pattern" name="Watch mode flows Correctly passing test path pattern" time="0.038">
    </testcase>
    <testcase classname="Watch mode flows Correctly passing test name pattern" name="Watch mode flows Correctly passing test name pattern" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows Runs Jest once by default and shows usage" name="Watch mode flows Runs Jest once by default and shows usage" time="0.011">
    </testcase>
    <testcase classname="Watch mode flows Runs Jest in a non-interactive environment not showing usage" name="Watch mode flows Runs Jest in a non-interactive environment not showing usage" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows resolves relative to the package root" name="Watch mode flows resolves relative to the package root" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows shows prompts for WatchPlugins in alphabetical order" name="Watch mode flows shows prompts for WatchPlugins in alphabetical order" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows shows update snapshot prompt (without interactive)" name="Watch mode flows shows update snapshot prompt (without interactive)" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows shows update snapshot prompt (with interactive)" name="Watch mode flows shows update snapshot prompt (with interactive)" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to hook into JestHook" name="Watch mode flows allows WatchPlugins to hook into JestHook" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to override eligible internal plugins" name="Watch mode flows allows WatchPlugins to override eligible internal plugins" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows when dealing with potential watch plugin key conflicts forbids WatchPlugins overriding reserved internal plugins" name="Watch mode flows when dealing with potential watch plugin key conflicts forbids WatchPlugins overriding reserved internal plugins" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows when dealing with potential watch plugin key conflicts forbids WatchPlugins overriding reserved internal plugins" name="Watch mode flows when dealing with potential watch plugin key conflicts forbids WatchPlugins overriding reserved internal plugins" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows when dealing with potential watch plugin key conflicts forbids WatchPlugins overriding reserved internal plugins" name="Watch mode flows when dealing with potential watch plugin key conflicts forbids WatchPlugins overriding reserved internal plugins" time="0">
    </testcase>
    <testcase classname="Watch mode flows when dealing with potential watch plugin key conflicts allows WatchPlugins to override non-reserved internal plugins" name="Watch mode flows when dealing with potential watch plugin key conflicts allows WatchPlugins to override non-reserved internal plugins" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows when dealing with potential watch plugin key conflicts allows WatchPlugins to override non-reserved internal plugins" name="Watch mode flows when dealing with potential watch plugin key conflicts allows WatchPlugins to override non-reserved internal plugins" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows when dealing with potential watch plugin key conflicts forbids third-party WatchPlugins overriding each other" name="Watch mode flows when dealing with potential watch plugin key conflicts forbids third-party WatchPlugins overriding each other" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to be configured" name="Watch mode flows allows WatchPlugins to be configured" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to hook into file system changes" name="Watch mode flows allows WatchPlugins to hook into file system changes" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.01">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" name="Watch mode flows allows WatchPlugins to modify only white-listed global config keys" time="0.002">
    </testcase>
    <testcase classname="Watch mode flows triggers enter on a WatchPlugin when its key is pressed" name="Watch mode flows triggers enter on a WatchPlugin when its key is pressed" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows prevents Jest from handling keys when active and returns control when end is called" name="Watch mode flows prevents Jest from handling keys when active and returns control when end is called" time="0.003">
    </testcase>
    <testcase classname="Watch mode flows Pressing &quot;o&quot; runs test in &quot;only changed files&quot; mode" name="Watch mode flows Pressing &quot;o&quot; runs test in &quot;only changed files&quot; mode" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows Pressing &quot;a&quot; runs test in &quot;watch all&quot; mode" name="Watch mode flows Pressing &quot;a&quot; runs test in &quot;watch all&quot; mode" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows Pressing &quot;ENTER&quot; reruns the tests" name="Watch mode flows Pressing &quot;ENTER&quot; reruns the tests" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows Pressing &quot;t&quot; reruns the tests in &quot;test name pattern&quot; mode" name="Watch mode flows Pressing &quot;t&quot; reruns the tests in &quot;test name pattern&quot; mode" time="0.044">
    </testcase>
    <testcase classname="Watch mode flows Pressing &quot;p&quot; reruns the tests in &quot;filename pattern&quot; mode" name="Watch mode flows Pressing &quot;p&quot; reruns the tests in &quot;filename pattern&quot; mode" time="0.003">
    </testcase>
    <testcase classname="Watch mode flows Can combine &quot;p&quot; and &quot;t&quot; filters" name="Watch mode flows Can combine &quot;p&quot; and &quot;t&quot; filters" time="0.005">
    </testcase>
    <testcase classname="Watch mode flows Pressing &quot;u&quot; reruns the tests in &quot;update snapshot&quot; mode" name="Watch mode flows Pressing &quot;u&quot; reruns the tests in &quot;update snapshot&quot; mode" time="0.015">
    </testcase>
    <testcase classname="Watch mode flows passWithNoTest should be set to true in watch mode" name="Watch mode flows passWithNoTest should be set to true in watch mode" time="0.001">
    </testcase>
    <testcase classname="Watch mode flows shows the correct usage for the f key in &quot;only failed tests&quot; mode" name="Watch mode flows shows the correct usage for the f key in &quot;only failed tests&quot; mode" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="prettyFormat()" errors="0" failures="0" skipped="0" timestamp="2018-12-19T20:59:46" time="0.394" tests="82">
    <testcase classname="prettyFormat() prints empty arguments" name="prettyFormat() prints empty arguments" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints arguments" name="prettyFormat() prints arguments" time="0.002">
    </testcase>
    <testcase classname="prettyFormat() prints an empty array" name="prettyFormat() prints an empty array" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints an array with items" name="prettyFormat() prints an array with items" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints a empty typed array" name="prettyFormat() prints a empty typed array" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a typed array with items" name="prettyFormat() prints a typed array with items" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints an array buffer" name="prettyFormat() prints an array buffer" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints a nested array" name="prettyFormat() prints a nested array" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints true" name="prettyFormat() prints true" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints false" name="prettyFormat() prints false" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints an error" name="prettyFormat() prints an error" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints a typed error with a message" name="prettyFormat() prints a typed error with a message" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a function constructor" name="prettyFormat() prints a function constructor" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints an anonymous callback function" name="prettyFormat() prints an anonymous callback function" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints an anonymous assigned function" name="prettyFormat() prints an anonymous assigned function" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints a named function" name="prettyFormat() prints a named function" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a named generator function" name="prettyFormat() prints a named generator function" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() can customize function names" name="prettyFormat() can customize function names" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints Infinity" name="prettyFormat() prints Infinity" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints -Infinity" name="prettyFormat() prints -Infinity" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints an empty map" name="prettyFormat() prints an empty map" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a map with values" name="prettyFormat() prints a map with values" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a map with non-string keys" name="prettyFormat() prints a map with non-string keys" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints NaN" name="prettyFormat() prints NaN" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints null" name="prettyFormat() prints null" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints a positive number" name="prettyFormat() prints a positive number" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a negative number" name="prettyFormat() prints a negative number" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints zero" name="prettyFormat() prints zero" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints negative zero" name="prettyFormat() prints negative zero" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a date" name="prettyFormat() prints a date" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints an invalid date" name="prettyFormat() prints an invalid date" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints an empty object" name="prettyFormat() prints an empty object" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints an object with properties" name="prettyFormat() prints an object with properties" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints an object with properties and symbols" name="prettyFormat() prints an object with properties and symbols" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints an object without non-enumerable properties which have string key" name="prettyFormat() prints an object without non-enumerable properties which have string key" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints an object without non-enumerable properties which have symbol key" name="prettyFormat() prints an object without non-enumerable properties which have symbol key" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints an object with sorted properties" name="prettyFormat() prints an object with sorted properties" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints regular expressions from constructors" name="prettyFormat() prints regular expressions from constructors" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints regular expressions from literals" name="prettyFormat() prints regular expressions from literals" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints regular expressions {escapeRegex: false}" name="prettyFormat() prints regular expressions {escapeRegex: false}" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints regular expressions {escapeRegex: true}" name="prettyFormat() prints regular expressions {escapeRegex: true}" time="0">
    </testcase>
    <testcase classname="prettyFormat() escapes regular expressions nested inside object" name="prettyFormat() escapes regular expressions nested inside object" time="0.002">
    </testcase>
    <testcase classname="prettyFormat() prints an empty set" name="prettyFormat() prints an empty set" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a set with values" name="prettyFormat() prints a set with values" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a string" name="prettyFormat() prints a string" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints and escape a string" name="prettyFormat() prints and escape a string" time="0">
    </testcase>
    <testcase classname="prettyFormat() doesn&apos;t escape string with {excapeString: false}" name="prettyFormat() doesn&apos;t escape string with {excapeString: false}" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a string with escapes" name="prettyFormat() prints a string with escapes" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a multiline string" name="prettyFormat() prints a multiline string" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a multiline string as value of object property" name="prettyFormat() prints a multiline string as value of object property" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a symbol" name="prettyFormat() prints a symbol" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints undefined" name="prettyFormat() prints undefined" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a WeakMap" name="prettyFormat() prints a WeakMap" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints a WeakSet" name="prettyFormat() prints a WeakSet" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints deeply nested objects" name="prettyFormat() prints deeply nested objects" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints circular references" name="prettyFormat() prints circular references" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints parallel references" name="prettyFormat() prints parallel references" time="0">
    </testcase>
    <testcase classname="prettyFormat() indent option default implicit: 2 spaces" name="prettyFormat() indent option default implicit: 2 spaces" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() indent option default explicit: 2 spaces" name="prettyFormat() indent option default explicit: 2 spaces" time="0">
    </testcase>
    <testcase classname="prettyFormat() indent option non-default: 0 spaces" name="prettyFormat() indent option non-default: 0 spaces" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() indent option non-default: 4 spaces" name="prettyFormat() indent option non-default: 4 spaces" time="0">
    </testcase>
    <testcase classname="prettyFormat() can customize the max depth" name="prettyFormat() can customize the max depth" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() throws on invalid options" name="prettyFormat() throws on invalid options" time="0">
    </testcase>
    <testcase classname="prettyFormat() supports plugins" name="prettyFormat() supports plugins" time="0">
    </testcase>
    <testcase classname="prettyFormat() supports plugins that return empty string" name="prettyFormat() supports plugins that return empty string" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() throws if plugin does not return a string" name="prettyFormat() throws if plugin does not return a string" time="0">
    </testcase>
    <testcase classname="prettyFormat() throws PrettyFormatPluginError if test throws an error" name="prettyFormat() throws PrettyFormatPluginError if test throws an error" time="0.048">
    </testcase>
    <testcase classname="prettyFormat() throws PrettyFormatPluginError if print throws an error" name="prettyFormat() throws PrettyFormatPluginError if print throws an error" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() throws PrettyFormatPluginError if serialize throws an error" name="prettyFormat() throws PrettyFormatPluginError if serialize throws an error" time="0">
    </testcase>
    <testcase classname="prettyFormat() supports plugins with deeply nested arrays (#24)" name="prettyFormat() supports plugins with deeply nested arrays (#24)" time="0">
    </testcase>
    <testcase classname="prettyFormat() should call plugins on nested basic values" name="prettyFormat() should call plugins on nested basic values" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() prints objects with no constructor" name="prettyFormat() prints objects with no constructor" time="0">
    </testcase>
    <testcase classname="prettyFormat() prints identity-obj-proxy with string constructor" name="prettyFormat() prints identity-obj-proxy with string constructor" time="0">
    </testcase>
    <testcase classname="prettyFormat() calls toJSON and prints its return value" name="prettyFormat() calls toJSON and prints its return value" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() calls toJSON and prints an internal representation." name="prettyFormat() calls toJSON and prints an internal representation." time="0">
    </testcase>
    <testcase classname="prettyFormat() calls toJSON only on functions" name="prettyFormat() calls toJSON only on functions" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() does not call toJSON recursively" name="prettyFormat() does not call toJSON recursively" time="0">
    </testcase>
    <testcase classname="prettyFormat() calls toJSON on Sets" name="prettyFormat() calls toJSON on Sets" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() disables toJSON calls through options" name="prettyFormat() disables toJSON calls through options" time="0.009">
    </testcase>
    <testcase classname="prettyFormat() min prints some basic values in min mode" name="prettyFormat() min prints some basic values in min mode" time="0">
    </testcase>
    <testcase classname="prettyFormat() min prints some complex values in min mode" name="prettyFormat() min prints some complex values in min mode" time="0.001">
    </testcase>
    <testcase classname="prettyFormat() min does not allow indent !== 0 in min mode" name="prettyFormat() min does not allow indent !== 0 in min mode" time="0">
    </testcase>
  </testsuite>
  <testsuite name="different types" errors="0" failures="0" skipped="0" timestamp="2018-12-19T20:59:47" time="0.699" tests="86">
    <testcase classname="different types &apos;1&apos; and &apos;a&apos;" name="different types &apos;1&apos; and &apos;a&apos;" time="0.003">
    </testcase>
    <testcase classname="different types &apos;[object Object]&apos; and &apos;a&apos;" name="different types &apos;[object Object]&apos; and &apos;a&apos;" time="0.001">
    </testcase>
    <testcase classname="different types &apos;&apos; and &apos;2&apos;" name="different types &apos;&apos; and &apos;2&apos;" time="0">
    </testcase>
    <testcase classname="different types &apos;null&apos; and &apos;undefined&apos;" name="different types &apos;null&apos; and &apos;undefined&apos;" time="0.002">
    </testcase>
    <testcase classname="different types &apos;() =&gt; {}&apos; and &apos;3&apos;" name="different types &apos;() =&gt; {}&apos; and &apos;3&apos;" time="0.001">
    </testcase>
    <testcase classname="no visual difference &apos;&quot;a&quot;&apos; and &apos;&quot;a&quot;&apos; (unexpanded)" name="no visual difference &apos;&quot;a&quot;&apos; and &apos;&quot;a&quot;&apos; (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="no visual difference &apos;&quot;a&quot;&apos; and &apos;&quot;a&quot;&apos; (expanded)" name="no visual difference &apos;&quot;a&quot;&apos; and &apos;&quot;a&quot;&apos; (expanded)" time="0">
    </testcase>
    <testcase classname="no visual difference &apos;{}&apos; and &apos;{}&apos; (unexpanded)" name="no visual difference &apos;{}&apos; and &apos;{}&apos; (unexpanded)" time="0.003">
    </testcase>
    <testcase classname="no visual difference &apos;{}&apos; and &apos;{}&apos; (expanded)" name="no visual difference &apos;{}&apos; and &apos;{}&apos; (expanded)" time="0.002">
    </testcase>
    <testcase classname="no visual difference &apos;[]&apos; and &apos;[]&apos; (unexpanded)" name="no visual difference &apos;[]&apos; and &apos;[]&apos; (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="no visual difference &apos;[]&apos; and &apos;[]&apos; (expanded)" name="no visual difference &apos;[]&apos; and &apos;[]&apos; (expanded)" time="0.002">
    </testcase>
    <testcase classname="no visual difference &apos;[1,2]&apos; and &apos;[1,2]&apos; (unexpanded)" name="no visual difference &apos;[1,2]&apos; and &apos;[1,2]&apos; (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="no visual difference &apos;[1,2]&apos; and &apos;[1,2]&apos; (expanded)" name="no visual difference &apos;[1,2]&apos; and &apos;[1,2]&apos; (expanded)" time="0.002">
    </testcase>
    <testcase classname="no visual difference &apos;11&apos; and &apos;11&apos; (unexpanded)" name="no visual difference &apos;11&apos; and &apos;11&apos; (unexpanded)" time="0">
    </testcase>
    <testcase classname="no visual difference &apos;11&apos; and &apos;11&apos; (expanded)" name="no visual difference &apos;11&apos; and &apos;11&apos; (expanded)" time="0.001">
    </testcase>
    <testcase classname="no visual difference &apos;undefined&apos; and &apos;undefined&apos; (unexpanded)" name="no visual difference &apos;undefined&apos; and &apos;undefined&apos; (unexpanded)" time="0">
    </testcase>
    <testcase classname="no visual difference &apos;undefined&apos; and &apos;undefined&apos; (expanded)" name="no visual difference &apos;undefined&apos; and &apos;undefined&apos; (expanded)" time="0">
    </testcase>
    <testcase classname="no visual difference &apos;null&apos; and &apos;null&apos; (unexpanded)" name="no visual difference &apos;null&apos; and &apos;null&apos; (unexpanded)" time="0">
    </testcase>
    <testcase classname="no visual difference &apos;null&apos; and &apos;null&apos; (expanded)" name="no visual difference &apos;null&apos; and &apos;null&apos; (expanded)" time="0">
    </testcase>
    <testcase classname="no visual difference &apos;undefined&apos; and &apos;undefined&apos; (unexpanded)" name="no visual difference &apos;undefined&apos; and &apos;undefined&apos; (unexpanded)" time="0">
    </testcase>
    <testcase classname="no visual difference &apos;undefined&apos; and &apos;undefined&apos; (expanded)" name="no visual difference &apos;undefined&apos; and &apos;undefined&apos; (expanded)" time="0">
    </testcase>
    <testcase classname="no visual difference &apos;{&quot;a&quot;:1}&apos; and &apos;{&quot;a&quot;:1}&apos; (unexpanded)" name="no visual difference &apos;{&quot;a&quot;:1}&apos; and &apos;{&quot;a&quot;:1}&apos; (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="no visual difference &apos;{&quot;a&quot;:1}&apos; and &apos;{&quot;a&quot;:1}&apos; (expanded)" name="no visual difference &apos;{&quot;a&quot;:1}&apos; and &apos;{&quot;a&quot;:1}&apos; (expanded)" time="0.001">
    </testcase>
    <testcase classname="no visual difference &apos;{&quot;a&quot;:{&quot;b&quot;:5}}&apos; and &apos;{&quot;a&quot;:{&quot;b&quot;:5}}&apos; (unexpanded)" name="no visual difference &apos;{&quot;a&quot;:{&quot;b&quot;:5}}&apos; and &apos;{&quot;a&quot;:{&quot;b&quot;:5}}&apos; (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="no visual difference &apos;{&quot;a&quot;:{&quot;b&quot;:5}}&apos; and &apos;{&quot;a&quot;:{&quot;b&quot;:5}}&apos; (expanded)" name="no visual difference &apos;{&quot;a&quot;:{&quot;b&quot;:5}}&apos; and &apos;{&quot;a&quot;:{&quot;b&quot;:5}}&apos; (expanded)" time="0.002">
    </testcase>
    <testcase classname="no visual difference Map key order should be irrelevant" name="no visual difference Map key order should be irrelevant" time="0.001">
    </testcase>
    <testcase classname="no visual difference Set value order should be irrelevant" name="no visual difference Set value order should be irrelevant" time="0.001">
    </testcase>
    <testcase classname=" oneline strings" name=" oneline strings" time="0.008">
    </testcase>
    <testcase classname="falls back to not call toJSON if serialization has no differences but then objects have differences" name="falls back to not call toJSON if serialization has no differences but then objects have differences" time="0.002">
    </testcase>
    <testcase classname="falls back to not call toJSON if serialization has no differences and then objects have no differences" name="falls back to not call toJSON if serialization has no differences and then objects have no differences" time="0.001">
    </testcase>
    <testcase classname="falls back to not call toJSON if it throws and then objects have differences" name="falls back to not call toJSON if it throws and then objects have differences" time="0.002">
    </testcase>
    <testcase classname="falls back to not call toJSON if it throws and then objects have no differences" name="falls back to not call toJSON if it throws and then objects have no differences" time="0.002">
    </testcase>
    <testcase classname="multiline strings (unexpanded)" name="multiline strings (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="multiline strings (expanded)" name="multiline strings (expanded)" time="0.001">
    </testcase>
    <testcase classname="objects (unexpanded)" name="objects (unexpanded)" time="0.003">
    </testcase>
    <testcase classname="objects (expanded)" name="objects (expanded)" time="0.003">
    </testcase>
    <testcase classname=" numbers" name=" numbers" time="0.001">
    </testcase>
    <testcase classname=" booleans" name=" booleans" time="0">
    </testcase>
    <testcase classname="multiline string non-snapshot (unexpanded)" name="multiline string non-snapshot (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="multiline string non-snapshot (expanded)" name="multiline string non-snapshot (expanded)" time="0.002">
    </testcase>
    <testcase classname="multiline string snapshot (unexpanded)" name="multiline string snapshot (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="multiline string snapshot (expanded)" name="multiline string snapshot (expanded)" time="0.002">
    </testcase>
    <testcase classname="React elements (unexpanded)" name="React elements (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="React elements (expanded)" name="React elements (expanded)" time="0.001">
    </testcase>
    <testcase classname="multiline string as value of object property (non-snapshot) (unexpanded)" name="multiline string as value of object property (non-snapshot) (unexpanded)" time="0.002">
    </testcase>
    <testcase classname="multiline string as value of object property (non-snapshot) (expanded)" name="multiline string as value of object property (non-snapshot) (expanded)" time="0.001">
    </testcase>
    <testcase classname="multiline string as value of object property (snapshot) (unexpanded)" name="multiline string as value of object property (snapshot) (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="multiline string as value of object property (snapshot) (expanded)" name="multiline string as value of object property (snapshot) (expanded)" time="0.001">
    </testcase>
    <testcase classname="indentation in JavaScript structures from less to more (unexpanded)" name="indentation in JavaScript structures from less to more (unexpanded)" time="0.002">
    </testcase>
    <testcase classname="indentation in JavaScript structures from less to more (expanded)" name="indentation in JavaScript structures from less to more (expanded)" time="0.002">
    </testcase>
    <testcase classname="indentation in JavaScript structures from more to less (unexpanded)" name="indentation in JavaScript structures from more to less (unexpanded)" time="0.002">
    </testcase>
    <testcase classname="indentation in JavaScript structures from more to less (expanded)" name="indentation in JavaScript structures from more to less (expanded)" time="0.002">
    </testcase>
    <testcase classname="color of text (expanded)" name="color of text (expanded)" time="0.001">
    </testcase>
    <testcase classname="color of text (unexpanded)" name="color of text (unexpanded)" time="0.002">
    </testcase>
    <testcase classname="indentation in React elements (non-snapshot) from less to more (unexpanded)" name="indentation in React elements (non-snapshot) from less to more (unexpanded)" time="0.002">
    </testcase>
    <testcase classname="indentation in React elements (non-snapshot) from less to more (expanded)" name="indentation in React elements (non-snapshot) from less to more (expanded)" time="0.001">
    </testcase>
    <testcase classname="indentation in React elements (non-snapshot) from more to less (unexpanded)" name="indentation in React elements (non-snapshot) from more to less (unexpanded)" time="0.011">
    </testcase>
    <testcase classname="indentation in React elements (non-snapshot) from more to less (expanded)" name="indentation in React elements (non-snapshot) from more to less (expanded)" time="0.002">
    </testcase>
    <testcase classname="indentation in React elements (snapshot) from less to more (unexpanded)" name="indentation in React elements (snapshot) from less to more (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="indentation in React elements (snapshot) from less to more (expanded)" name="indentation in React elements (snapshot) from less to more (expanded)" time="0.001">
    </testcase>
    <testcase classname="indentation in React elements (snapshot) from more to less (unexpanded)" name="indentation in React elements (snapshot) from more to less (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="indentation in React elements (snapshot) from more to less (expanded)" name="indentation in React elements (snapshot) from more to less (expanded)" time="0.003">
    </testcase>
    <testcase classname="outer React element (non-snapshot) from less to more (unexpanded)" name="outer React element (non-snapshot) from less to more (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="outer React element (non-snapshot) from less to more (expanded)" name="outer React element (non-snapshot) from less to more (expanded)" time="0.003">
    </testcase>
    <testcase classname="outer React element (non-snapshot) from more to less (unexpanded)" name="outer React element (non-snapshot) from more to less (unexpanded)" time="0.002">
    </testcase>
    <testcase classname="outer React element (non-snapshot) from more to less (expanded)" name="outer React element (non-snapshot) from more to less (expanded)" time="0.002">
    </testcase>
    <testcase classname="trailing newline in multiline string not enclosed in quotes from less to more (unexpanded)" name="trailing newline in multiline string not enclosed in quotes from less to more (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="trailing newline in multiline string not enclosed in quotes from less to more (expanded)" name="trailing newline in multiline string not enclosed in quotes from less to more (expanded)" time="0.001">
    </testcase>
    <testcase classname="trailing newline in multiline string not enclosed in quotes from more to less (unexpanded)" name="trailing newline in multiline string not enclosed in quotes from more to less (unexpanded)" time="0">
    </testcase>
    <testcase classname="trailing newline in multiline string not enclosed in quotes from more to less (expanded)" name="trailing newline in multiline string not enclosed in quotes from more to less (expanded)" time="0.001">
    </testcase>
    <testcase classname="background color of spaces cyan for inchanged (expanded)" name="background color of spaces cyan for inchanged (expanded)" time="0.001">
    </testcase>
    <testcase classname="background color of spaces cyan for inchanged (unexpanded)" name="background color of spaces cyan for inchanged (unexpanded)" time="0.002">
    </testcase>
    <testcase classname="background color of spaces green for removed (expanded)" name="background color of spaces green for removed (expanded)" time="0.001">
    </testcase>
    <testcase classname="background color of spaces green for removed (unexpanded)" name="background color of spaces green for removed (unexpanded)" time="0.003">
    </testcase>
    <testcase classname="background color of spaces red for added (expanded)" name="background color of spaces red for added (expanded)" time="0">
    </testcase>
    <testcase classname="background color of spaces red for added (unexpanded)" name="background color of spaces red for added (unexpanded)" time="0.001">
    </testcase>
    <testcase classname="background color of spaces yellow for unchanged (expanded)" name="background color of spaces yellow for unchanged (expanded)" time="0.001">
    </testcase>
    <testcase classname="background color of spaces yellow for unchanged (unexpanded)" name="background color of spaces yellow for unchanged (unexpanded)" time="0.002">
    </testcase>
    <testcase classname="highlight only the last in odd length of leading spaces (expanded)" name="highlight only the last in odd length of leading spaces (expanded)" time="0.001">
    </testcase>
    <testcase classname="highlight only the last in odd length of leading spaces (unexpanded)" name="highlight only the last in odd length of leading spaces (unexpanded)" time="0.001">
    </testcase>
    <testcase classname=" collapses big diffs to patch format" name=" collapses big diffs to patch format" time="0.004">
    </testcase>
    <testcase classname="context number of lines: null (5 default)" name="context number of lines: null (5 default)" time="0.002">
    </testcase>
    <testcase classname="context number of lines: 2 " name="context number of lines: 2 " time="0.002">
    </testcase>
    <testcase classname="context number of lines: 1 " name="context number of lines: 1 " time="0.002">
    </testcase>
    <testcase classname="context number of lines: 0 " name="context number of lines: 0 " time="0.002">
    </testcase>
    <testcase classname="context number of lines: -1 (5 default)" name="context number of lines: -1 (5 default)" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T20:59:48" time="0.585" tests="51">
    <testcase classname=" supports a single element with no props or children" name=" supports a single element with no props or children" time="0.022">
    </testcase>
    <testcase classname=" supports a single element with non-empty string child" name=" supports a single element with non-empty string child" time="0.003">
    </testcase>
    <testcase classname=" supports a single element with empty string child" name=" supports a single element with empty string child" time="0.001">
    </testcase>
    <testcase classname=" supports a single element with non-zero number child" name=" supports a single element with non-zero number child" time="0.002">
    </testcase>
    <testcase classname=" supports a single element with zero number child" name=" supports a single element with zero number child" time="0.001">
    </testcase>
    <testcase classname=" supports a single element with mixed children" name=" supports a single element with mixed children" time="0.005">
    </testcase>
    <testcase classname=" supports props with strings" name=" supports props with strings" time="0.002">
    </testcase>
    <testcase classname=" supports props with multiline strings" name=" supports props with multiline strings" time="0.002">
    </testcase>
    <testcase classname=" supports props with numbers" name=" supports props with numbers" time="0.001">
    </testcase>
    <testcase classname=" supports a single element with a function prop" name=" supports a single element with a function prop" time="0.002">
    </testcase>
    <testcase classname=" supports a single element with a object prop" name=" supports a single element with a object prop" time="0.001">
    </testcase>
    <testcase classname=" supports an element with and object prop and children" name=" supports an element with and object prop and children" time="0.002">
    </testcase>
    <testcase classname=" supports an element with complex props and mixed children" name=" supports an element with complex props and mixed children" time="0.003">
    </testcase>
    <testcase classname=" escapes children properly" name=" escapes children properly" time="0.001">
    </testcase>
    <testcase classname=" supports everything all together" name=" supports everything all together" time="0.002">
    </testcase>
    <testcase classname=" sorts props in nested components" name=" sorts props in nested components" time="0.001">
    </testcase>
    <testcase classname=" supports a single element with React elements as props" name=" supports a single element with React elements as props" time="0.003">
    </testcase>
    <testcase classname=" supports a single element with React elements with props" name=" supports a single element with React elements with props" time="0.002">
    </testcase>
    <testcase classname=" supports a single element with custom React elements with props" name=" supports a single element with custom React elements with props" time="0.002">
    </testcase>
    <testcase classname=" supports a single element with custom React elements with props (using displayName)" name=" supports a single element with custom React elements with props (using displayName)" time="0.001">
    </testcase>
    <testcase classname=" supports a single element with custom React elements with props (using anonymous function)" name=" supports a single element with custom React elements with props (using anonymous function)" time="0.001">
    </testcase>
    <testcase classname=" supports a single element with custom React elements with a child" name=" supports a single element with custom React elements with a child" time="0">
    </testcase>
    <testcase classname=" supports undefined element type" name=" supports undefined element type" time="0">
    </testcase>
    <testcase classname=" supports a fragment with no children" name=" supports a fragment with no children" time="0">
    </testcase>
    <testcase classname=" supports a fragment with string child" name=" supports a fragment with string child" time="0">
    </testcase>
    <testcase classname=" supports a fragment with element child" name=" supports a fragment with element child" time="0">
    </testcase>
    <testcase classname=" supports a single element with React elements with a child" name=" supports a single element with React elements with a child" time="0.001">
    </testcase>
    <testcase classname=" supports a single element with React elements with children" name=" supports a single element with React elements with children" time="0">
    </testcase>
    <testcase classname=" supports a single element with React elements with array children" name=" supports a single element with React elements with array children" time="0.001">
    </testcase>
    <testcase classname=" supports array of elements" name=" supports array of elements" time="0.001">
    </testcase>
    <testcase classname="test object for subset match undefined props" name="test object for subset match undefined props" time="0.001">
    </testcase>
    <testcase classname="test object for subset match undefined children" name="test object for subset match undefined children" time="0">
    </testcase>
    <testcase classname="indent option default implicit: 2 spaces" name="indent option default implicit: 2 spaces" time="0.001">
    </testcase>
    <testcase classname="indent option default explicit: 2 spaces" name="indent option default explicit: 2 spaces" time="0.001">
    </testcase>
    <testcase classname="indent option non-default: 0 spaces" name="indent option non-default: 0 spaces" time="0.001">
    </testcase>
    <testcase classname="indent option non-default: 4 spaces" name="indent option non-default: 4 spaces" time="0">
    </testcase>
    <testcase classname="maxDepth option elements" name="maxDepth option elements" time="0.001">
    </testcase>
    <testcase classname="maxDepth option array of elements" name="maxDepth option array of elements" time="0.002">
    </testcase>
    <testcase classname=" min option" name=" min option" time="0.002">
    </testcase>
    <testcase classname=" ReactElement plugin highlights syntax" name=" ReactElement plugin highlights syntax" time="0.002">
    </testcase>
    <testcase classname=" ReactTestComponent plugin highlights syntax" name=" ReactTestComponent plugin highlights syntax" time="0.002">
    </testcase>
    <testcase classname=" throws if theme option is null" name=" throws if theme option is null" time="0.001">
    </testcase>
    <testcase classname=" throws if theme option is not of type &quot;object&quot;" name=" throws if theme option is not of type &quot;object&quot;" time="0.001">
    </testcase>
    <testcase classname=" throws if theme option has value that is undefined in ansi-styles" name=" throws if theme option has value that is undefined in ansi-styles" time="0.001">
    </testcase>
    <testcase classname=" ReactElement plugin highlights syntax with color from theme option" name=" ReactElement plugin highlights syntax with color from theme option" time="0.001">
    </testcase>
    <testcase classname=" ReactTestComponent plugin highlights syntax with color from theme option" name=" ReactTestComponent plugin highlights syntax with color from theme option" time="0.001">
    </testcase>
    <testcase classname=" supports forwardRef with a child" name=" supports forwardRef with a child" time="0.009">
    </testcase>
    <testcase classname=" supports context Provider with a child" name=" supports context Provider with a child" time="0">
    </testcase>
    <testcase classname=" supports context Consumer with a child" name=" supports context Consumer with a child" time="0.001">
    </testcase>
    <testcase classname=" ReactElement removes undefined props" name=" ReactElement removes undefined props" time="0.009">
    </testcase>
    <testcase classname=" ReactTestComponent removes undefined props" name=" ReactTestComponent removes undefined props" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="ScriptTransformer" errors="0" failures="0" skipped="0" timestamp="2018-12-19T20:59:48" time="9.912" tests="15">
    <testcase classname="ScriptTransformer transforms a file properly" name="ScriptTransformer transforms a file properly" time="3.452">
    </testcase>
    <testcase classname="ScriptTransformer does not transform Node core modules" name="ScriptTransformer does not transform Node core modules" time="0.431">
    </testcase>
    <testcase classname="ScriptTransformer throws an error if `process` doesn&apos;t return a string or an objectcontaining `code` key with processed string" name="ScriptTransformer throws an error if `process` doesn&apos;t return a string or an objectcontaining `code` key with processed string" time="0.585">
    </testcase>
    <testcase classname="ScriptTransformer throws an error if `process` doesn&apos;t defined" name="ScriptTransformer throws an error if `process` doesn&apos;t defined" time="0.344">
    </testcase>
    <testcase classname="ScriptTransformer throws an error if createTransformer returns object without `process` method" name="ScriptTransformer throws an error if createTransformer returns object without `process` method" time="0.356">
    </testcase>
    <testcase classname="ScriptTransformer shouldn&apos;t throw error without process method. But with corrent createTransformer method" name="ScriptTransformer shouldn&apos;t throw error without process method. But with corrent createTransformer method" time="0.401">
    </testcase>
    <testcase classname="ScriptTransformer uses the supplied preprocessor" name="ScriptTransformer uses the supplied preprocessor" time="0.323">
    </testcase>
    <testcase classname="ScriptTransformer uses multiple preprocessors" name="ScriptTransformer uses multiple preprocessors" time="0.523">
    </testcase>
    <testcase classname="ScriptTransformer writes source map if preprocessor supplies it" name="ScriptTransformer writes source map if preprocessor supplies it" time="0.387">
    </testcase>
    <testcase classname="ScriptTransformer writes source map if preprocessor inlines it" name="ScriptTransformer writes source map if preprocessor inlines it" time="0.483">
    </testcase>
    <testcase classname="ScriptTransformer writes source maps if given by the transformer" name="ScriptTransformer writes source maps if given by the transformer" time="0.436">
    </testcase>
    <testcase classname="ScriptTransformer does not write source map if not given by the transformer" name="ScriptTransformer does not write source map if not given by the transformer" time="0.399">
    </testcase>
    <testcase classname="ScriptTransformer passes expected transform options to getCacheKey" name="ScriptTransformer passes expected transform options to getCacheKey" time="0.342">
    </testcase>
    <testcase classname="ScriptTransformer reads values from the cache" name="ScriptTransformer reads values from the cache" time="0.832">
    </testcase>
    <testcase classname="ScriptTransformer does not reuse the in-memory cache between different projects" name="ScriptTransformer does not reuse the in-memory cache between different projects" time="0.237">
    </testcase>
  </testsuite>
  <testsuite name="watchman watch" errors="0" failures="0" skipped="0" timestamp="2018-12-19T20:59:58" time="0.348" tests="8">
    <testcase classname="watchman watch returns a list of all files when there are no clocks" name="watchman watch returns a list of all files when there are no clocks" time="0.046">
    </testcase>
    <testcase classname="watchman watch applies the mapper when needed" name="watchman watch applies the mapper when needed" time="0.002">
    </testcase>
    <testcase classname="watchman watch updates the file object when the clock is given" name="watchman watch updates the file object when the clock is given" time="0.003">
    </testcase>
    <testcase classname="watchman watch resets the file object when watchman is restarted" name="watchman watch resets the file object when watchman is restarted" time="0.004">
    </testcase>
    <testcase classname="watchman watch properly resets the file map when only one watcher is reset" name="watchman watch properly resets the file map when only one watcher is reset" time="0.002">
    </testcase>
    <testcase classname="watchman watch does not add directory filters to query when watching a ROOT" name="watchman watch does not add directory filters to query when watching a ROOT" time="0.014">
    </testcase>
    <testcase classname="watchman watch SHA-1 requested and available" name="watchman watch SHA-1 requested and available" time="0.022">
    </testcase>
    <testcase classname="watchman watch SHA-1 requested and NOT available" name="watchman watch SHA-1 requested and NOT available" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="pretty-format" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:00:02" time="0.489" tests="26">
    <testcase classname="pretty-format prints global window as constructor name alone" name="pretty-format prints global window as constructor name alone" time="0.001">
    </testcase>
    <testcase classname="DOMElement Plugin supports a single HTML element" name="DOMElement Plugin supports a single HTML element" time="0.006">
    </testcase>
    <testcase classname="DOMElement Plugin supports an HTML element with a class property" name="DOMElement Plugin supports an HTML element with a class property" time="0.003">
    </testcase>
    <testcase classname="DOMElement Plugin supports an HTML element with a title property" name="DOMElement Plugin supports an HTML element with a title property" time="0">
    </testcase>
    <testcase classname="DOMElement Plugin escapes double quote in attribute value" name="DOMElement Plugin escapes double quote in attribute value" time="0.001">
    </testcase>
    <testcase classname="DOMElement Plugin supports an HTML element with a single attribute" name="DOMElement Plugin supports an HTML element with a single attribute" time="0">
    </testcase>
    <testcase classname="DOMElement Plugin supports an HTML element with multiple attributes" name="DOMElement Plugin supports an HTML element with multiple attributes" time="0.001">
    </testcase>
    <testcase classname="DOMElement Plugin supports an HTML element with attribute and text content" name="DOMElement Plugin supports an HTML element with attribute and text content" time="0.007">
    </testcase>
    <testcase classname="DOMElement Plugin supports an element with text content" name="DOMElement Plugin supports an element with text content" time="0.002">
    </testcase>
    <testcase classname="DOMElement Plugin supports nested elements" name="DOMElement Plugin supports nested elements" time="0.001">
    </testcase>
    <testcase classname="DOMElement Plugin supports nested elements with attributes" name="DOMElement Plugin supports nested elements with attributes" time="0.003">
    </testcase>
    <testcase classname="DOMElement Plugin supports nested elements with attribute and text content" name="DOMElement Plugin supports nested elements with attribute and text content" time="0.001">
    </testcase>
    <testcase classname="DOMElement Plugin supports nested elements with text content" name="DOMElement Plugin supports nested elements with text content" time="0.002">
    </testcase>
    <testcase classname="DOMElement Plugin supports siblings" name="DOMElement Plugin supports siblings" time="0.012">
    </testcase>
    <testcase classname="DOMElement Plugin supports multiline text node in pre" name="DOMElement Plugin supports multiline text node in pre" time="0.002">
    </testcase>
    <testcase classname="DOMElement Plugin supports multiline text node preceding span in pre" name="DOMElement Plugin supports multiline text node preceding span in pre" time="0.004">
    </testcase>
    <testcase classname="DOMElement Plugin supports multiline text node in textarea" name="DOMElement Plugin supports multiline text node in textarea" time="0.002">
    </testcase>
    <testcase classname="DOMElement Plugin supports empty text node" name="DOMElement Plugin supports empty text node" time="0.003">
    </testcase>
    <testcase classname="DOMElement Plugin supports non-empty text node" name="DOMElement Plugin supports non-empty text node" time="0.005">
    </testcase>
    <testcase classname="DOMElement Plugin supports comment node" name="DOMElement Plugin supports comment node" time="0.004">
    </testcase>
    <testcase classname="DOMElement Plugin supports fragment node" name="DOMElement Plugin supports fragment node" time="0.006">
    </testcase>
    <testcase classname="DOMElement Plugin matches constructor name of SVG elements jsdom 9 and 10" name="DOMElement Plugin matches constructor name of SVG elements jsdom 9 and 10" time="0.001">
    </testcase>
    <testcase classname="DOMElement Plugin matches constructor name of SVG elements jsdom 11" name="DOMElement Plugin matches constructor name of SVG elements jsdom 11" time="0">
    </testcase>
    <testcase classname="DOMElement Plugin supports SVG elements" name="DOMElement Plugin supports SVG elements" time="0.004">
    </testcase>
    <testcase classname="DOMElement Plugin supports indentation for array of elements" name="DOMElement Plugin supports indentation for array of elements" time="0.002">
    </testcase>
    <testcase classname="DOMElement Plugin supports maxDepth option" name="DOMElement Plugin supports maxDepth option" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="SearchSource" errors="0" failures="0" skipped="23" timestamp="2018-12-19T21:00:03" time="0.803" tests="24">
    <testcase classname="SearchSource does not work on Windows" name="SearchSource does not work on Windows" time="0.417">
    </testcase>
    <testcase classname="SearchSource isTestFilePath supports ../ paths and unix separators via testRegex" name="SearchSource isTestFilePath supports ../ paths and unix separators via testRegex" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource isTestFilePath supports unix separators" name="SearchSource isTestFilePath supports unix separators" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource isTestFilePath supports win32 separators" name="SearchSource isTestFilePath supports win32 separators" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource testPathsMatching finds tests matching a pattern via testRegex" name="SearchSource testPathsMatching finds tests matching a pattern via testRegex" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource testPathsMatching finds tests matching a pattern via testMatch" name="SearchSource testPathsMatching finds tests matching a pattern via testMatch" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource testPathsMatching finds tests matching a JS regex pattern" name="SearchSource testPathsMatching finds tests matching a JS regex pattern" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource testPathsMatching finds tests matching a JS glob pattern" name="SearchSource testPathsMatching finds tests matching a JS glob pattern" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource testPathsMatching finds tests with default file extensions using testRegex" name="SearchSource testPathsMatching finds tests with default file extensions using testRegex" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource testPathsMatching finds tests with default file extensions using testMatch" name="SearchSource testPathsMatching finds tests with default file extensions using testMatch" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource testPathsMatching finds tests with parentheses in their rootDir when using testMatch" name="SearchSource testPathsMatching finds tests with parentheses in their rootDir when using testMatch" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource testPathsMatching finds tests with similar but custom file extensions" name="SearchSource testPathsMatching finds tests with similar but custom file extensions" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource testPathsMatching finds tests with totally custom foobar file extensions" name="SearchSource testPathsMatching finds tests with totally custom foobar file extensions" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource testPathsMatching finds tests with many kinds of file extensions" name="SearchSource testPathsMatching finds tests with many kinds of file extensions" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource testPathsMatching finds tests using a regex only" name="SearchSource testPathsMatching finds tests using a regex only" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource testPathsMatching finds tests using a glob only" name="SearchSource testPathsMatching finds tests using a glob only" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource findRelatedTests makes sure a file is related to itself" name="SearchSource findRelatedTests makes sure a file is related to itself" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource findRelatedTests finds tests that depend directly on the path" name="SearchSource findRelatedTests finds tests that depend directly on the path" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource findRelatedTestsFromPattern returns empty search result for empty input" name="SearchSource findRelatedTestsFromPattern returns empty search result for empty input" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource findRelatedTestsFromPattern returns empty search result for invalid input" name="SearchSource findRelatedTestsFromPattern returns empty search result for invalid input" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource findRelatedTestsFromPattern returns empty search result if no related tests were found" name="SearchSource findRelatedTestsFromPattern returns empty search result if no related tests were found" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource findRelatedTestsFromPattern finds tests for a single file" name="SearchSource findRelatedTestsFromPattern finds tests for a single file" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource findRelatedTestsFromPattern finds tests for multiple files" name="SearchSource findRelatedTestsFromPattern finds tests for multiple files" time="0">
      <skipped/>
    </testcase>
    <testcase classname="SearchSource findRelatedTestsFromPattern does not mistake roots folders with prefix names" name="SearchSource findRelatedTestsFromPattern does not mistake roots folders with prefix names" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="jest-each" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:00:04" time="0.63" tests="122">
    <testcase classname="jest-each .test throws error when there are no arguments for given headings" name="jest-each .test throws error when there are no arguments for given headings" time="0.005">
    </testcase>
    <testcase classname="jest-each .test throws error when there are fewer arguments than headings when given one row" name="jest-each .test throws error when there are fewer arguments than headings when given one row" time="0.004">
    </testcase>
    <testcase classname="jest-each .test throws error when there are fewer arguments than headings over multiple rows" name="jest-each .test throws error when there are fewer arguments than headings over multiple rows" time="0.003">
    </testcase>
    <testcase classname="jest-each .test throws an error when called with an empty string" name="jest-each .test throws an error when called with an empty string" time="0.002">
    </testcase>
    <testcase classname="jest-each .test calls global with given title" name="jest-each .test calls global with given title" time="0.002">
    </testcase>
    <testcase classname="jest-each .test calls global with given title when multiple tests cases exist" name="jest-each .test calls global with given title when multiple tests cases exist" time="0.002">
    </testcase>
    <testcase classname="jest-each .test calls global with title containing param values when using $variable format" name="jest-each .test calls global with title containing param values when using $variable format" time="0.003">
    </testcase>
    <testcase classname="jest-each .test calls global with title containing $key in multiple positions" name="jest-each .test calls global with title containing $key in multiple positions" time="0">
    </testcase>
    <testcase classname="jest-each .test calls global with title containing $key.path" name="jest-each .test calls global with title containing $key.path" time="0.001">
    </testcase>
    <testcase classname="jest-each .test calls global with title containing last seen object when $key.path is invalid" name="jest-each .test calls global with title containing last seen object when $key.path is invalid" time="0.001">
    </testcase>
    <testcase classname="jest-each .test calls global with cb function with object built from table headings and values" name="jest-each .test calls global with cb function with object built from table headings and values" time="0.001">
    </testcase>
    <testcase classname="jest-each .test calls global with given timeout" name="jest-each .test calls global with given timeout" time="0.001">
    </testcase>
    <testcase classname="jest-each .test.only throws error when there are no arguments for given headings" name="jest-each .test.only throws error when there are no arguments for given headings" time="0.002">
    </testcase>
    <testcase classname="jest-each .test.only throws error when there are fewer arguments than headings when given one row" name="jest-each .test.only throws error when there are fewer arguments than headings when given one row" time="0.002">
    </testcase>
    <testcase classname="jest-each .test.only throws error when there are fewer arguments than headings over multiple rows" name="jest-each .test.only throws error when there are fewer arguments than headings over multiple rows" time="0.003">
    </testcase>
    <testcase classname="jest-each .test.only throws an error when called with an empty string" name="jest-each .test.only throws an error when called with an empty string" time="0.003">
    </testcase>
    <testcase classname="jest-each .test.only calls global with given title" name="jest-each .test.only calls global with given title" time="0.001">
    </testcase>
    <testcase classname="jest-each .test.only calls global with given title when multiple tests cases exist" name="jest-each .test.only calls global with given title when multiple tests cases exist" time="0">
    </testcase>
    <testcase classname="jest-each .test.only calls global with title containing param values when using $variable format" name="jest-each .test.only calls global with title containing param values when using $variable format" time="0.001">
    </testcase>
    <testcase classname="jest-each .test.only calls global with title containing $key in multiple positions" name="jest-each .test.only calls global with title containing $key in multiple positions" time="0.001">
    </testcase>
    <testcase classname="jest-each .test.only calls global with title containing $key.path" name="jest-each .test.only calls global with title containing $key.path" time="0">
    </testcase>
    <testcase classname="jest-each .test.only calls global with title containing last seen object when $key.path is invalid" name="jest-each .test.only calls global with title containing last seen object when $key.path is invalid" time="0.001">
    </testcase>
    <testcase classname="jest-each .test.only calls global with cb function with object built from table headings and values" name="jest-each .test.only calls global with cb function with object built from table headings and values" time="0.001">
    </testcase>
    <testcase classname="jest-each .test.only calls global with given timeout" name="jest-each .test.only calls global with given timeout" time="0.001">
    </testcase>
    <testcase classname="jest-each .it throws error when there are no arguments for given headings" name="jest-each .it throws error when there are no arguments for given headings" time="0.002">
    </testcase>
    <testcase classname="jest-each .it throws error when there are fewer arguments than headings when given one row" name="jest-each .it throws error when there are fewer arguments than headings when given one row" time="0.001">
    </testcase>
    <testcase classname="jest-each .it throws error when there are fewer arguments than headings over multiple rows" name="jest-each .it throws error when there are fewer arguments than headings over multiple rows" time="0.002">
    </testcase>
    <testcase classname="jest-each .it throws an error when called with an empty string" name="jest-each .it throws an error when called with an empty string" time="0.001">
    </testcase>
    <testcase classname="jest-each .it calls global with given title" name="jest-each .it calls global with given title" time="0.001">
    </testcase>
    <testcase classname="jest-each .it calls global with given title when multiple tests cases exist" name="jest-each .it calls global with given title when multiple tests cases exist" time="0.001">
    </testcase>
    <testcase classname="jest-each .it calls global with title containing param values when using $variable format" name="jest-each .it calls global with title containing param values when using $variable format" time="0">
    </testcase>
    <testcase classname="jest-each .it calls global with title containing $key in multiple positions" name="jest-each .it calls global with title containing $key in multiple positions" time="0.003">
    </testcase>
    <testcase classname="jest-each .it calls global with title containing $key.path" name="jest-each .it calls global with title containing $key.path" time="0.001">
    </testcase>
    <testcase classname="jest-each .it calls global with title containing last seen object when $key.path is invalid" name="jest-each .it calls global with title containing last seen object when $key.path is invalid" time="0">
    </testcase>
    <testcase classname="jest-each .it calls global with cb function with object built from table headings and values" name="jest-each .it calls global with cb function with object built from table headings and values" time="0.001">
    </testcase>
    <testcase classname="jest-each .it calls global with given timeout" name="jest-each .it calls global with given timeout" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit throws error when there are no arguments for given headings" name="jest-each .fit throws error when there are no arguments for given headings" time="0">
    </testcase>
    <testcase classname="jest-each .fit throws error when there are fewer arguments than headings when given one row" name="jest-each .fit throws error when there are fewer arguments than headings when given one row" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit throws error when there are fewer arguments than headings over multiple rows" name="jest-each .fit throws error when there are fewer arguments than headings over multiple rows" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit throws an error when called with an empty string" name="jest-each .fit throws an error when called with an empty string" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit calls global with given title" name="jest-each .fit calls global with given title" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit calls global with given title when multiple tests cases exist" name="jest-each .fit calls global with given title when multiple tests cases exist" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit calls global with title containing param values when using $variable format" name="jest-each .fit calls global with title containing param values when using $variable format" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit calls global with title containing $key in multiple positions" name="jest-each .fit calls global with title containing $key in multiple positions" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit calls global with title containing $key.path" name="jest-each .fit calls global with title containing $key.path" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit calls global with title containing last seen object when $key.path is invalid" name="jest-each .fit calls global with title containing last seen object when $key.path is invalid" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit calls global with cb function with object built from table headings and values" name="jest-each .fit calls global with cb function with object built from table headings and values" time="0.002">
    </testcase>
    <testcase classname="jest-each .fit calls global with given timeout" name="jest-each .fit calls global with given timeout" time="0">
    </testcase>
    <testcase classname="jest-each .it.only throws error when there are no arguments for given headings" name="jest-each .it.only throws error when there are no arguments for given headings" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.only throws error when there are fewer arguments than headings when given one row" name="jest-each .it.only throws error when there are fewer arguments than headings when given one row" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.only throws error when there are fewer arguments than headings over multiple rows" name="jest-each .it.only throws error when there are fewer arguments than headings over multiple rows" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.only throws an error when called with an empty string" name="jest-each .it.only throws an error when called with an empty string" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.only calls global with given title" name="jest-each .it.only calls global with given title" time="0.005">
    </testcase>
    <testcase classname="jest-each .it.only calls global with given title when multiple tests cases exist" name="jest-each .it.only calls global with given title when multiple tests cases exist" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.only calls global with title containing param values when using $variable format" name="jest-each .it.only calls global with title containing param values when using $variable format" time="0.008">
    </testcase>
    <testcase classname="jest-each .it.only calls global with title containing $key in multiple positions" name="jest-each .it.only calls global with title containing $key in multiple positions" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.only calls global with title containing $key.path" name="jest-each .it.only calls global with title containing $key.path" time="0">
    </testcase>
    <testcase classname="jest-each .it.only calls global with title containing last seen object when $key.path is invalid" name="jest-each .it.only calls global with title containing last seen object when $key.path is invalid" time="0">
    </testcase>
    <testcase classname="jest-each .it.only calls global with cb function with object built from table headings and values" name="jest-each .it.only calls global with cb function with object built from table headings and values" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.only calls global with given timeout" name="jest-each .it.only calls global with given timeout" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe throws error when there are no arguments for given headings" name="jest-each .describe throws error when there are no arguments for given headings" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe throws error when there are fewer arguments than headings when given one row" name="jest-each .describe throws error when there are fewer arguments than headings when given one row" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe throws error when there are fewer arguments than headings over multiple rows" name="jest-each .describe throws error when there are fewer arguments than headings over multiple rows" time="0.002">
    </testcase>
    <testcase classname="jest-each .describe throws an error when called with an empty string" name="jest-each .describe throws an error when called with an empty string" time="0.002">
    </testcase>
    <testcase classname="jest-each .describe calls global with given title" name="jest-each .describe calls global with given title" time="0.002">
    </testcase>
    <testcase classname="jest-each .describe calls global with given title when multiple tests cases exist" name="jest-each .describe calls global with given title when multiple tests cases exist" time="0.002">
    </testcase>
    <testcase classname="jest-each .describe calls global with title containing param values when using $variable format" name="jest-each .describe calls global with title containing param values when using $variable format" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe calls global with title containing $key in multiple positions" name="jest-each .describe calls global with title containing $key in multiple positions" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe calls global with title containing $key.path" name="jest-each .describe calls global with title containing $key.path" time="0">
    </testcase>
    <testcase classname="jest-each .describe calls global with title containing last seen object when $key.path is invalid" name="jest-each .describe calls global with title containing last seen object when $key.path is invalid" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe calls global with cb function with object built from table headings and values" name="jest-each .describe calls global with cb function with object built from table headings and values" time="0.002">
    </testcase>
    <testcase classname="jest-each .describe calls global with given timeout" name="jest-each .describe calls global with given timeout" time="0.001">
    </testcase>
    <testcase classname="jest-each .fdescribe throws error when there are no arguments for given headings" name="jest-each .fdescribe throws error when there are no arguments for given headings" time="0">
    </testcase>
    <testcase classname="jest-each .fdescribe throws error when there are fewer arguments than headings when given one row" name="jest-each .fdescribe throws error when there are fewer arguments than headings when given one row" time="0.001">
    </testcase>
    <testcase classname="jest-each .fdescribe throws error when there are fewer arguments than headings over multiple rows" name="jest-each .fdescribe throws error when there are fewer arguments than headings over multiple rows" time="0">
    </testcase>
    <testcase classname="jest-each .fdescribe throws an error when called with an empty string" name="jest-each .fdescribe throws an error when called with an empty string" time="0.001">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global with given title" name="jest-each .fdescribe calls global with given title" time="0">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global with given title when multiple tests cases exist" name="jest-each .fdescribe calls global with given title when multiple tests cases exist" time="0">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global with title containing param values when using $variable format" name="jest-each .fdescribe calls global with title containing param values when using $variable format" time="0.001">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global with title containing $key in multiple positions" name="jest-each .fdescribe calls global with title containing $key in multiple positions" time="0">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global with title containing $key.path" name="jest-each .fdescribe calls global with title containing $key.path" time="0">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global with title containing last seen object when $key.path is invalid" name="jest-each .fdescribe calls global with title containing last seen object when $key.path is invalid" time="0.001">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global with cb function with object built from table headings and values" name="jest-each .fdescribe calls global with cb function with object built from table headings and values" time="0">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global with given timeout" name="jest-each .fdescribe calls global with given timeout" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only throws error when there are no arguments for given headings" name="jest-each .describe.only throws error when there are no arguments for given headings" time="0">
    </testcase>
    <testcase classname="jest-each .describe.only throws error when there are fewer arguments than headings when given one row" name="jest-each .describe.only throws error when there are fewer arguments than headings when given one row" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only throws error when there are fewer arguments than headings over multiple rows" name="jest-each .describe.only throws error when there are fewer arguments than headings over multiple rows" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only throws an error when called with an empty string" name="jest-each .describe.only throws an error when called with an empty string" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only calls global with given title" name="jest-each .describe.only calls global with given title" time="0">
    </testcase>
    <testcase classname="jest-each .describe.only calls global with given title when multiple tests cases exist" name="jest-each .describe.only calls global with given title when multiple tests cases exist" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only calls global with title containing param values when using $variable format" name="jest-each .describe.only calls global with title containing param values when using $variable format" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only calls global with title containing $key in multiple positions" name="jest-each .describe.only calls global with title containing $key in multiple positions" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only calls global with title containing $key.path" name="jest-each .describe.only calls global with title containing $key.path" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only calls global with title containing last seen object when $key.path is invalid" name="jest-each .describe.only calls global with title containing last seen object when $key.path is invalid" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only calls global with cb function with object built from table headings and values" name="jest-each .describe.only calls global with cb function with object built from table headings and values" time="0.002">
    </testcase>
    <testcase classname="jest-each .describe.only calls global with given timeout" name="jest-each .describe.only calls global with given timeout" time="0">
    </testcase>
    <testcase classname="jest-each done callback calls [ &apos;test&apos; ] with done when cb function has more args than params of given test row" name="jest-each done callback calls [ &apos;test&apos; ] with done when cb function has more args than params of given test row" time="0.001">
    </testcase>
    <testcase classname="jest-each done callback calls [ &apos;test&apos;, &apos;only&apos; ] with done when cb function has more args than params of given test row" name="jest-each done callback calls [ &apos;test&apos;, &apos;only&apos; ] with done when cb function has more args than params of given test row" time="0">
    </testcase>
    <testcase classname="jest-each done callback calls [ &apos;it&apos; ] with done when cb function has more args than params of given test row" name="jest-each done callback calls [ &apos;it&apos; ] with done when cb function has more args than params of given test row" time="0">
    </testcase>
    <testcase classname="jest-each done callback calls [ &apos;fit&apos; ] with done when cb function has more args than params of given test row" name="jest-each done callback calls [ &apos;fit&apos; ] with done when cb function has more args than params of given test row" time="0.001">
    </testcase>
    <testcase classname="jest-each done callback calls [ &apos;it&apos;, &apos;only&apos; ] with done when cb function has more args than params of given test row" name="jest-each done callback calls [ &apos;it&apos;, &apos;only&apos; ] with done when cb function has more args than params of given test row" time="0">
    </testcase>
    <testcase classname="jest-each done callback does not call [ &apos;describe&apos; ] with done when test function has more args than params of given test row" name="jest-each done callback does not call [ &apos;describe&apos; ] with done when test function has more args than params of given test row" time="0.001">
    </testcase>
    <testcase classname="jest-each done callback does not call [ &apos;fdescribe&apos; ] with done when test function has more args than params of given test row" name="jest-each done callback does not call [ &apos;fdescribe&apos; ] with done when test function has more args than params of given test row" time="0.001">
    </testcase>
    <testcase classname="jest-each done callback does not call [ &apos;describe&apos;, &apos;only&apos; ] with done when test function has more args than params of given test row" name="jest-each done callback does not call [ &apos;describe&apos;, &apos;only&apos; ] with done when test function has more args than params of given test row" time="0.006">
    </testcase>
    <testcase classname="jest-each .xtest calls global with given title" name="jest-each .xtest calls global with given title" time="0.001">
    </testcase>
    <testcase classname="jest-each .xtest calls global with given title when multiple tests cases exist" name="jest-each .xtest calls global with given title when multiple tests cases exist" time="0.001">
    </testcase>
    <testcase classname="jest-each .xtest calls global with title containing param values when using $variable format" name="jest-each .xtest calls global with title containing param values when using $variable format" time="0.001">
    </testcase>
    <testcase classname="jest-each .test.skip calls global with given title" name="jest-each .test.skip calls global with given title" time="0.001">
    </testcase>
    <testcase classname="jest-each .test.skip calls global with given title when multiple tests cases exist" name="jest-each .test.skip calls global with given title when multiple tests cases exist" time="0.001">
    </testcase>
    <testcase classname="jest-each .test.skip calls global with title containing param values when using $variable format" name="jest-each .test.skip calls global with title containing param values when using $variable format" time="0.001">
    </testcase>
    <testcase classname="jest-each .xit calls global with given title" name="jest-each .xit calls global with given title" time="0.001">
    </testcase>
    <testcase classname="jest-each .xit calls global with given title when multiple tests cases exist" name="jest-each .xit calls global with given title when multiple tests cases exist" time="0">
    </testcase>
    <testcase classname="jest-each .xit calls global with title containing param values when using $variable format" name="jest-each .xit calls global with title containing param values when using $variable format" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.skip calls global with given title" name="jest-each .it.skip calls global with given title" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.skip calls global with given title when multiple tests cases exist" name="jest-each .it.skip calls global with given title when multiple tests cases exist" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.skip calls global with title containing param values when using $variable format" name="jest-each .it.skip calls global with title containing param values when using $variable format" time="0.001">
    </testcase>
    <testcase classname="jest-each .xdescribe calls global with given title" name="jest-each .xdescribe calls global with given title" time="0.001">
    </testcase>
    <testcase classname="jest-each .xdescribe calls global with given title when multiple tests cases exist" name="jest-each .xdescribe calls global with given title when multiple tests cases exist" time="0">
    </testcase>
    <testcase classname="jest-each .xdescribe calls global with title containing param values when using $variable format" name="jest-each .xdescribe calls global with title containing param values when using $variable format" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.skip calls global with given title" name="jest-each .describe.skip calls global with given title" time="0">
    </testcase>
    <testcase classname="jest-each .describe.skip calls global with given title when multiple tests cases exist" name="jest-each .describe.skip calls global with given title when multiple tests cases exist" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.skip calls global with title containing param values when using $variable format" name="jest-each .describe.skip calls global with title containing param values when using $variable format" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="jest-each" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:00:04" time="0.582" tests="114">
    <testcase classname="jest-each .test throws an error when not called with an array" name="jest-each .test throws an error when not called with an array" time="0.002">
    </testcase>
    <testcase classname="jest-each .test throws an error when called with an empty array" name="jest-each .test throws an error when called with an empty array" time="0.002">
    </testcase>
    <testcase classname="jest-each .test calls global with given title" name="jest-each .test calls global with given title" time="0.003">
    </testcase>
    <testcase classname="jest-each .test calls global with given title when multiple tests cases exist" name="jest-each .test calls global with given title when multiple tests cases exist" time="0.003">
    </testcase>
    <testcase classname="jest-each .test calls global with title containing param values when using printf format" name="jest-each .test calls global with title containing param values when using printf format" time="0.001">
    </testcase>
    <testcase classname="jest-each .test does not call global test with title containing more param values than sprintf placeholders" name="jest-each .test does not call global test with title containing more param values than sprintf placeholders" time="0.003">
    </testcase>
    <testcase classname="jest-each .test calls global test title with %p placeholder injected at the correct positions" name="jest-each .test calls global test title with %p placeholder injected at the correct positions" time="0.015">
    </testcase>
    <testcase classname="jest-each .test does not calls global test title with %p placeholder when no data is supplied at given position" name="jest-each .test does not calls global test title with %p placeholder when no data is supplied at given position" time="0.004">
    </testcase>
    <testcase classname="jest-each .test calls global with cb function containing all parameters of each test case when given 1d array" name="jest-each .test calls global with cb function containing all parameters of each test case when given 1d array" time="0.002">
    </testcase>
    <testcase classname="jest-each .test calls global with cb function containing all parameters of each test case 2d array" name="jest-each .test calls global with cb function containing all parameters of each test case 2d array" time="0.005">
    </testcase>
    <testcase classname="jest-each .test calls global with given timeout" name="jest-each .test calls global with given timeout" time="0.002">
    </testcase>
    <testcase classname="jest-each .test.only throws an error when not called with an array" name="jest-each .test.only throws an error when not called with an array" time="0.002">
    </testcase>
    <testcase classname="jest-each .test.only throws an error when called with an empty array" name="jest-each .test.only throws an error when called with an empty array" time="0.001">
    </testcase>
    <testcase classname="jest-each .test.only calls global with given title" name="jest-each .test.only calls global with given title" time="0.003">
    </testcase>
    <testcase classname="jest-each .test.only calls global with given title when multiple tests cases exist" name="jest-each .test.only calls global with given title when multiple tests cases exist" time="0.004">
    </testcase>
    <testcase classname="jest-each .test.only calls global with title containing param values when using printf format" name="jest-each .test.only calls global with title containing param values when using printf format" time="0.002">
    </testcase>
    <testcase classname="jest-each .test.only does not call global test with title containing more param values than sprintf placeholders" name="jest-each .test.only does not call global test with title containing more param values than sprintf placeholders" time="0.002">
    </testcase>
    <testcase classname="jest-each .test.only calls global test title with %p placeholder injected at the correct positions" name="jest-each .test.only calls global test title with %p placeholder injected at the correct positions" time="0.002">
    </testcase>
    <testcase classname="jest-each .test.only does not calls global test title with %p placeholder when no data is supplied at given position" name="jest-each .test.only does not calls global test title with %p placeholder when no data is supplied at given position" time="0.003">
    </testcase>
    <testcase classname="jest-each .test.only calls global with cb function containing all parameters of each test case when given 1d array" name="jest-each .test.only calls global with cb function containing all parameters of each test case when given 1d array" time="0.007">
    </testcase>
    <testcase classname="jest-each .test.only calls global with cb function containing all parameters of each test case 2d array" name="jest-each .test.only calls global with cb function containing all parameters of each test case 2d array" time="0.008">
    </testcase>
    <testcase classname="jest-each .test.only calls global with given timeout" name="jest-each .test.only calls global with given timeout" time="0.003">
    </testcase>
    <testcase classname="jest-each .it throws an error when not called with an array" name="jest-each .it throws an error when not called with an array" time="0.003">
    </testcase>
    <testcase classname="jest-each .it throws an error when called with an empty array" name="jest-each .it throws an error when called with an empty array" time="0.004">
    </testcase>
    <testcase classname="jest-each .it calls global with given title" name="jest-each .it calls global with given title" time="0.036">
    </testcase>
    <testcase classname="jest-each .it calls global with given title when multiple tests cases exist" name="jest-each .it calls global with given title when multiple tests cases exist" time="0.002">
    </testcase>
    <testcase classname="jest-each .it calls global with title containing param values when using printf format" name="jest-each .it calls global with title containing param values when using printf format" time="0.001">
    </testcase>
    <testcase classname="jest-each .it does not call global test with title containing more param values than sprintf placeholders" name="jest-each .it does not call global test with title containing more param values than sprintf placeholders" time="0.001">
    </testcase>
    <testcase classname="jest-each .it calls global test title with %p placeholder injected at the correct positions" name="jest-each .it calls global test title with %p placeholder injected at the correct positions" time="0.002">
    </testcase>
    <testcase classname="jest-each .it does not calls global test title with %p placeholder when no data is supplied at given position" name="jest-each .it does not calls global test title with %p placeholder when no data is supplied at given position" time="0.001">
    </testcase>
    <testcase classname="jest-each .it calls global with cb function containing all parameters of each test case when given 1d array" name="jest-each .it calls global with cb function containing all parameters of each test case when given 1d array" time="0.001">
    </testcase>
    <testcase classname="jest-each .it calls global with cb function containing all parameters of each test case 2d array" name="jest-each .it calls global with cb function containing all parameters of each test case 2d array" time="0.001">
    </testcase>
    <testcase classname="jest-each .it calls global with given timeout" name="jest-each .it calls global with given timeout" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit throws an error when not called with an array" name="jest-each .fit throws an error when not called with an array" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit throws an error when called with an empty array" name="jest-each .fit throws an error when called with an empty array" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit calls global with given title" name="jest-each .fit calls global with given title" time="0">
    </testcase>
    <testcase classname="jest-each .fit calls global with given title when multiple tests cases exist" name="jest-each .fit calls global with given title when multiple tests cases exist" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit calls global with title containing param values when using printf format" name="jest-each .fit calls global with title containing param values when using printf format" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit does not call global test with title containing more param values than sprintf placeholders" name="jest-each .fit does not call global test with title containing more param values than sprintf placeholders" time="0.002">
    </testcase>
    <testcase classname="jest-each .fit calls global test title with %p placeholder injected at the correct positions" name="jest-each .fit calls global test title with %p placeholder injected at the correct positions" time="0.002">
    </testcase>
    <testcase classname="jest-each .fit does not calls global test title with %p placeholder when no data is supplied at given position" name="jest-each .fit does not calls global test title with %p placeholder when no data is supplied at given position" time="0.006">
    </testcase>
    <testcase classname="jest-each .fit calls global with cb function containing all parameters of each test case when given 1d array" name="jest-each .fit calls global with cb function containing all parameters of each test case when given 1d array" time="0.002">
    </testcase>
    <testcase classname="jest-each .fit calls global with cb function containing all parameters of each test case 2d array" name="jest-each .fit calls global with cb function containing all parameters of each test case 2d array" time="0.001">
    </testcase>
    <testcase classname="jest-each .fit calls global with given timeout" name="jest-each .fit calls global with given timeout" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.only throws an error when not called with an array" name="jest-each .it.only throws an error when not called with an array" time="0.002">
    </testcase>
    <testcase classname="jest-each .it.only throws an error when called with an empty array" name="jest-each .it.only throws an error when called with an empty array" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.only calls global with given title" name="jest-each .it.only calls global with given title" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.only calls global with given title when multiple tests cases exist" name="jest-each .it.only calls global with given title when multiple tests cases exist" time="0.004">
    </testcase>
    <testcase classname="jest-each .it.only calls global with title containing param values when using printf format" name="jest-each .it.only calls global with title containing param values when using printf format" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.only does not call global test with title containing more param values than sprintf placeholders" name="jest-each .it.only does not call global test with title containing more param values than sprintf placeholders" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.only calls global test title with %p placeholder injected at the correct positions" name="jest-each .it.only calls global test title with %p placeholder injected at the correct positions" time="0.002">
    </testcase>
    <testcase classname="jest-each .it.only does not calls global test title with %p placeholder when no data is supplied at given position" name="jest-each .it.only does not calls global test title with %p placeholder when no data is supplied at given position" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.only calls global with cb function containing all parameters of each test case when given 1d array" name="jest-each .it.only calls global with cb function containing all parameters of each test case when given 1d array" time="0.003">
    </testcase>
    <testcase classname="jest-each .it.only calls global with cb function containing all parameters of each test case 2d array" name="jest-each .it.only calls global with cb function containing all parameters of each test case 2d array" time="0.007">
    </testcase>
    <testcase classname="jest-each .it.only calls global with given timeout" name="jest-each .it.only calls global with given timeout" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe throws an error when not called with an array" name="jest-each .describe throws an error when not called with an array" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe throws an error when called with an empty array" name="jest-each .describe throws an error when called with an empty array" time="0.002">
    </testcase>
    <testcase classname="jest-each .describe calls global with given title" name="jest-each .describe calls global with given title" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe calls global with given title when multiple tests cases exist" name="jest-each .describe calls global with given title when multiple tests cases exist" time="0.004">
    </testcase>
    <testcase classname="jest-each .describe calls global with title containing param values when using printf format" name="jest-each .describe calls global with title containing param values when using printf format" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe does not call global test with title containing more param values than sprintf placeholders" name="jest-each .describe does not call global test with title containing more param values than sprintf placeholders" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe calls global test title with %p placeholder injected at the correct positions" name="jest-each .describe calls global test title with %p placeholder injected at the correct positions" time="0.011">
    </testcase>
    <testcase classname="jest-each .describe does not calls global test title with %p placeholder when no data is supplied at given position" name="jest-each .describe does not calls global test title with %p placeholder when no data is supplied at given position" time="0.002">
    </testcase>
    <testcase classname="jest-each .describe calls global with cb function containing all parameters of each test case when given 1d array" name="jest-each .describe calls global with cb function containing all parameters of each test case when given 1d array" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe calls global with cb function containing all parameters of each test case 2d array" name="jest-each .describe calls global with cb function containing all parameters of each test case 2d array" time="0.002">
    </testcase>
    <testcase classname="jest-each .describe calls global with given timeout" name="jest-each .describe calls global with given timeout" time="0.001">
    </testcase>
    <testcase classname="jest-each .fdescribe throws an error when not called with an array" name="jest-each .fdescribe throws an error when not called with an array" time="0.001">
    </testcase>
    <testcase classname="jest-each .fdescribe throws an error when called with an empty array" name="jest-each .fdescribe throws an error when called with an empty array" time="0">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global with given title" name="jest-each .fdescribe calls global with given title" time="0.001">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global with given title when multiple tests cases exist" name="jest-each .fdescribe calls global with given title when multiple tests cases exist" time="0.001">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global with title containing param values when using printf format" name="jest-each .fdescribe calls global with title containing param values when using printf format" time="0">
    </testcase>
    <testcase classname="jest-each .fdescribe does not call global test with title containing more param values than sprintf placeholders" name="jest-each .fdescribe does not call global test with title containing more param values than sprintf placeholders" time="0.001">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global test title with %p placeholder injected at the correct positions" name="jest-each .fdescribe calls global test title with %p placeholder injected at the correct positions" time="0.001">
    </testcase>
    <testcase classname="jest-each .fdescribe does not calls global test title with %p placeholder when no data is supplied at given position" name="jest-each .fdescribe does not calls global test title with %p placeholder when no data is supplied at given position" time="0.001">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global with cb function containing all parameters of each test case when given 1d array" name="jest-each .fdescribe calls global with cb function containing all parameters of each test case when given 1d array" time="0">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global with cb function containing all parameters of each test case 2d array" name="jest-each .fdescribe calls global with cb function containing all parameters of each test case 2d array" time="0.001">
    </testcase>
    <testcase classname="jest-each .fdescribe calls global with given timeout" name="jest-each .fdescribe calls global with given timeout" time="0">
    </testcase>
    <testcase classname="jest-each .describe.only throws an error when not called with an array" name="jest-each .describe.only throws an error when not called with an array" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only throws an error when called with an empty array" name="jest-each .describe.only throws an error when called with an empty array" time="0">
    </testcase>
    <testcase classname="jest-each .describe.only calls global with given title" name="jest-each .describe.only calls global with given title" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only calls global with given title when multiple tests cases exist" name="jest-each .describe.only calls global with given title when multiple tests cases exist" time="0">
    </testcase>
    <testcase classname="jest-each .describe.only calls global with title containing param values when using printf format" name="jest-each .describe.only calls global with title containing param values when using printf format" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only does not call global test with title containing more param values than sprintf placeholders" name="jest-each .describe.only does not call global test with title containing more param values than sprintf placeholders" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only calls global test title with %p placeholder injected at the correct positions" name="jest-each .describe.only calls global test title with %p placeholder injected at the correct positions" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only does not calls global test title with %p placeholder when no data is supplied at given position" name="jest-each .describe.only does not calls global test title with %p placeholder when no data is supplied at given position" time="0.002">
    </testcase>
    <testcase classname="jest-each .describe.only calls global with cb function containing all parameters of each test case when given 1d array" name="jest-each .describe.only calls global with cb function containing all parameters of each test case when given 1d array" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only calls global with cb function containing all parameters of each test case 2d array" name="jest-each .describe.only calls global with cb function containing all parameters of each test case 2d array" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.only calls global with given timeout" name="jest-each .describe.only calls global with given timeout" time="0.001">
    </testcase>
    <testcase classname="jest-each done callback calls [ &apos;test&apos; ] with done when cb function has more args than params of given test row" name="jest-each done callback calls [ &apos;test&apos; ] with done when cb function has more args than params of given test row" time="0.001">
    </testcase>
    <testcase classname="jest-each done callback calls [ &apos;test&apos;, &apos;only&apos; ] with done when cb function has more args than params of given test row" name="jest-each done callback calls [ &apos;test&apos;, &apos;only&apos; ] with done when cb function has more args than params of given test row" time="0.001">
    </testcase>
    <testcase classname="jest-each done callback calls [ &apos;it&apos; ] with done when cb function has more args than params of given test row" name="jest-each done callback calls [ &apos;it&apos; ] with done when cb function has more args than params of given test row" time="0">
    </testcase>
    <testcase classname="jest-each done callback calls [ &apos;fit&apos; ] with done when cb function has more args than params of given test row" name="jest-each done callback calls [ &apos;fit&apos; ] with done when cb function has more args than params of given test row" time="0.001">
    </testcase>
    <testcase classname="jest-each done callback calls [ &apos;it&apos;, &apos;only&apos; ] with done when cb function has more args than params of given test row" name="jest-each done callback calls [ &apos;it&apos;, &apos;only&apos; ] with done when cb function has more args than params of given test row" time="0">
    </testcase>
    <testcase classname="jest-each done callback does not call [ &apos;describe&apos; ] with done when test function has more args than params of given test row" name="jest-each done callback does not call [ &apos;describe&apos; ] with done when test function has more args than params of given test row" time="0.001">
    </testcase>
    <testcase classname="jest-each done callback does not call [ &apos;fdescribe&apos; ] with done when test function has more args than params of given test row" name="jest-each done callback does not call [ &apos;fdescribe&apos; ] with done when test function has more args than params of given test row" time="0.001">
    </testcase>
    <testcase classname="jest-each done callback does not call [ &apos;describe&apos;, &apos;only&apos; ] with done when test function has more args than params of given test row" name="jest-each done callback does not call [ &apos;describe&apos;, &apos;only&apos; ] with done when test function has more args than params of given test row" time="0.001">
    </testcase>
    <testcase classname="jest-each .xtest calls global with given title" name="jest-each .xtest calls global with given title" time="0">
    </testcase>
    <testcase classname="jest-each .xtest calls global with given title when multiple tests cases exist" name="jest-each .xtest calls global with given title when multiple tests cases exist" time="0.001">
    </testcase>
    <testcase classname="jest-each .xtest calls global with title containing param values when using sprintf format" name="jest-each .xtest calls global with title containing param values when using sprintf format" time="0">
    </testcase>
    <testcase classname="jest-each .test.skip calls global with given title" name="jest-each .test.skip calls global with given title" time="0.001">
    </testcase>
    <testcase classname="jest-each .test.skip calls global with given title when multiple tests cases exist" name="jest-each .test.skip calls global with given title when multiple tests cases exist" time="0">
    </testcase>
    <testcase classname="jest-each .test.skip calls global with title containing param values when using sprintf format" name="jest-each .test.skip calls global with title containing param values when using sprintf format" time="0.001">
    </testcase>
    <testcase classname="jest-each .xit calls global with given title" name="jest-each .xit calls global with given title" time="0">
    </testcase>
    <testcase classname="jest-each .xit calls global with given title when multiple tests cases exist" name="jest-each .xit calls global with given title when multiple tests cases exist" time="0.001">
    </testcase>
    <testcase classname="jest-each .xit calls global with title containing param values when using sprintf format" name="jest-each .xit calls global with title containing param values when using sprintf format" time="0">
    </testcase>
    <testcase classname="jest-each .it.skip calls global with given title" name="jest-each .it.skip calls global with given title" time="0">
    </testcase>
    <testcase classname="jest-each .it.skip calls global with given title when multiple tests cases exist" name="jest-each .it.skip calls global with given title when multiple tests cases exist" time="0.001">
    </testcase>
    <testcase classname="jest-each .it.skip calls global with title containing param values when using sprintf format" name="jest-each .it.skip calls global with title containing param values when using sprintf format" time="0.001">
    </testcase>
    <testcase classname="jest-each .xdescribe calls global with given title" name="jest-each .xdescribe calls global with given title" time="0.001">
    </testcase>
    <testcase classname="jest-each .xdescribe calls global with given title when multiple tests cases exist" name="jest-each .xdescribe calls global with given title when multiple tests cases exist" time="0">
    </testcase>
    <testcase classname="jest-each .xdescribe calls global with title containing param values when using sprintf format" name="jest-each .xdescribe calls global with title containing param values when using sprintf format" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.skip calls global with given title" name="jest-each .describe.skip calls global with given title" time="0">
    </testcase>
    <testcase classname="jest-each .describe.skip calls global with given title when multiple tests cases exist" name="jest-each .describe.skip calls global with given title when multiple tests cases exist" time="0.001">
    </testcase>
    <testcase classname="jest-each .describe.skip calls global with title containing param values when using sprintf format" name="jest-each .describe.skip calls global with title containing param values when using sprintf format" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="docblock" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:00:05" time="0.337" tests="36">
    <testcase classname="docblock extracts valid docblock with line comment" name="docblock extracts valid docblock with line comment" time="0.002">
    </testcase>
    <testcase classname="docblock extracts valid docblock" name="docblock extracts valid docblock" time="0.001">
    </testcase>
    <testcase classname="docblock extracts valid docblock with more comments" name="docblock extracts valid docblock with more comments" time="0.001">
    </testcase>
    <testcase classname="docblock extracts from invalid docblock" name="docblock extracts from invalid docblock" time="0">
    </testcase>
    <testcase classname="docblock returns extract and parsedocblock" name="docblock returns extract and parsedocblock" time="0.003">
    </testcase>
    <testcase classname="docblock parses directives out of a docblock" name="docblock parses directives out of a docblock" time="0.001">
    </testcase>
    <testcase classname="docblock parses multiple of the same directives out of a docblock" name="docblock parses multiple of the same directives out of a docblock" time="0.001">
    </testcase>
    <testcase classname="docblock parses &gt;=3 of the same directives out of a docblock" name="docblock parses &gt;=3 of the same directives out of a docblock" time="0">
    </testcase>
    <testcase classname="docblock parses directives out of a docblock with comments" name="docblock parses directives out of a docblock with comments" time="0.001">
    </testcase>
    <testcase classname="docblock parses directives out of a docblock with line comments" name="docblock parses directives out of a docblock with line comments" time="0.001">
    </testcase>
    <testcase classname="docblock parses multiline directives" name="docblock parses multiline directives" time="0.001">
    </testcase>
    <testcase classname="docblock parses multiline directives even if there are linecomments within the docblock" name="docblock parses multiline directives even if there are linecomments within the docblock" time="0">
    </testcase>
    <testcase classname="docblock supports slashes in @team directive" name="docblock supports slashes in @team directive" time="0.001">
    </testcase>
    <testcase classname="docblock extracts comments from docblock" name="docblock extracts comments from docblock" time="0.001">
    </testcase>
    <testcase classname="docblock extracts multiline comments from docblock" name="docblock extracts multiline comments from docblock" time="0">
    </testcase>
    <testcase classname="docblock preserves leading whitespace in multiline comments from docblock" name="docblock preserves leading whitespace in multiline comments from docblock" time="0">
    </testcase>
    <testcase classname="docblock removes leading newlines in multiline comments from docblock" name="docblock removes leading newlines in multiline comments from docblock" time="0.001">
    </testcase>
    <testcase classname="docblock extracts comments from beginning and end of docblock" name="docblock extracts comments from beginning and end of docblock" time="0">
    </testcase>
    <testcase classname="docblock preserve urls within a pragma&apos;s values" name="docblock preserve urls within a pragma&apos;s values" time="0">
    </testcase>
    <testcase classname="docblock strip linecomments from pragmas but preserve for comments" name="docblock strip linecomments from pragmas but preserve for comments" time="0">
    </testcase>
    <testcase classname="docblock extracts docblock comments as CRLF when docblock contains CRLF" name="docblock extracts docblock comments as CRLF when docblock contains CRLF" time="0.001">
    </testcase>
    <testcase classname="docblock extracts docblock comments as LF when docblock contains LF" name="docblock extracts docblock comments as LF when docblock contains LF" time="0">
    </testcase>
    <testcase classname="docblock strips the docblock out of a file that contains a top docblock" name="docblock strips the docblock out of a file that contains a top docblock" time="0">
    </testcase>
    <testcase classname="docblock returns a file unchanged if there is no top docblock to strip" name="docblock returns a file unchanged if there is no top docblock to strip" time="0.001">
    </testcase>
    <testcase classname="docblock prints docblocks with no pragmas as empty string" name="docblock prints docblocks with no pragmas as empty string" time="0">
    </testcase>
    <testcase classname="docblock prints docblocks with one pragma on one line" name="docblock prints docblocks with one pragma on one line" time="0.001">
    </testcase>
    <testcase classname="docblock prints docblocks with multiple pragmas on multiple lines" name="docblock prints docblocks with multiple pragmas on multiple lines" time="0">
    </testcase>
    <testcase classname="docblock prints docblocks with multiple of the same pragma" name="docblock prints docblocks with multiple of the same pragma" time="0.008">
    </testcase>
    <testcase classname="docblock prints docblocks with pragmas" name="docblock prints docblocks with pragmas" time="0.001">
    </testcase>
    <testcase classname="docblock prints docblocks with comments" name="docblock prints docblocks with comments" time="0.001">
    </testcase>
    <testcase classname="docblock prints docblocks with comments and no keys" name="docblock prints docblocks with comments and no keys" time="0">
    </testcase>
    <testcase classname="docblock prints docblocks with multiline comments" name="docblock prints docblocks with multiline comments" time="0.001">
    </testcase>
    <testcase classname="docblock prints docblocks that are parseable" name="docblock prints docblocks that are parseable" time="0">
    </testcase>
    <testcase classname="docblock can augment existing docblocks with comments" name="docblock can augment existing docblocks with comments" time="0.001">
    </testcase>
    <testcase classname="docblock prints docblocks using CRLF if comments contains CRLF" name="docblock prints docblocks using CRLF if comments contains CRLF" time="0">
    </testcase>
    <testcase classname="docblock prints docblocks using LF if comments contains LF" name="docblock prints docblocks using LF if comments contains LF" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="9" timestamp="2018-12-19T21:00:05" time="0.816" tests="10">
    <testcase classname=" does not work on Windows" name=" does not work on Windows" time="0.011">
    </testcase>
    <testcase classname=" gets hg SCM roots and dedups them" name=" gets hg SCM roots and dedups them" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" gets git SCM roots and dedups them" name=" gets git SCM roots and dedups them" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" gets mixed git and hg SCM roots and dedups them" name=" gets mixed git and hg SCM roots and dedups them" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" gets changed files for git" name=" gets changed files for git" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" monitors only root paths for git" name=" monitors only root paths for git" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" handles a bad revision for &quot;changedSince&quot;, for git" name=" handles a bad revision for &quot;changedSince&quot;, for git" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" gets changed files for hg" name=" gets changed files for hg" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" monitors only root paths for hg" name=" monitors only root paths for hg" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" handles a bad revision for &quot;changedSince&quot;, for hg" name=" handles a bad revision for &quot;changedSince&quot;, for hg" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:00:06" time="94.809" tests="8">
    <testcase classname=" --listTests doesnt duplicate the test files" name=" --listTests doesnt duplicate the test files" time="5.784">
    </testcase>
    <testcase classname=" can pass projects or global config" name=" can pass projects or global config" time="32.837">
    </testcase>
    <testcase classname=" &quot;No tests found&quot; message for projects" name=" &quot;No tests found&quot; message for projects" time="6.064">
    </testcase>
    <testcase classname=" projects can be workspaces with non-JS/JSON files" name=" projects can be workspaces with non-JS/JSON files" time="12.694">
    </testcase>
    <testcase classname=" objects in project configuration" name=" objects in project configuration" time="8.412">
    </testcase>
    <testcase classname=" allows a single project" name=" allows a single project" time="5.827">
    </testcase>
    <testcase classname=" resolves projects and their &lt;rootDir&gt; properly" name=" resolves projects and their &lt;rootDir&gt; properly" time="14.859">
    </testcase>
    <testcase classname=" Does transform files with the corresponding project transformer" name=" Does transform files with the corresponding project transformer" time="8.039">
    </testcase>
  </testsuite>
  <testsuite name="groupTestsBySuites" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:01:41" time="0.529" tests="11">
    <testcase classname="groupTestsBySuites should handle empty results" name="groupTestsBySuites should handle empty results" time="0.236">
    </testcase>
    <testcase classname="groupTestsBySuites should group A1 in A" name="groupTestsBySuites should group A1 in A" time="0.004">
    </testcase>
    <testcase classname="groupTestsBySuites should group A1 in A; B1 in B" name="groupTestsBySuites should group A1 in A; B1 in B" time="0.001">
    </testcase>
    <testcase classname="groupTestsBySuites should group A1, A2 in A" name="groupTestsBySuites should group A1, A2 in A" time="0.001">
    </testcase>
    <testcase classname="groupTestsBySuites should group A1, A2 in A; B1, B2 in B" name="groupTestsBySuites should group A1, A2 in A; B1, B2 in B" time="0.002">
    </testcase>
    <testcase classname="groupTestsBySuites should group AB1 in AB" name="groupTestsBySuites should group AB1 in AB" time="0.001">
    </testcase>
    <testcase classname="groupTestsBySuites should group AB1, AB2 in AB" name="groupTestsBySuites should group AB1, AB2 in AB" time="0.002">
    </testcase>
    <testcase classname="groupTestsBySuites should group A1 in A; AB1 in AB" name="groupTestsBySuites should group A1 in A; AB1 in AB" time="0.001">
    </testcase>
    <testcase classname="groupTestsBySuites should group AB1 in AB; A1 in A" name="groupTestsBySuites should group AB1 in AB; A1 in A" time="0.001">
    </testcase>
    <testcase classname="groupTestsBySuites should group AB1 in AB; CD1 in CD" name="groupTestsBySuites should group AB1 in AB; CD1 in CD" time="0.002">
    </testcase>
    <testcase classname="groupTestsBySuites should group ABC1 in ABC; BC1 in BC; D1 in D; A1 in A" name="groupTestsBySuites should group ABC1 in ABC; BC1 in BC; D1 in D; A1 in A" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="SnapshotInteractiveMode" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:01:42" time="0.291" tests="13">
    <testcase classname="SnapshotInteractiveMode is inactive at construction" name="SnapshotInteractiveMode is inactive at construction" time="0.002">
    </testcase>
    <testcase classname="SnapshotInteractiveMode call to run process the first file" name="SnapshotInteractiveMode call to run process the first file" time="0.002">
    </testcase>
    <testcase classname="SnapshotInteractiveMode call to abort" name="SnapshotInteractiveMode call to abort" time="0.002">
    </testcase>
    <testcase classname="SnapshotInteractiveMode call to reset" name="SnapshotInteractiveMode call to reset" time="0.003">
    </testcase>
    <testcase classname="SnapshotInteractiveMode press Q or ESC triggers an abort" name="SnapshotInteractiveMode press Q or ESC triggers an abort" time="0.001">
    </testcase>
    <testcase classname="SnapshotInteractiveMode press ENTER trigger a run" name="SnapshotInteractiveMode press ENTER trigger a run" time="0.003">
    </testcase>
    <testcase classname="SnapshotInteractiveMode skip 1 test, then restart" name="SnapshotInteractiveMode skip 1 test, then restart" time="0.006">
    </testcase>
    <testcase classname="SnapshotInteractiveMode skip 1 test, then quit" name="SnapshotInteractiveMode skip 1 test, then quit" time="0.005">
    </testcase>
    <testcase classname="SnapshotInteractiveMode update 1 test, then finish and return" name="SnapshotInteractiveMode update 1 test, then finish and return" time="0.005">
    </testcase>
    <testcase classname="SnapshotInteractiveMode skip 2 tests, then finish and restart" name="SnapshotInteractiveMode skip 2 tests, then finish and restart" time="0.009">
    </testcase>
    <testcase classname="SnapshotInteractiveMode update 2 tests, then finish and return" name="SnapshotInteractiveMode update 2 tests, then finish and return" time="0.005">
    </testcase>
    <testcase classname="SnapshotInteractiveMode update 1 test, skip 1 test, then finish and restart" name="SnapshotInteractiveMode update 1 test, skip 1 test, then finish and restart" time="0.005">
    </testcase>
    <testcase classname="SnapshotInteractiveMode skip 1 test, update 1 test, then finish and restart" name="SnapshotInteractiveMode skip 1 test, update 1 test, then finish and restart" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="onRunComplete" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:01:42" time="1.156" tests="11">
    <testcase classname="onRunComplete getLastError() returns an error when threshold is not met for global" name="onRunComplete getLastError() returns an error when threshold is not met for global" time="0.83">
    </testcase>
    <testcase classname="onRunComplete getLastError() returns an error when threshold is not met for file" name="onRunComplete getLastError() returns an error when threshold is not met for file" time="0.007">
    </testcase>
    <testcase classname="onRunComplete getLastError() returns `undefined` when threshold is met" name="onRunComplete getLastError() returns `undefined` when threshold is met" time="0.002">
    </testcase>
    <testcase classname="onRunComplete getLastError() returns an error when threshold is not met for non-covered file" name="onRunComplete getLastError() returns an error when threshold is not met for non-covered file" time="0.002">
    </testcase>
    <testcase classname="onRunComplete getLastError() returns an error when threshold is not met for directory" name="onRunComplete getLastError() returns an error when threshold is not met for directory" time="0.001">
    </testcase>
    <testcase classname="onRunComplete getLastError() returns `undefined` when threshold is met for directory" name="onRunComplete getLastError() returns `undefined` when threshold is met for directory" time="0.002">
    </testcase>
    <testcase classname="onRunComplete getLastError() returns an error when there is no coverage data for a threshold" name="onRunComplete getLastError() returns an error when there is no coverage data for a threshold" time="0.001">
    </testcase>
    <testcase classname="onRunComplete getLastError() returns &apos;undefined&apos; when global threshold group
   is empty because PATH and GLOB threshold groups have matched all the
    files in the coverage data." name="onRunComplete getLastError() returns &apos;undefined&apos; when global threshold group
   is empty because PATH and GLOB threshold groups have matched all the
    files in the coverage data." time="0.001">
    </testcase>
    <testcase classname="onRunComplete getLastError() returns &apos;undefined&apos; when file and directory path 
  threshold groups overlap" name="onRunComplete getLastError() returns &apos;undefined&apos; when file and directory path 
  threshold groups overlap" time="0.003">
    </testcase>
    <testcase classname="onRunComplete that if globs or paths are specified alongside global, coverage 
  data for matching paths will be subtracted from overall coverage 
  and thresholds will be applied independently" name="onRunComplete that if globs or paths are specified alongside global, coverage 
  data for matching paths will be subtracted from overall coverage 
  and thresholds will be applied independently" time="0.004">
    </testcase>
    <testcase classname="onRunComplete that files are matched by all matching threshold groups" name="onRunComplete that files are matched by all matching threshold groups" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="Snapshot" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:01:43" time="85.602" tests="9">
    <testcase classname="Snapshot stores new snapshots on the first run" name="Snapshot stores new snapshots on the first run" time="4.255">
    </testcase>
    <testcase classname="Snapshot works with escaped characters" name="Snapshot works with escaped characters" time="13.221">
    </testcase>
    <testcase classname="Snapshot works with escaped regex" name="Snapshot works with escaped regex" time="7.539">
    </testcase>
    <testcase classname="Snapshot works with template literal substitutions" name="Snapshot works with template literal substitutions" time="7.512">
    </testcase>
    <testcase classname="Snapshot Validation does not save snapshots in CI mode by default" name="Snapshot Validation does not save snapshots in CI mode by default" time="6.484">
    </testcase>
    <testcase classname="Snapshot Validation works on subsequent runs without `-u`" name="Snapshot Validation works on subsequent runs without `-u`" time="14.32">
    </testcase>
    <testcase classname="Snapshot Validation deletes the snapshot if the test suite has been removed" name="Snapshot Validation deletes the snapshot if the test suite has been removed" time="12.076">
    </testcase>
    <testcase classname="Snapshot Validation deletes a snapshot when a test does removes all the snapshots" name="Snapshot Validation deletes a snapshot when a test does removes all the snapshots" time="11.737">
    </testcase>
    <testcase classname="Snapshot Validation updates the snapshot when a test removes some snapshots" name="Snapshot Validation updates the snapshot when a test removes some snapshots" time="8.164">
    </testcase>
  </testsuite>
  <testsuite name="Runtime requireModule" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:03:09" time="7.325" tests="25">
    <testcase classname="Runtime requireModule finds haste modules" name="Runtime requireModule finds haste modules" time="3.63">
    </testcase>
    <testcase classname="Runtime requireModule provides `module` to modules" name="Runtime requireModule provides `module` to modules" time="0.08">
    </testcase>
    <testcase classname="Runtime requireModule provides `module.parent` to modules" name="Runtime requireModule provides `module.parent` to modules" time="0.13">
    </testcase>
    <testcase classname="Runtime requireModule `module.parent` should be undefined for entrypoints" name="Runtime requireModule `module.parent` should be undefined for entrypoints" time="0.055">
    </testcase>
    <testcase classname="Runtime requireModule resolve module.parent.require correctly" name="Runtime requireModule resolve module.parent.require correctly" time="0.11">
    </testcase>
    <testcase classname="Runtime requireModule resolve module.parent.filename correctly" name="Runtime requireModule resolve module.parent.filename correctly" time="0.053">
    </testcase>
    <testcase classname="Runtime requireModule provides `module.loaded` to modules" name="Runtime requireModule provides `module.loaded` to modules" time="0.077">
    </testcase>
    <testcase classname="Runtime requireModule provides `module.filename` to modules" name="Runtime requireModule provides `module.filename` to modules" time="0.054">
    </testcase>
    <testcase classname="Runtime requireModule provides `module.paths` to modules" name="Runtime requireModule provides `module.paths` to modules" time="0.111">
    </testcase>
    <testcase classname="Runtime requireModule provides `require.main` to modules" name="Runtime requireModule provides `require.main` to modules" time="0.161">
    </testcase>
    <testcase classname="Runtime requireModule throws on non-existent haste modules" name="Runtime requireModule throws on non-existent haste modules" time="0.034">
    </testcase>
    <testcase classname="Runtime requireModule finds relative-path modules without file extension" name="Runtime requireModule finds relative-path modules without file extension" time="0.036">
    </testcase>
    <testcase classname="Runtime requireModule finds relative-path modules with file extension" name="Runtime requireModule finds relative-path modules with file extension" time="0.037">
    </testcase>
    <testcase classname="Runtime requireModule throws on non-existent relative-path modules" name="Runtime requireModule throws on non-existent relative-path modules" time="0.032">
    </testcase>
    <testcase classname="Runtime requireModule finds node core built-in modules" name="Runtime requireModule finds node core built-in modules" time="0.042">
    </testcase>
    <testcase classname="Runtime requireModule finds and loads JSON files without file extension" name="Runtime requireModule finds and loads JSON files without file extension" time="0.036">
    </testcase>
    <testcase classname="Runtime requireModule finds and loads JSON files with file extension" name="Runtime requireModule finds and loads JSON files with file extension" time="0.032">
    </testcase>
    <testcase classname="Runtime requireModule requires a JSON file twice successfully" name="Runtime requireModule requires a JSON file twice successfully" time="0.04">
    </testcase>
    <testcase classname="Runtime requireModule provides manual mock when real module doesnt exist" name="Runtime requireModule provides manual mock when real module doesnt exist" time="0.084">
    </testcase>
    <testcase classname="Runtime requireModule doesn&apos;t override real modules with manual mocks when explicitly unmocked" name="Runtime requireModule doesn&apos;t override real modules with manual mocks when explicitly unmocked" time="0.462">
    </testcase>
    <testcase classname="Runtime requireModule resolves haste packages properly" name="Runtime requireModule resolves haste packages properly" time="0.096">
    </testcase>
    <testcase classname="Runtime requireModule resolves node modules properly when crawling node_modules" name="Runtime requireModule resolves node modules properly when crawling node_modules" time="0.113">
    </testcase>
    <testcase classname="Runtime requireModule resolves platform extensions based on the default platform" name="Runtime requireModule resolves platform extensions based on the default platform" time="0.472">
    </testcase>
    <testcase classname="Runtime requireModule finds modules encoded in UTF-8 *with BOM*" name="Runtime requireModule finds modules encoded in UTF-8 *with BOM*" time="0.089">
    </testcase>
    <testcase classname="Runtime requireModule finds and loads JSON files encoded in UTF-8 *with BOM*" name="Runtime requireModule finds and loads JSON files encoded in UTF-8 *with BOM*" time="0.025">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:03:16" time="98.307" tests="9">
    <testcase classname=" basic support" name=" basic support" time="14.658">
    </testcase>
    <testcase classname=" error thrown before snapshot" name=" error thrown before snapshot" time="11.243">
    </testcase>
    <testcase classname=" first snapshot fails, second passes" name=" first snapshot fails, second passes" time="8.214">
    </testcase>
    <testcase classname=" does not mark snapshots as obsolete in skipped tests" name=" does not mark snapshots as obsolete in skipped tests" time="7.895">
    </testcase>
    <testcase classname=" accepts custom snapshot name" name=" accepts custom snapshot name" time="4.145">
    </testcase>
    <testcase classname=" handles property matchers" name=" handles property matchers" time="11.533">
    </testcase>
    <testcase classname=" handles invalid property matchers" name=" handles invalid property matchers" time="12.362">
    </testcase>
    <testcase classname=" handles property matchers with custom name" name=" handles property matchers with custom name" time="11.798">
    </testcase>
    <testcase classname=" handles property matchers with deep properties" name=" handles property matchers with deep properties" time="16.166">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="1" skipped="0" timestamp="2018-12-19T21:04:54" time="120.363" tests="6">
    <testcase classname=" run for &quot;onlyChanged&quot; and &quot;changedSince&quot;" name=" run for &quot;onlyChanged&quot; and &quot;changedSince&quot;" time="6.795">
    </testcase>
    <testcase classname=" run only changed files" name=" run only changed files" time="39.409">
    </testcase>
    <testcase classname=" report test coverage for only changed files" name=" report test coverage for only changed files" time="13.259">
    </testcase>
    <testcase classname=" onlyChanged in config is overwritten by --all or testPathPattern" name=" onlyChanged in config is overwritten by --all or testPathPattern" time="47.059">
    </testcase>
    <testcase classname=" gets changed files for hg" name=" gets changed files for hg" time="0.186">
      <failure>Error: 
      ORIGINAL CMD: hg --config ui.username=jest_test init
      STDOUT: 
      STDERR: &apos;hg&apos; is not recognized as an internal or external command,
operable program or batch file.

      STATUS: 1
      ERROR: undefined
    
    at Object.&lt;anonymous&gt;.exports.run (C:\Users\kangan\Source\Repos\jest\e2e\Utils.js:36:11)
    at Object.&lt;anonymous&gt; (C:\Users\kangan\Source\Repos\jest\e2e\__tests__\only_changed.test.js:224:3)
    at Generator.next (&lt;anonymous&gt;)
    at step (C:\Users\kangan\Source\Repos\jest\e2e\__tests__\only_changed.test.js:28:191)
    at C:\Users\kangan\Source\Repos\jest\e2e\__tests__\only_changed.test.js:28:437
    at new Promise (&lt;anonymous&gt;)
    at Object.&lt;anonymous&gt; (C:\Users\kangan\Source\Repos\jest\e2e\__tests__\only_changed.test.js:28:99)
    at Object.asyncJestTest (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\jasmineAsyncInstall.js:121:37)
    at resolve (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\queueRunner.js:54:12)
    at new Promise (&lt;anonymous&gt;)</failure>
    </testcase>
    <testcase classname=" path on Windows is case-insensitive" name=" path on Windows is case-insensitive" time="12.992">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:06:55" time="0.88" tests="10">
    <testcase classname=" lazily requires the file" name=" lazily requires the file" time="0.08">
    </testcase>
    <testcase classname=" calls initialize with the correct arguments" name=" calls initialize with the correct arguments" time="0.004">
    </testcase>
    <testcase classname=" returns results immediately when function is synchronous" name=" returns results immediately when function is synchronous" time="0.038">
    </testcase>
    <testcase classname=" returns results when it gets resolved if function is asynchronous" name=" returns results when it gets resolved if function is asynchronous" time="0.044">
    </testcase>
    <testcase classname=" calls the main module if the method call is &quot;default&quot;" name=" calls the main module if the method call is &quot;default&quot;" time="0.002">
    </testcase>
    <testcase classname=" calls the main export if the method call is &quot;default&quot; and it is a Babel transpiled one" name=" calls the main export if the method call is &quot;default&quot; and it is a Babel transpiled one" time="0.002">
    </testcase>
    <testcase classname=" finishes the process with exit code 0 if requested" name=" finishes the process with exit code 0 if requested" time="0.003">
    </testcase>
    <testcase classname=" calls the teardown method " name=" calls the teardown method " time="0.002">
    </testcase>
    <testcase classname=" throws if an invalid message is detected" name=" throws if an invalid message is detected" time="0.002">
    </testcase>
    <testcase classname=" throws if child is not forked" name=" throws if child is not forked" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:06:56" time="0.52" tests="10">
    <testcase classname=" lazily requires the file" name=" lazily requires the file" time="0.091">
    </testcase>
    <testcase classname=" calls initialize with the correct arguments" name=" calls initialize with the correct arguments" time="0.001">
    </testcase>
    <testcase classname=" returns results immediately when function is synchronous" name=" returns results immediately when function is synchronous" time="0.022">
    </testcase>
    <testcase classname=" returns results when it gets resolved if function is asynchronous" name=" returns results when it gets resolved if function is asynchronous" time="0.024">
    </testcase>
    <testcase classname=" calls the main module if the method call is &quot;default&quot;" name=" calls the main module if the method call is &quot;default&quot;" time="0.001">
    </testcase>
    <testcase classname=" calls the main export if the method call is &quot;default&quot; and it is a Babel transpiled one" name=" calls the main export if the method call is &quot;default&quot; and it is a Babel transpiled one" time="0.001">
    </testcase>
    <testcase classname=" finishes the process with exit code 0 if requested" name=" finishes the process with exit code 0 if requested" time="0.001">
    </testcase>
    <testcase classname=" calls the teardown method " name=" calls the teardown method " time="0.001">
    </testcase>
    <testcase classname=" throws if an invalid message is detected" name=" throws if an invalid message is detected" time="0.001">
    </testcase>
    <testcase classname=" throws if child is not forked" name=" throws if child is not forked" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:06:56" time="0.351" tests="32">
    <testcase classname=" Any.asymmetricMatch()" name=" Any.asymmetricMatch()" time="0.004">
    </testcase>
    <testcase classname=" Any.toAsymmetricMatcher()" name=" Any.toAsymmetricMatcher()" time="0.001">
    </testcase>
    <testcase classname=" Any throws when called with empty constructor" name=" Any throws when called with empty constructor" time="0.001">
    </testcase>
    <testcase classname=" Anything matches any type" name=" Anything matches any type" time="0.002">
    </testcase>
    <testcase classname=" Anything does not match null and undefined" name=" Anything does not match null and undefined" time="0">
    </testcase>
    <testcase classname=" Anything.toAsymmetricMatcher()" name=" Anything.toAsymmetricMatcher()" time="0">
    </testcase>
    <testcase classname=" ArrayContaining matches" name=" ArrayContaining matches" time="0.001">
    </testcase>
    <testcase classname=" ArrayContaining does not match" name=" ArrayContaining does not match" time="0.001">
    </testcase>
    <testcase classname=" ArrayContaining throws for non-arrays" name=" ArrayContaining throws for non-arrays" time="0.001">
    </testcase>
    <testcase classname=" ArrayNotContaining matches" name=" ArrayNotContaining matches" time="0">
    </testcase>
    <testcase classname=" ArrayNotContaining does not match" name=" ArrayNotContaining does not match" time="0.001">
    </testcase>
    <testcase classname=" ArrayNotContaining throws for non-arrays" name=" ArrayNotContaining throws for non-arrays" time="0">
    </testcase>
    <testcase classname=" ObjectContaining matches" name=" ObjectContaining matches" time="0.002">
    </testcase>
    <testcase classname=" ObjectContaining does not match" name=" ObjectContaining does not match" time="0.001">
    </testcase>
    <testcase classname=" ObjectContaining matches defined properties" name=" ObjectContaining matches defined properties" time="0.001">
    </testcase>
    <testcase classname=" ObjectContaining matches prototype properties" name=" ObjectContaining matches prototype properties" time="0">
    </testcase>
    <testcase classname=" ObjectContaining throws for non-objects" name=" ObjectContaining throws for non-objects" time="0.001">
    </testcase>
    <testcase classname=" ObjectNotContaining matches" name=" ObjectNotContaining matches" time="0.001">
    </testcase>
    <testcase classname=" ObjectNotContaining does not match" name=" ObjectNotContaining does not match" time="0.001">
    </testcase>
    <testcase classname=" ObjectNotContaining throws for non-objects" name=" ObjectNotContaining throws for non-objects" time="0">
    </testcase>
    <testcase classname=" StringContaining matches string against string" name=" StringContaining matches string against string" time="0.001">
    </testcase>
    <testcase classname=" StringContaining throws for non-strings" name=" StringContaining throws for non-strings" time="0">
    </testcase>
    <testcase classname=" StringNotContaining matches string against string" name=" StringNotContaining matches string against string" time="0">
    </testcase>
    <testcase classname=" StringNotContaining throws for non-strings" name=" StringNotContaining throws for non-strings" time="0.001">
    </testcase>
    <testcase classname=" StringMatching matches string against regexp" name=" StringMatching matches string against regexp" time="0">
    </testcase>
    <testcase classname=" StringMatching matches string against string" name=" StringMatching matches string against string" time="0">
    </testcase>
    <testcase classname=" StringMatching throws for non-strings and non-regexps" name=" StringMatching throws for non-strings and non-regexps" time="0.001">
    </testcase>
    <testcase classname=" StringMatching throws for non-string actual values" name=" StringMatching throws for non-string actual values" time="0">
    </testcase>
    <testcase classname=" StringNotMatching matches string against regexp" name=" StringNotMatching matches string against regexp" time="0">
    </testcase>
    <testcase classname=" StringNotMatching matches string against string" name=" StringNotMatching matches string against string" time="0.001">
    </testcase>
    <testcase classname=" StringNotMatching throws for non-strings and non-regexps" name=" StringNotMatching throws for non-strings and non-regexps" time="0">
    </testcase>
    <testcase classname=" StringNotMatching throws for non-string actual values" name=" StringNotMatching throws for non-string actual values" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="isCoreModule" errors="0" failures="1" skipped="0" timestamp="2018-12-19T21:06:57" time="0.954" tests="13">
    <testcase classname="isCoreModule returns false if `hasCoreModules` is false." name="isCoreModule returns false if `hasCoreModules` is false." time="0.005">
    </testcase>
    <testcase classname="isCoreModule returns true if `hasCoreModules` is true and `moduleName` is a core module." name="isCoreModule returns true if `hasCoreModules` is true and `moduleName` is a core module." time="0.003">
    </testcase>
    <testcase classname="isCoreModule returns false if `hasCoreModules` is true and `moduleName` is not a core module." name="isCoreModule returns false if `hasCoreModules` is true and `moduleName` is not a core module." time="0.002">
    </testcase>
    <testcase classname="findNodeModule is possible to override the default resolver" name="findNodeModule is possible to override the default resolver" time="0.011">
    </testcase>
    <testcase classname="resolveModule is possible to resolve node modules" name="resolveModule is possible to resolve node modules" time="0.013">
    </testcase>
    <testcase classname="resolveModule is possible to resolve node modules with custom extensions" name="resolveModule is possible to resolve node modules with custom extensions" time="0.009">
    </testcase>
    <testcase classname="resolveModule is possible to resolve node modules with custom extensions and platforms" name="resolveModule is possible to resolve node modules with custom extensions and platforms" time="0.009">
    </testcase>
    <testcase classname="resolveModule is possible to resolve node modules by resolving their realpath" name="resolveModule is possible to resolve node modules by resolving their realpath" time="0.051">
      <failure>Error: Cannot find module &apos;dep&apos; from &apos;index.js&apos;
    at Resolver.resolveModule (C:\Users\kangan\Source\Repos\jest\packages\jest-resolve\src\index.js:213:17)
    at Object.resolveModule (C:\Users\kangan\Source\Repos\jest\packages\jest-resolve\src\__tests__\resolve.test.js:137:31)
    at Object.asyncJestTest (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\jasmineAsyncInstall.js:121:37)
    at resolve (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\queueRunner.js:54:12)
    at new Promise (&lt;anonymous&gt;)
    at mapper (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\queueRunner.js:41:19)
    at promise.then (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\queueRunner.js:86:41)</failure>
    </testcase>
    <testcase classname="resolveModule is possible to specify custom resolve paths" name="resolveModule is possible to specify custom resolve paths" time="0.005">
    </testcase>
    <testcase classname="getMockModule is possible to use custom resolver to resolve deps inside mock modules with moduleNameMapper" name="getMockModule is possible to use custom resolver to resolve deps inside mock modules with moduleNameMapper" time="0.002">
    </testcase>
    <testcase classname="nodeModulesPaths provides custom module paths after node_modules" name="nodeModulesPaths provides custom module paths after node_modules" time="0.002">
    </testcase>
    <testcase classname="Resolver.getModulePaths() -&gt; nodeModulesPaths() can resolve node modules relative to absolute paths in &quot;moduleDirectories&quot; on Windows platforms" name="Resolver.getModulePaths() -&gt; nodeModulesPaths() can resolve node modules relative to absolute paths in &quot;moduleDirectories&quot; on Windows platforms" time="0.014">
    </testcase>
    <testcase classname="Resolver.getModulePaths() -&gt; nodeModulesPaths() can resolve node modules relative to absolute paths in &quot;moduleDirectories&quot; on Posix platforms" name="Resolver.getModulePaths() -&gt; nodeModulesPaths() can resolve node modules relative to absolute paths in &quot;moduleDirectories&quot; on Posix platforms" time="0.009">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:06:58" time="0.334" tests="38">
    <testcase classname=" supports any(String)" name=" supports any(String)" time="0.002">
    </testcase>
    <testcase classname=" supports nested any(String)" name=" supports nested any(String)" time="0">
    </testcase>
    <testcase classname=" supports any(Function)" name=" supports any(Function)" time="0.001">
    </testcase>
    <testcase classname=" supports nested any(Function)" name=" supports nested any(Function)" time="0">
    </testcase>
    <testcase classname=" supports any(Array)" name=" supports any(Array)" time="0.001">
    </testcase>
    <testcase classname=" supports nested any(Array)" name=" supports nested any(Array)" time="0">
    </testcase>
    <testcase classname=" supports any(Object)" name=" supports any(Object)" time="0">
    </testcase>
    <testcase classname=" supports nested any(Object)" name=" supports nested any(Object)" time="0.001">
    </testcase>
    <testcase classname=" supports any(RegExp)" name=" supports any(RegExp)" time="0">
    </testcase>
    <testcase classname=" supports nested any(RegExp)" name=" supports nested any(RegExp)" time="0">
    </testcase>
    <testcase classname=" supports any(Symbol)" name=" supports any(Symbol)" time="0.001">
    </testcase>
    <testcase classname=" supports nested any(Symbol)" name=" supports nested any(Symbol)" time="0">
    </testcase>
    <testcase classname=" supports any(Function)" name=" supports any(Function)" time="0">
    </testcase>
    <testcase classname=" supports nested any(Function)" name=" supports nested any(Function)" time="0.001">
    </testcase>
    <testcase classname=" supports any(&lt;anonymous&gt;)" name=" supports any(&lt;anonymous&gt;)" time="0">
    </testcase>
    <testcase classname=" supports nested any(&lt;anonymous&gt;)" name=" supports nested any(&lt;anonymous&gt;)" time="0">
    </testcase>
    <testcase classname=" supports any(namedFuntction)" name=" supports any(namedFuntction)" time="0">
    </testcase>
    <testcase classname=" supports nested any(namedFuntction)" name=" supports nested any(namedFuntction)" time="0">
    </testcase>
    <testcase classname=" anything()" name=" anything()" time="0">
    </testcase>
    <testcase classname=" arrayContaining()" name=" arrayContaining()" time="0.019">
    </testcase>
    <testcase classname=" arrayNotContaining()" name=" arrayNotContaining()" time="0.001">
    </testcase>
    <testcase classname=" objectContaining()" name=" objectContaining()" time="0.003">
    </testcase>
    <testcase classname=" objectNotContaining()" name=" objectNotContaining()" time="0">
    </testcase>
    <testcase classname=" stringContaining(string)" name=" stringContaining(string)" time="0.001">
    </testcase>
    <testcase classname=" not.stringContaining(string)" name=" not.stringContaining(string)" time="0.001">
    </testcase>
    <testcase classname=" stringMatching(string)" name=" stringMatching(string)" time="0">
    </testcase>
    <testcase classname=" stringMatching(regexp)" name=" stringMatching(regexp)" time="0.001">
    </testcase>
    <testcase classname=" stringMatching(regexp) {escapeRegex: false}" name=" stringMatching(regexp) {escapeRegex: false}" time="0">
    </testcase>
    <testcase classname=" stringMatching(regexp) {escapeRegex: true}" name=" stringMatching(regexp) {escapeRegex: true}" time="0.002">
    </testcase>
    <testcase classname=" stringNotMatching(string)" name=" stringNotMatching(string)" time="0">
    </testcase>
    <testcase classname=" supports multiple nested asymmetric matchers" name=" supports multiple nested asymmetric matchers" time="0.001">
    </testcase>
    <testcase classname="indent option default implicit: 2 spaces" name="indent option default implicit: 2 spaces" time="0.001">
    </testcase>
    <testcase classname="indent option default explicit: 2 spaces" name="indent option default explicit: 2 spaces" time="0.001">
    </testcase>
    <testcase classname="indent option non-default: 0 spaces" name="indent option non-default: 0 spaces" time="0.001">
    </testcase>
    <testcase classname="indent option non-default: 4 spaces" name="indent option non-default: 4 spaces" time="0.001">
    </testcase>
    <testcase classname="maxDepth option matchers as leaf nodes" name="maxDepth option matchers as leaf nodes" time="0.001">
    </testcase>
    <testcase classname="maxDepth option matchers as internal nodes" name="maxDepth option matchers as internal nodes" time="0.001">
    </testcase>
    <testcase classname=" min option" name=" min option" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:06:58" time="86.71" tests="7">
    <testcase classname=" basic support" name=" basic support" time="22.049">
    </testcase>
    <testcase classname=" handles property matchers" name=" handles property matchers" time="28.64">
    </testcase>
    <testcase classname=" removes obsolete external snapshots" name=" removes obsolete external snapshots" time="14.712">
    </testcase>
    <testcase classname=" supports async matchers" name=" supports async matchers" time="5.15">
    </testcase>
    <testcase classname=" supports async tests" name=" supports async tests" time="5.214">
    </testcase>
    <testcase classname=" writes snapshots with non-literals in expect(...)" name=" writes snapshots with non-literals in expect(...)" time="5.115">
    </testcase>
    <testcase classname=" handles mocking native modules prettier relies on" name=" handles mocking native modules prettier relies on" time="5.381">
    </testcase>
  </testsuite>
  <testsuite name="Farm" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:08:25" time="0.482" tests="8">
    <testcase classname="Farm sends a request to one worker" name="Farm sends a request to one worker" time="0.005">
    </testcase>
    <testcase classname="Farm sends four requests to four unique workers" name="Farm sends four requests to four unique workers" time="0.003">
    </testcase>
    <testcase classname="Farm handles null computeWorkerKey, sending to first worker" name="Farm handles null computeWorkerKey, sending to first worker" time="0.003">
    </testcase>
    <testcase classname="Farm sends the same worker key to the same worker" name="Farm sends the same worker key to the same worker" time="0.003">
    </testcase>
    <testcase classname="Farm returns the result if the call worked" name="Farm returns the result if the call worked" time="0.001">
    </testcase>
    <testcase classname="Farm throws if the call failed" name="Farm throws if the call failed" time="0.002">
    </testcase>
    <testcase classname="Farm checks that once a sticked task finishes, next time is sent to that worker" name="Farm checks that once a sticked task finishes, next time is sent to that worker" time="0.001">
    </testcase>
    <testcase classname="Farm checks that even before a sticked task finishes, next time is sent to that worker" name="Farm checks that even before a sticked task finishes, next time is sent to that worker" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="dependencyExtractor" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:08:25" time="0.315" tests="15">
    <testcase classname="dependencyExtractor should not extract dependencies inside comments" name="dependencyExtractor should not extract dependencies inside comments" time="0.007">
    </testcase>
    <testcase classname="dependencyExtractor should not extract dependencies inside comments (windows line endings)" name="dependencyExtractor should not extract dependencies inside comments (windows line endings)" time="0.006">
    </testcase>
    <testcase classname="dependencyExtractor should not extract dependencies inside comments (unicode line endings)" name="dependencyExtractor should not extract dependencies inside comments (unicode line endings)" time="0.003">
    </testcase>
    <testcase classname="dependencyExtractor should extract dependencies from `import` statements" name="dependencyExtractor should extract dependencies from `import` statements" time="0.005">
    </testcase>
    <testcase classname="dependencyExtractor should not extract dependencies from `import type/typeof` statements" name="dependencyExtractor should not extract dependencies from `import type/typeof` statements" time="0.002">
    </testcase>
    <testcase classname="dependencyExtractor should extract dependencies from `export` statements" name="dependencyExtractor should extract dependencies from `export` statements" time="0.001">
    </testcase>
    <testcase classname="dependencyExtractor should extract dependencies from `export-from` statements" name="dependencyExtractor should extract dependencies from `export-from` statements" time="0.004">
    </testcase>
    <testcase classname="dependencyExtractor should not extract dependencies from `export type/typeof` statements" name="dependencyExtractor should not extract dependencies from `export type/typeof` statements" time="0.002">
    </testcase>
    <testcase classname="dependencyExtractor should extract dependencies from dynamic `import` calls" name="dependencyExtractor should extract dependencies from dynamic `import` calls" time="0.003">
    </testcase>
    <testcase classname="dependencyExtractor should extract dependencies from `require` calls" name="dependencyExtractor should extract dependencies from `require` calls" time="0.002">
    </testcase>
    <testcase classname="dependencyExtractor should extract dependencies from `require.requireActual` calls" name="dependencyExtractor should extract dependencies from `require.requireActual` calls" time="0.003">
    </testcase>
    <testcase classname="dependencyExtractor should extract dependencies from `require.requireMock` calls" name="dependencyExtractor should extract dependencies from `require.requireMock` calls" time="0.003">
    </testcase>
    <testcase classname="dependencyExtractor should extract dependencies from `jest.requireActual` calls" name="dependencyExtractor should extract dependencies from `jest.requireActual` calls" time="0.002">
    </testcase>
    <testcase classname="dependencyExtractor should extract dependencies from `jest.requireMock` calls" name="dependencyExtractor should extract dependencies from `jest.requireMock` calls" time="0.002">
    </testcase>
    <testcase classname="dependencyExtractor should extract dependencies from `jest.genMockFromModule` calls" name="dependencyExtractor should extract dependencies from `jest.genMockFromModule` calls" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name=".toThrowError()" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:08:26" time="0.585" tests="40">
    <testcase classname=".toThrowError() to throw or not to throw" name=".toThrowError() to throw or not to throw" time="0.002">
    </testcase>
    <testcase classname=".toThrowError() strings passes" name=".toThrowError() strings passes" time="0.001">
    </testcase>
    <testcase classname=".toThrowError() strings did not throw at all" name=".toThrowError() strings did not throw at all" time="0.004">
    </testcase>
    <testcase classname=".toThrowError() strings threw, but message did not match" name=".toThrowError() strings threw, but message did not match" time="0.033">
    </testcase>
    <testcase classname=".toThrowError() strings properly escapes strings when matching against errors" name=".toThrowError() strings properly escapes strings when matching against errors" time="0">
    </testcase>
    <testcase classname=".toThrowError() strings threw, but should not have" name=".toThrowError() strings threw, but should not have" time="0.002">
    </testcase>
    <testcase classname=".toThrowError() regexp passes" name=".toThrowError() regexp passes" time="0.001">
    </testcase>
    <testcase classname=".toThrowError() regexp did not throw at all" name=".toThrowError() regexp did not throw at all" time="0.001">
    </testcase>
    <testcase classname=".toThrowError() regexp threw, but message did not match" name=".toThrowError() regexp threw, but message did not match" time="0.007">
    </testcase>
    <testcase classname=".toThrowError() regexp threw, but should not have" name=".toThrowError() regexp threw, but should not have" time="0.002">
    </testcase>
    <testcase classname=".toThrowError() error class passes" name=".toThrowError() error class passes" time="0.001">
    </testcase>
    <testcase classname=".toThrowError() error class did not throw at all" name=".toThrowError() error class did not throw at all" time="0.001">
    </testcase>
    <testcase classname=".toThrowError() error class threw, but class did not match" name=".toThrowError() error class threw, but class did not match" time="0.001">
    </testcase>
    <testcase classname=".toThrowError() error class threw, but should not have" name=".toThrowError() error class threw, but should not have" time="0.002">
    </testcase>
    <testcase classname=".toThrowError() promise/async throws if Error-like object is returned passes" name=".toThrowError() promise/async throws if Error-like object is returned passes" time="0.004">
    </testcase>
    <testcase classname=".toThrowError() promise/async throws if Error-like object is returned did not throw at all" name=".toThrowError() promise/async throws if Error-like object is returned did not throw at all" time="0.002">
    </testcase>
    <testcase classname=".toThrowError() promise/async throws if Error-like object is returned threw, but class did not match" name=".toThrowError() promise/async throws if Error-like object is returned threw, but class did not match" time="0.002">
    </testcase>
    <testcase classname=".toThrowError() promise/async throws if Error-like object is returned threw, but should not have" name=".toThrowError() promise/async throws if Error-like object is returned threw, but should not have" time="0.001">
    </testcase>
    <testcase classname=".toThrowError() invalid arguments" name=".toThrowError() invalid arguments" time="0.001">
    </testcase>
    <testcase classname=".toThrowError() invalid actual" name=".toThrowError() invalid actual" time="0.001">
    </testcase>
    <testcase classname=".toThrow() to throw or not to throw" name=".toThrow() to throw or not to throw" time="0">
    </testcase>
    <testcase classname=".toThrow() strings passes" name=".toThrow() strings passes" time="0">
    </testcase>
    <testcase classname=".toThrow() strings did not throw at all" name=".toThrow() strings did not throw at all" time="0.001">
    </testcase>
    <testcase classname=".toThrow() strings threw, but message did not match" name=".toThrow() strings threw, but message did not match" time="0.001">
    </testcase>
    <testcase classname=".toThrow() strings properly escapes strings when matching against errors" name=".toThrow() strings properly escapes strings when matching against errors" time="0">
    </testcase>
    <testcase classname=".toThrow() strings threw, but should not have" name=".toThrow() strings threw, but should not have" time="0.001">
    </testcase>
    <testcase classname=".toThrow() regexp passes" name=".toThrow() regexp passes" time="0.001">
    </testcase>
    <testcase classname=".toThrow() regexp did not throw at all" name=".toThrow() regexp did not throw at all" time="0.001">
    </testcase>
    <testcase classname=".toThrow() regexp threw, but message did not match" name=".toThrow() regexp threw, but message did not match" time="0.001">
    </testcase>
    <testcase classname=".toThrow() regexp threw, but should not have" name=".toThrow() regexp threw, but should not have" time="0.001">
    </testcase>
    <testcase classname=".toThrow() error class passes" name=".toThrow() error class passes" time="0.001">
    </testcase>
    <testcase classname=".toThrow() error class did not throw at all" name=".toThrow() error class did not throw at all" time="0.002">
    </testcase>
    <testcase classname=".toThrow() error class threw, but class did not match" name=".toThrow() error class threw, but class did not match" time="0.001">
    </testcase>
    <testcase classname=".toThrow() error class threw, but should not have" name=".toThrow() error class threw, but should not have" time="0.001">
    </testcase>
    <testcase classname=".toThrow() promise/async throws if Error-like object is returned passes" name=".toThrow() promise/async throws if Error-like object is returned passes" time="0.004">
    </testcase>
    <testcase classname=".toThrow() promise/async throws if Error-like object is returned did not throw at all" name=".toThrow() promise/async throws if Error-like object is returned did not throw at all" time="0">
    </testcase>
    <testcase classname=".toThrow() promise/async throws if Error-like object is returned threw, but class did not match" name=".toThrow() promise/async throws if Error-like object is returned threw, but class did not match" time="0.001">
    </testcase>
    <testcase classname=".toThrow() promise/async throws if Error-like object is returned threw, but should not have" name=".toThrow() promise/async throws if Error-like object is returned threw, but should not have" time="0">
    </testcase>
    <testcase classname=".toThrow() invalid arguments" name=".toThrow() invalid arguments" time="0.001">
    </testcase>
    <testcase classname=".toThrow() invalid actual" name=".toThrow() invalid actual" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:08:26" time="0.437" tests="11">
    <testcase classname=" passes fork options down to child_process.fork, adding the defaults" name=" passes fork options down to child_process.fork, adding the defaults" time="0.11">
    </testcase>
    <testcase classname=" passes workerId to the child process and assign it to env.JEST_WORKER_ID" name=" passes workerId to the child process and assign it to env.JEST_WORKER_ID" time="0.002">
    </testcase>
    <testcase classname=" initializes the child process with the given workerPath" name=" initializes the child process with the given workerPath" time="0.001">
    </testcase>
    <testcase classname=" stops initializing the worker after the amount of retries is exceeded" name=" stops initializing the worker after the amount of retries is exceeded" time="0.023">
    </testcase>
    <testcase classname=" provides stdout and stderr fields from the child process" name=" provides stdout and stderr fields from the child process" time="0.001">
    </testcase>
    <testcase classname=" sends the task to the child process" name=" sends the task to the child process" time="0.002">
    </testcase>
    <testcase classname=" calls the onProcessStart method synchronously if the queue is empty" name=" calls the onProcessStart method synchronously if the queue is empty" time="0.002">
    </testcase>
    <testcase classname=" creates error instances for known errors" name=" creates error instances for known errors" time="0.003">
    </testcase>
    <testcase classname=" throws when the child process returns a strange message" name=" throws when the child process returns a strange message" time="0.002">
    </testcase>
    <testcase classname=" does not restart the child if it cleanly exited" name=" does not restart the child if it cleanly exited" time="0.003">
    </testcase>
    <testcase classname=" restarts the child when the child process dies" name=" restarts the child when the child process dies" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="init" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:08:27" time="0.802" tests="14">
    <testcase classname="init project with package.json and no jest config all questions answered with answer: &quot;No&quot; should return the default configuration (an empty config)" name="init project with package.json and no jest config all questions answered with answer: &quot;No&quot; should return the default configuration (an empty config)" time="0.079">
    </testcase>
    <testcase classname="init project with package.json and no jest config some questions answered with answer: &quot;Yes&quot; should create configuration for {clearMocks: true}" name="init project with package.json and no jest config some questions answered with answer: &quot;Yes&quot; should create configuration for {clearMocks: true}" time="0.002">
    </testcase>
    <testcase classname="init project with package.json and no jest config some questions answered with answer: &quot;Yes&quot; should create configuration for {coverage: true}" name="init project with package.json and no jest config some questions answered with answer: &quot;Yes&quot; should create configuration for {coverage: true}" time="0.002">
    </testcase>
    <testcase classname="init project with package.json and no jest config some questions answered with answer: &quot;Yes&quot; should create configuration for {environment: &quot;jsdom&quot;}" name="init project with package.json and no jest config some questions answered with answer: &quot;Yes&quot; should create configuration for {environment: &quot;jsdom&quot;}" time="0.002">
    </testcase>
    <testcase classname="init project with package.json and no jest config some questions answered with answer: &quot;Yes&quot; should create configuration for {environment: &quot;node&quot;}" name="init project with package.json and no jest config some questions answered with answer: &quot;Yes&quot; should create configuration for {environment: &quot;node&quot;}" time="0.003">
    </testcase>
    <testcase classname="init project with package.json and no jest config some questions answered with answer: &quot;Yes&quot; should create package.json with configured test command when {scripts: true}" name="init project with package.json and no jest config some questions answered with answer: &quot;Yes&quot; should create package.json with configured test command when {scripts: true}" time="0.002">
    </testcase>
    <testcase classname="init no package json should throw an error if there is no package.json file" name="init no package json should throw an error if there is no package.json file" time="0.002">
    </testcase>
    <testcase classname="init has-jest-config-file ask the user whether to override config or not user answered with &quot;Yes&quot;" name="init has-jest-config-file ask the user whether to override config or not user answered with &quot;Yes&quot;" time="0.003">
    </testcase>
    <testcase classname="init has-jest-config-file ask the user whether to override config or not user answered with &quot;No&quot;" name="init has-jest-config-file ask the user whether to override config or not user answered with &quot;No&quot;" time="0.001">
    </testcase>
    <testcase classname="init has jest config in package.json should ask the user whether to override config or not" name="init has jest config in package.json should ask the user whether to override config or not" time="0.003">
    </testcase>
    <testcase classname="init already has &quot;jest&quot; in packageJson.scripts.test should not ask &quot;test script question&quot;" name="init already has &quot;jest&quot; in packageJson.scripts.test should not ask &quot;test script question&quot;" time="0.002">
    </testcase>
    <testcase classname="init typescript project should ask &quot;typescript question&quot; when has typescript in dependencies" name="init typescript project should ask &quot;typescript question&quot; when has typescript in dependencies" time="0.002">
    </testcase>
    <testcase classname="init typescript project should ask &quot;typescript question&quot; when has typescript in devDependencies" name="init typescript project should ask &quot;typescript question&quot; when has typescript in devDependencies" time="0.002">
    </testcase>
    <testcase classname="init typescript project should create configuration for {typescript: true}" name="init typescript project should create configuration for {typescript: true}" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:08:28" time="0.399" tests="11">
    <testcase classname=" passes fork options down to child_process.fork, adding the defaults" name=" passes fork options down to child_process.fork, adding the defaults" time="0.099">
    </testcase>
    <testcase classname=" passes workerId to the child process and assign it to env.JEST_WORKER_ID" name=" passes workerId to the child process and assign it to env.JEST_WORKER_ID" time="0.004">
    </testcase>
    <testcase classname=" initializes the child process with the given workerPath" name=" initializes the child process with the given workerPath" time="0.002">
    </testcase>
    <testcase classname=" stops initializing the worker after the amount of retries is exceeded" name=" stops initializing the worker after the amount of retries is exceeded" time="0.025">
    </testcase>
    <testcase classname=" provides stdout and stderr fields from the child process" name=" provides stdout and stderr fields from the child process" time="0.006">
    </testcase>
    <testcase classname=" sends the task to the child process" name=" sends the task to the child process" time="0.005">
    </testcase>
    <testcase classname=" calls the onProcessStart method synchronously if the queue is empty" name=" calls the onProcessStart method synchronously if the queue is empty" time="0.004">
    </testcase>
    <testcase classname=" creates error instances for known errors" name=" creates error instances for known errors" time="0.008">
    </testcase>
    <testcase classname=" throws when the child process returns a strange message" name=" throws when the child process returns a strange message" time="0.005">
    </testcase>
    <testcase classname=" does not restart the child if it cleanly exited" name=" does not restart the child if it cleanly exited" time="0.003">
    </testcase>
    <testcase classname=" restarts the child when the child process dies" name=" restarts the child when the child process dies" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:08:28" time="0.61" tests="13">
    <testcase classname=" keyToTestName()" name=" keyToTestName()" time="0.007">
    </testcase>
    <testcase classname=" testNameToKey" name=" testNameToKey" time="0.001">
    </testcase>
    <testcase classname=" saveSnapshotFile() works with 
" name=" saveSnapshotFile() works with 
" time="0.002">
    </testcase>
    <testcase classname=" saveSnapshotFile() works with " name=" saveSnapshotFile() works with " time="0.001">
    </testcase>
    <testcase classname=" getSnapshotData() throws when no snapshot version" name=" getSnapshotData() throws when no snapshot version" time="0.002">
    </testcase>
    <testcase classname=" getSnapshotData() throws for older snapshot version" name=" getSnapshotData() throws for older snapshot version" time="0.001">
    </testcase>
    <testcase classname=" getSnapshotData() throws for newer snapshot version" name=" getSnapshotData() throws for newer snapshot version" time="0.001">
    </testcase>
    <testcase classname=" getSnapshotData() does not throw for when updating" name=" getSnapshotData() does not throw for when updating" time="0.001">
    </testcase>
    <testcase classname=" getSnapshotData() marks invalid snapshot dirty when updating" name=" getSnapshotData() marks invalid snapshot dirty when updating" time="0.001">
    </testcase>
    <testcase classname=" getSnapshotData() marks valid snapshot not dirty when updating" name=" getSnapshotData() marks valid snapshot not dirty when updating" time="0.001">
    </testcase>
    <testcase classname=" escaping" name=" escaping" time="0.001">
    </testcase>
    <testcase classname=" serialize handles \r\n" name=" serialize handles \r\n" time="0">
    </testcase>
    <testcase classname="DeepMerge Correctly merges objects with property matchers" name="DeepMerge Correctly merges objects with property matchers" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:08:29" time="0.39" tests="7">
    <testcase classname=" sorts by file size if there is no timing information" name=" sorts by file size if there is no timing information" time="0.002">
    </testcase>
    <testcase classname=" sorts based on timing information" name=" sorts based on timing information" time="0.001">
    </testcase>
    <testcase classname=" sorts based on failures and timing information" name=" sorts based on failures and timing information" time="0.001">
    </testcase>
    <testcase classname=" sorts based on failures, timing information and file size" name=" sorts based on failures, timing information and file size" time="0.001">
    </testcase>
    <testcase classname=" writes the cache based on results without existing cache" name=" writes the cache based on results without existing cache" time="0.001">
    </testcase>
    <testcase classname=" writes the cache based on the results" name=" writes the cache based on the results" time="0.001">
    </testcase>
    <testcase classname=" works with multiple contexts" name=" works with multiple contexts" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:08:29" time="0.963" tests="19">
    <testcase classname=" recursively validates default Jest config" name=" recursively validates default Jest config" time="0.001">
    </testcase>
    <testcase classname=" recursively validates default jest-validate config" name=" recursively validates default jest-validate config" time="0">
    </testcase>
    <testcase classname=" pretty prints valid config for Boolean" name=" pretty prints valid config for Boolean" time="0.002">
    </testcase>
    <testcase classname=" pretty prints valid config for Array" name=" pretty prints valid config for Array" time="0.001">
    </testcase>
    <testcase classname=" pretty prints valid config for String" name=" pretty prints valid config for String" time="0.001">
    </testcase>
    <testcase classname=" pretty prints valid config for Object" name=" pretty prints valid config for Object" time="0.001">
    </testcase>
    <testcase classname=" pretty prints valid config for Function" name=" pretty prints valid config for Function" time="0">
    </testcase>
    <testcase classname=" omits null and undefined config values" name=" omits null and undefined config values" time="0.001">
    </testcase>
    <testcase classname=" recursively omits null and undefined config values" name=" recursively omits null and undefined config values" time="0">
    </testcase>
    <testcase classname=" respects blacklist" name=" respects blacklist" time="0.001">
    </testcase>
    <testcase classname=" displays warning for unknown config options" name=" displays warning for unknown config options" time="0.009">
    </testcase>
    <testcase classname=" displays warning for deprecated config options" name=" displays warning for deprecated config options" time="0.007">
    </testcase>
    <testcase classname=" works with custom warnings" name=" works with custom warnings" time="0.001">
    </testcase>
    <testcase classname=" works with custom errors" name=" works with custom errors" time="0.001">
    </testcase>
    <testcase classname=" works with custom deprecations" name=" works with custom deprecations" time="0">
    </testcase>
    <testcase classname=" works with multiple valid types" name=" works with multiple valid types" time="0.001">
    </testcase>
    <testcase classname=" reports errors nicely when failing with multiple valid options" name=" reports errors nicely when failing with multiple valid options" time="0.001">
    </testcase>
    <testcase classname=" Repeated types within multiple valid examples are coalesced in error report" name=" Repeated types within multiple valid examples are coalesced in error report" time="0.001">
    </testcase>
    <testcase classname=" Comments in config JSON using &quot;//&quot; key are not warned" name=" Comments in config JSON using &quot;//&quot; key are not warned" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:08:30" time="0.283" tests="12">
    <testcase classname=" returns the same value for primitive or function values" name=" returns the same value for primitive or function values" time="0.003">
    </testcase>
    <testcase classname=" does not execute getters/setters, but copies them" name=" does not execute getters/setters, but copies them" time="0.001">
    </testcase>
    <testcase classname=" copies symbols" name=" copies symbols" time="0">
    </testcase>
    <testcase classname=" copies arrays as array objects" name=" copies arrays as array objects" time="0.001">
    </testcase>
    <testcase classname=" handles cyclic dependencies" name=" handles cyclic dependencies" time="0.001">
    </testcase>
    <testcase classname=" uses the blacklist to avoid copying properties on the first level" name=" uses the blacklist to avoid copying properties on the first level" time="0">
    </testcase>
    <testcase classname=" does not keep the prototype by default when top level is object" name=" does not keep the prototype by default when top level is object" time="0.002">
    </testcase>
    <testcase classname=" does not keep the prototype by default when top level is array" name=" does not keep the prototype by default when top level is array" time="0">
    </testcase>
    <testcase classname=" does not keep the prototype of arrays when keepPrototype = false" name=" does not keep the prototype of arrays when keepPrototype = false" time="0.001">
    </testcase>
    <testcase classname=" keeps the prototype of arrays when keepPrototype = true" name=" keeps the prototype of arrays when keepPrototype = true" time="0.001">
    </testcase>
    <testcase classname=" does not keep the prototype for objects when keepPrototype = false" name=" does not keep the prototype for objects when keepPrototype = false" time="0">
    </testcase>
    <testcase classname=" keeps the prototype for objects when keepPrototype = true" name=" keeps the prototype for objects when keepPrototype = true" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="node crawler" errors="0" failures="0" skipped="6" timestamp="2018-12-19T21:08:31" time="0.519" tests="7">
    <testcase classname="node crawler does not work on Windows" name="node crawler does not work on Windows" time="0.002">
    </testcase>
    <testcase classname="node crawler crawls for files based on patterns" name="node crawler crawls for files based on patterns" time="0.001">
      <skipped/>
    </testcase>
    <testcase classname="node crawler updates only changed files" name="node crawler updates only changed files" time="0">
      <skipped/>
    </testcase>
    <testcase classname="node crawler uses node fs APIs on windows" name="node crawler uses node fs APIs on windows" time="0">
      <skipped/>
    </testcase>
    <testcase classname="node crawler uses node fs APIs if &quot;forceNodeFilesystemAPI&quot; is set to true, regardless of platform" name="node crawler uses node fs APIs if &quot;forceNodeFilesystemAPI&quot; is set to true, regardless of platform" time="0">
      <skipped/>
    </testcase>
    <testcase classname="node crawler completes with empty roots" name="node crawler completes with empty roots" time="0">
      <skipped/>
    </testcase>
    <testcase classname="node crawler completes with fs.readdir throwing an error" name="node crawler completes with fs.readdir throwing an error" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="Runtime" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:08:31" time="2.692" tests="14">
    <testcase classname="Runtime requireMock uses manual mocks before attempting to automock" name="Runtime requireMock uses manual mocks before attempting to automock" time="1.294">
    </testcase>
    <testcase classname="Runtime requireMock can resolve modules that are only referenced from mocks" name="Runtime requireMock can resolve modules that are only referenced from mocks" time="0.091">
    </testcase>
    <testcase classname="Runtime requireMock stores and re-uses manual mock exports" name="Runtime requireMock stores and re-uses manual mock exports" time="0.063">
    </testcase>
    <testcase classname="Runtime requireMock automocks haste modules without a manual mock" name="Runtime requireMock automocks haste modules without a manual mock" time="0.146">
    </testcase>
    <testcase classname="Runtime requireMock automocks relative-path modules without a file extension" name="Runtime requireMock automocks relative-path modules without a file extension" time="0.043">
    </testcase>
    <testcase classname="Runtime requireMock automocks relative-path modules with a file extension" name="Runtime requireMock automocks relative-path modules with a file extension" time="0.033">
    </testcase>
    <testcase classname="Runtime requireMock just falls back when loading a native module" name="Runtime requireMock just falls back when loading a native module" time="0.03">
    </testcase>
    <testcase classname="Runtime requireMock stores and re-uses automocked haste exports" name="Runtime requireMock stores and re-uses automocked haste exports" time="0.034">
    </testcase>
    <testcase classname="Runtime requireMock stores and re-uses automocked relative-path modules" name="Runtime requireMock stores and re-uses automocked relative-path modules" time="0.041">
    </testcase>
    <testcase classname="Runtime requireMock multiple node core modules returns correct module" name="Runtime requireMock multiple node core modules returns correct module" time="0.107">
    </testcase>
    <testcase classname="Runtime requireMock throws on non-existent haste modules" name="Runtime requireMock throws on non-existent haste modules" time="0.027">
    </testcase>
    <testcase classname="Runtime requireMock uses the closest manual mock when duplicates exist" name="Runtime requireMock uses the closest manual mock when duplicates exist" time="0.125">
    </testcase>
    <testcase classname="Runtime requireMock uses manual mocks when using a custom resolver" name="Runtime requireMock uses manual mocks when using a custom resolver" time="0.188">
    </testcase>
    <testcase classname="Runtime requireMock provides `require.main` in mock" name="Runtime requireMock provides `require.main` in mock" time="0.043">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:08:34" time="48.061" tests="9">
    <testcase classname=" basic test constructs" name=" basic test constructs" time="6.861">
    </testcase>
    <testcase classname=" skips" name=" skips" time="9.604">
    </testcase>
    <testcase classname=" only" name=" only" time="5.224">
    </testcase>
    <testcase classname=" cannot have describe with no implementation" name=" cannot have describe with no implementation" time="4.777">
    </testcase>
    <testcase classname=" cannot test with no implementation" name=" cannot test with no implementation" time="4.438">
    </testcase>
    <testcase classname=" skips with expand arg" name=" skips with expand arg" time="3.75">
    </testcase>
    <testcase classname=" only with expand arg" name=" only with expand arg" time="3.665">
    </testcase>
    <testcase classname=" cannot test with no implementation with expand arg" name=" cannot test with no implementation with expand arg" time="3.817">
    </testcase>
    <testcase classname=" function as descriptor" name=" function as descriptor" time="5.341">
    </testcase>
  </testsuite>
  <testsuite name="BaseWorkerPool" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:09:22" time="0.608" tests="9">
    <testcase classname="BaseWorkerPool throws error when createWorker is not defined" name="BaseWorkerPool throws error when createWorker is not defined" time="0.003">
    </testcase>
    <testcase classname="BaseWorkerPool creates and exposes n workers" name="BaseWorkerPool creates and exposes n workers" time="0.002">
    </testcase>
    <testcase classname="BaseWorkerPool ends all workers" name="BaseWorkerPool ends all workers" time="0.002">
    </testcase>
    <testcase classname="BaseWorkerPool creates and expoeses n workers" name="BaseWorkerPool creates and expoeses n workers" time="0.003">
    </testcase>
    <testcase classname="BaseWorkerPool creates workers with the right options" name="BaseWorkerPool creates workers with the right options" time="0.002">
    </testcase>
    <testcase classname="BaseWorkerPool makes a non-existing relative worker throw" name="BaseWorkerPool makes a non-existing relative worker throw" time="0.001">
    </testcase>
    <testcase classname="BaseWorkerPool create multiple workers with unique worker ids" name="BaseWorkerPool create multiple workers with unique worker ids" time="0.001">
    </testcase>
    <testcase classname="BaseWorkerPool aggregates all stdouts and stderrs from all workers" name="BaseWorkerPool aggregates all stdouts and stderrs from all workers" time="0.005">
    </testcase>
    <testcase classname="BaseWorkerPool works when stdout and stderr are not piped to the parent" name="BaseWorkerPool works when stdout and stderr are not piped to the parent" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:09:23" time="1.152" tests="9">
    <testcase classname=" saveInlineSnapshots() replaces empty function call with a template literal" name=" saveInlineSnapshots() replaces empty function call with a template literal" time="0.176">
    </testcase>
    <testcase classname=" saveInlineSnapshots() replaces existing template literal - babylon parser" name=" saveInlineSnapshots() replaces existing template literal - babylon parser" time="0.012">
    </testcase>
    <testcase classname=" saveInlineSnapshots() replaces existing template literal - flow parser" name=" saveInlineSnapshots() replaces existing template literal - flow parser" time="0.006">
    </testcase>
    <testcase classname=" saveInlineSnapshots() replaces existing template literal - typescript parser" name=" saveInlineSnapshots() replaces existing template literal - typescript parser" time="0.005">
    </testcase>
    <testcase classname=" saveInlineSnapshots() replaces existing template literal with property matchers" name=" saveInlineSnapshots() replaces existing template literal with property matchers" time="0.006">
    </testcase>
    <testcase classname=" saveInlineSnapshots() throws if frame does not match" name=" saveInlineSnapshots() throws if frame does not match" time="0.057">
    </testcase>
    <testcase classname=" saveInlineSnapshots() throws if multiple calls to to the same location" name=" saveInlineSnapshots() throws if multiple calls to to the same location" time="0.006">
    </testcase>
    <testcase classname=" saveInlineSnapshots() uses escaped backticks" name=" saveInlineSnapshots() uses escaped backticks" time="0.005">
    </testcase>
    <testcase classname=" saveInlineSnapshots() works with non-literals in expect call" name=" saveInlineSnapshots() works with non-literals in expect call" time="0.01">
    </testcase>
  </testsuite>
  <testsuite name="worker" errors="0" failures="0" skipped="7" timestamp="2018-12-19T21:09:24" time="0.276" tests="8">
    <testcase classname="worker does not work on Windows" name="worker does not work on Windows" time="0.003">
    </testcase>
    <testcase classname="worker parses JavaScript files and extracts module information" name="worker parses JavaScript files and extracts module information" time="0">
      <skipped/>
    </testcase>
    <testcase classname="worker accepts a custom dependency extractor" name="worker accepts a custom dependency extractor" time="0">
      <skipped/>
    </testcase>
    <testcase classname="worker delegates to hasteImplModulePath for getting the id" name="worker delegates to hasteImplModulePath for getting the id" time="0">
      <skipped/>
    </testcase>
    <testcase classname="worker parses package.json files as haste packages" name="worker parses package.json files as haste packages" time="0">
      <skipped/>
    </testcase>
    <testcase classname="worker returns an error when a file cannot be accessed" name="worker returns an error when a file cannot be accessed" time="0">
      <skipped/>
    </testcase>
    <testcase classname="worker simply computes SHA-1s when requested (works well with binary data)" name="worker simply computes SHA-1s when requested (works well with binary data)" time="0">
      <skipped/>
    </testcase>
    <testcase classname="worker avoids computing dependencies if not requested and Haste does not need it" name="worker avoids computing dependencies if not requested and Haste does not need it" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:09:24" time="2.269" tests="9">
    <testcase classname=" mocks modules by default when using automocking" name=" mocks modules by default when using automocking" time="0.408">
    </testcase>
    <testcase classname=" doesn&apos;t mock modules when explicitly unmocked when using automocking" name=" doesn&apos;t mock modules when explicitly unmocked when using automocking" time="0.244">
    </testcase>
    <testcase classname=" doesn&apos;t mock modules when explicitly unmocked via a different name" name=" doesn&apos;t mock modules when explicitly unmocked via a different name" time="0.093">
    </testcase>
    <testcase classname=" doesn&apos;t mock modules when disableAutomock() has been called" name=" doesn&apos;t mock modules when disableAutomock() has been called" time="0.258">
    </testcase>
    <testcase classname=" uses manual mock when automocking on and mock is available" name=" uses manual mock when automocking on and mock is available" time="0.038">
    </testcase>
    <testcase classname=" does not use manual mock when automocking is off and a real module is available" name=" does not use manual mock when automocking is off and a real module is available" time="0.058">
    </testcase>
    <testcase classname=" resolves mapped module names and unmocks them by default" name=" resolves mapped module names and unmocks them by default" time="0.498">
    </testcase>
    <testcase classname=" automocking is disabled by default" name=" automocking is disabled by default" time="0.08">
    </testcase>
    <testcase classname=" unmocks modules in config.unmockedModulePathPatterns for tests with automock enabled when automock is false" name=" unmocks modules in config.unmockedModulePathPatterns for tests with automock enabled when automock is false" time="0.354">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:09:26" time="43.221" tests="5">
    <testcase classname=" exits with 1 if coverage threshold is not met" name=" exits with 1 if coverage threshold is not met" time="8.342">
    </testcase>
    <testcase classname=" exits with 1 if path threshold group is not found in coverage data" name=" exits with 1 if path threshold group is not found in coverage data" time="7.82">
    </testcase>
    <testcase classname=" exits with 0 if global threshold group is not found in coverage data" name=" exits with 0 if global threshold group is not found in coverage data" time="7.737">
    </testcase>
    <testcase classname=" excludes tests matched by path threshold groups from global group" name=" excludes tests matched by path threshold groups from global group" time="9.938">
    </testcase>
    <testcase classname=" file is matched by all path and glob threshold groups" name=" file is matched by all path and glob threshold groups" time="9.061">
    </testcase>
  </testsuite>
  <testsuite name="should_instrument" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:10:10" time="0.369" tests="16">
    <testcase classname="should_instrument should return true when testRegex provided and file is not a test file" name="should_instrument should return true when testRegex provided and file is not a test file" time="0.002">
    </testcase>
    <testcase classname="should_instrument should return true when more than one testRegex is provided and filename is not a test file" name="should_instrument should return true when more than one testRegex is provided and filename is not a test file" time="0.002">
    </testcase>
    <testcase classname="should_instrument should return true when testMatch is provided and file is not a test file" name="should_instrument should return true when testMatch is provided and file is not a test file" time="0.01">
    </testcase>
    <testcase classname="should_instrument should return true should return true when file is in collectCoverageOnlyFrom when provided" name="should_instrument should return true should return true when file is in collectCoverageOnlyFrom when provided" time="0.001">
    </testcase>
    <testcase classname="should_instrument should return true should return true when filename matches collectCoverageFrom" name="should_instrument should return true should return true when filename matches collectCoverageFrom" time="0.002">
    </testcase>
    <testcase classname="should_instrument should return true should should match invalid globs, to be removed in the next major" name="should_instrument should return true should should match invalid globs, to be removed in the next major" time="0.005">
    </testcase>
    <testcase classname="should_instrument should return true should return true if the file is not in coveragePathIgnorePatterns" name="should_instrument should return true should return true if the file is not in coveragePathIgnorePatterns" time="0.001">
    </testcase>
    <testcase classname="should_instrument should return true should return true if file is a testfile but forceCoverageMatch is set" name="should_instrument should return true should return true if file is a testfile but forceCoverageMatch is set" time="0.002">
    </testcase>
    <testcase classname="should_instrument should return false if collectCoverage is falsy" name="should_instrument should return false if collectCoverage is falsy" time="0.001">
    </testcase>
    <testcase classname="should_instrument should return false when testRegex provided and filename is a test file" name="should_instrument should return false when testRegex provided and filename is a test file" time="0">
    </testcase>
    <testcase classname="should_instrument should return false when more than one testRegex is provided and filename matches one of the patterns" name="should_instrument should return false when more than one testRegex is provided and filename matches one of the patterns" time="0">
    </testcase>
    <testcase classname="should_instrument should return false when testMatch is provided and file is a test file" name="should_instrument should return false when testMatch is provided and file is a test file" time="0">
    </testcase>
    <testcase classname="should_instrument should return false when file is not in collectCoverageOnlyFrom when provided" name="should_instrument should return false when file is not in collectCoverageOnlyFrom when provided" time="0.001">
    </testcase>
    <testcase classname="should_instrument should return false when filename does not match collectCoverageFrom" name="should_instrument should return false when filename does not match collectCoverageFrom" time="0">
    </testcase>
    <testcase classname="should_instrument should return false if the file is in coveragePathIgnorePatterns" name="should_instrument should return false if the file is in coveragePathIgnorePatterns" time="0">
    </testcase>
    <testcase classname="should_instrument should return false if file is in mock patterns" name="should_instrument should return false if file is in mock patterns" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:10:10" time="1.398" tests="16">
    <testcase classname=" .addReporter() .removeReporter()" name=" .addReporter() .removeReporter()" time="0.002">
    </testcase>
    <testcase classname=" test always" name=" test always" time="0.003">
    </testcase>
    <testcase classname=" test success" name=" test success" time="0.001">
    </testcase>
    <testcase classname=" test change" name=" test change" time="0.001">
    </testcase>
    <testcase classname=" test success-change" name=" test success-change" time="0.001">
    </testcase>
    <testcase classname=" test failure-change" name=" test failure-change" time="0.001">
    </testcase>
    <testcase classname=" test always with rootDir" name=" test always with rootDir" time="0.001">
    </testcase>
    <testcase classname=" test success with rootDir" name=" test success with rootDir" time="0.001">
    </testcase>
    <testcase classname=" test change with rootDir" name=" test change with rootDir" time="0.001">
    </testcase>
    <testcase classname=" test success-change with rootDir" name=" test success-change with rootDir" time="0.001">
    </testcase>
    <testcase classname=" test failure-change with rootDir" name=" test failure-change with rootDir" time="0">
    </testcase>
    <testcase classname=" test always with moduleName" name=" test always with moduleName" time="0.002">
    </testcase>
    <testcase classname=" test success with moduleName" name=" test success with moduleName" time="0.001">
    </testcase>
    <testcase classname=" test change with moduleName" name=" test change with moduleName" time="0.001">
    </testcase>
    <testcase classname=" test success-change with moduleName" name=" test success-change with moduleName" time="0">
    </testcase>
    <testcase classname=" test failure-change with moduleName" name=" test failure-change with moduleName" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="--findRelatedTests flag" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:10:12" time="37.427" tests="4">
    <testcase classname="--findRelatedTests flag runs tests related to filename" name="--findRelatedTests flag runs tests related to filename" time="6.416">
    </testcase>
    <testcase classname="--findRelatedTests flag runs tests related to filename with a custom dependency extractor" name="--findRelatedTests flag runs tests related to filename with a custom dependency extractor" time="6.053">
    </testcase>
    <testcase classname="--findRelatedTests flag generates coverage report for filename" name="--findRelatedTests flag generates coverage report for filename" time="15.811">
    </testcase>
    <testcase classname="--findRelatedTests flag coverage configuration is applied correctly" name="--findRelatedTests flag coverage configuration is applied correctly" time="8.889">
    </testcase>
  </testsuite>
  <testsuite name="transitive dependencies" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:10:49" time="3.833" tests="6">
    <testcase classname="transitive dependencies mocks a manually mocked and mapped module" name="transitive dependencies mocks a manually mocked and mapped module" time="0.558">
    </testcase>
    <testcase classname="transitive dependencies unmocks transitive dependencies in node_modules by default" name="transitive dependencies unmocks transitive dependencies in node_modules by default" time="0.647">
    </testcase>
    <testcase classname="transitive dependencies unmocks transitive dependencies in node_modules when using unmock" name="transitive dependencies unmocks transitive dependencies in node_modules when using unmock" time="0.616">
    </testcase>
    <testcase classname="transitive dependencies unmocks transitive dependencies in node_modules by default when using both patterns and unmock" name="transitive dependencies unmocks transitive dependencies in node_modules by default when using both patterns and unmock" time="0.575">
    </testcase>
    <testcase classname="transitive dependencies mocks deep dependencies when using unmock" name="transitive dependencies mocks deep dependencies when using unmock" time="0.518">
    </testcase>
    <testcase classname="transitive dependencies does not mock deep dependencies when using deepUnmock" name="transitive dependencies does not mock deep dependencies when using deepUnmock" time="0.71">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:10:53" time="143.462" tests="12">
    <testcase classname=" outputs coverage report" name=" outputs coverage report" time="12.054">
    </testcase>
    <testcase classname=" collects coverage only from specified file" name=" collects coverage only from specified file" time="11.678">
    </testcase>
    <testcase classname=" collects coverage only from multiple specified files" name=" collects coverage only from multiple specified files" time="10.19">
    </testcase>
    <testcase classname=" collects coverage only from specified files avoiding dependencies" name=" collects coverage only from specified files avoiding dependencies" time="6.06">
    </testcase>
    <testcase classname=" json reporter printing with --coverage" name=" json reporter printing with --coverage" time="5.442">
    </testcase>
    <testcase classname=" outputs coverage report as json" name=" outputs coverage report as json" time="13.11">
    </testcase>
    <testcase classname=" outputs coverage report when text is requested" name=" outputs coverage report when text is requested" time="12.981">
    </testcase>
    <testcase classname=" outputs coverage report when text-summary is requested" name=" outputs coverage report when text-summary is requested" time="12.728">
    </testcase>
    <testcase classname=" outputs coverage report when text and text-summary is requested" name=" outputs coverage report when text and text-summary is requested" time="13.488">
    </testcase>
    <testcase classname=" does not output coverage report when html is requested" name=" does not output coverage report when html is requested" time="12.207">
    </testcase>
    <testcase classname=" collects coverage from duplicate files avoiding shared cache" name=" collects coverage from duplicate files avoiding shared cache" time="18.312">
    </testcase>
    <testcase classname=" generates coverage when using the testRegex config param " name=" generates coverage when using the testRegex config param " time="14.921">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:13:16" time="46.881" tests="6">
    <testcase classname=" not throwing Error objects" name=" not throwing Error objects" time="24.629">
    </testcase>
    <testcase classname=" works with node assert" name=" works with node assert" time="4.352">
    </testcase>
    <testcase classname=" works with assertions in separate files" name=" works with assertions in separate files" time="4.441">
    </testcase>
    <testcase classname=" works with async failures" name=" works with async failures" time="4.301">
    </testcase>
    <testcase classname=" works with snapshot failures" name=" works with snapshot failures" time="4.395">
    </testcase>
    <testcase classname=" works with named snapshot failures" name=" works with named snapshot failures" time="4.39">
    </testcase>
  </testsuite>
  <testsuite name="async jasmine" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:14:03" time="56.032" tests="11">
    <testcase classname="async jasmine works with beforeAll" name="async jasmine works with beforeAll" time="5.168">
    </testcase>
    <testcase classname="async jasmine works with beforeEach" name="async jasmine works with beforeEach" time="4.479">
    </testcase>
    <testcase classname="async jasmine works with afterAll" name="async jasmine works with afterAll" time="4.793">
    </testcase>
    <testcase classname="async jasmine works with afterEach" name="async jasmine works with afterEach" time="5.229">
    </testcase>
    <testcase classname="async jasmine works with fit" name="async jasmine works with fit" time="4.65">
    </testcase>
    <testcase classname="async jasmine works with xit" name="async jasmine works with xit" time="4.364">
    </testcase>
    <testcase classname="async jasmine throws when not a promise is returned" name="async jasmine throws when not a promise is returned" time="4.444">
    </testcase>
    <testcase classname="async jasmine tests async promise code" name="async jasmine tests async promise code" time="4.558">
    </testcase>
    <testcase classname="async jasmine works with concurrent" name="async jasmine works with concurrent" time="4.587">
    </testcase>
    <testcase classname="async jasmine async test fails" name="async jasmine async test fails" time="8.549">
    </testcase>
    <testcase classname="async jasmine generator test" name="async jasmine generator test" time="4.832">
    </testcase>
  </testsuite>
  <testsuite name="Runtime" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:14:59" time="1.429" tests="4">
    <testcase classname="Runtime jest.mock uses explicitly set mocks instead of automocking" name="Runtime jest.mock uses explicitly set mocks instead of automocking" time="0.767">
    </testcase>
    <testcase classname="Runtime jest.mock sets virtual mock for non-existing module required from same directory" name="Runtime jest.mock sets virtual mock for non-existing module required from same directory" time="0.104">
    </testcase>
    <testcase classname="Runtime jest.mock sets virtual mock for non-existing module required from different directory" name="Runtime jest.mock sets virtual mock for non-existing module required from different directory" time="0.059">
    </testcase>
    <testcase classname="Runtime jest.setMock uses explicitly set mocks instead of automocking" name="Runtime jest.setMock uses explicitly set mocks instead of automocking" time="0.062">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:15:01" time="0.499" tests="5">
    <testcase classname=" should exclude jasmine from stack trace for Unix paths." name=" should exclude jasmine from stack trace for Unix paths." time="0.051">
    </testcase>
    <testcase classname=" .formatExecError()" name=" .formatExecError()" time="0.003">
    </testcase>
    <testcase classname=" formatStackTrace should strip node internals" name=" formatStackTrace should strip node internals" time="0.003">
    </testcase>
    <testcase classname=" should not exclude vendor from stack trace" name=" should not exclude vendor from stack trace" time="0.002">
    </testcase>
    <testcase classname=" retains message in babel code frame error" name=" retains message in babel code frame error" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:15:01" time="0.727" tests="6">
    <testcase classname=" config for reporters supports `default`" name=" config for reporters supports `default`" time="0.004">
    </testcase>
    <testcase classname=" .addReporter() .removeReporter()" name=" .addReporter() .removeReporter()" time="0.001">
    </testcase>
    <testcase classname=" schedule tests run in parallel per default" name=" schedule tests run in parallel per default" time="0.008">
    </testcase>
    <testcase classname=" schedule tests run in serial if the runner flags them" name=" schedule tests run in serial if the runner flags them" time="0.006">
    </testcase>
    <testcase classname=" should bail after `n` failures" name=" should bail after `n` failures" time="0.003">
    </testcase>
    <testcase classname=" should not bail if less than `n` failures" name=" should not bail if less than `n` failures" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="DOMCollection plugin for object properties" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:15:02" time="0.38" tests="10">
    <testcase classname="DOMCollection plugin for object properties supports DOMStringMap" name="DOMCollection plugin for object properties supports DOMStringMap" time="0.006">
    </testcase>
    <testcase classname="DOMCollection plugin for object properties supports NamedNodeMap" name="DOMCollection plugin for object properties supports NamedNodeMap" time="0">
    </testcase>
    <testcase classname="DOMCollection plugin for object properties supports config.min option" name="DOMCollection plugin for object properties supports config.min option" time="0.001">
    </testcase>
    <testcase classname="DOMCollection plugin for list items supports HTMLCollection for getElementsByTagName" name="DOMCollection plugin for list items supports HTMLCollection for getElementsByTagName" time="0.004">
    </testcase>
    <testcase classname="DOMCollection plugin for list items supports HTMLCollection for children" name="DOMCollection plugin for list items supports HTMLCollection for children" time="0.002">
    </testcase>
    <testcase classname="DOMCollection plugin for list items supports config.maxDepth option" name="DOMCollection plugin for list items supports config.maxDepth option" time="0.001">
    </testcase>
    <testcase classname="DOMCollection plugin for list items supports NodeList for querySelectorAll" name="DOMCollection plugin for list items supports NodeList for querySelectorAll" time="0.012">
    </testcase>
    <testcase classname="DOMCollection plugin for list items supports NodeList for childNodes" name="DOMCollection plugin for list items supports NodeList for childNodes" time="0.001">
    </testcase>
    <testcase classname="DOMCollection plugin for list items supports HTMLOptionsCollection for select options" name="DOMCollection plugin for list items supports HTMLOptionsCollection for select options" time="0.001">
    </testcase>
    <testcase classname="DOMCollection plugin for list items supports HTMLCollection for form elements" name="DOMCollection plugin for list items supports HTMLCollection for form elements" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:15:03" time="0.413" tests="10">
    <testcase classname=" mock with 0 calls and default name" name=" mock with 0 calls and default name" time="0.004">
    </testcase>
    <testcase classname=" mock with 2 calls, 1 return, 1 throw" name=" mock with 2 calls, 1 return, 1 throw" time="0.004">
    </testcase>
    <testcase classname=" mock with 0 calls and default name in React element" name=" mock with 0 calls and default name in React element" time="0.001">
    </testcase>
    <testcase classname=" mock with 0 calls and non-default name" name=" mock with 0 calls and non-default name" time="0.002">
    </testcase>
    <testcase classname=" mock with 1 calls and non-default name via new in object" name=" mock with 1 calls and non-default name via new in object" time="0.001">
    </testcase>
    <testcase classname=" mock with 1 calls in React element" name=" mock with 1 calls in React element" time="0.001">
    </testcase>
    <testcase classname=" mock with 2 calls" name=" mock with 2 calls" time="0.001">
    </testcase>
    <testcase classname=" indent option" name=" indent option" time="0.001">
    </testcase>
    <testcase classname=" min option" name=" min option" time="0.001">
    </testcase>
    <testcase classname=" maxDepth option" name=" maxDepth option" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="Jest Worker Process Integration" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:15:03" time="0.621" tests="4">
    <testcase classname="Jest Worker Process Integration calls a single method from the worker" name="Jest Worker Process Integration calls a single method from the worker" time="0.21">
    </testcase>
    <testcase classname="Jest Worker Process Integration distributes sequential calls across child processes" name="Jest Worker Process Integration distributes sequential calls across child processes" time="0.012">
    </testcase>
    <testcase classname="Jest Worker Process Integration distributes concurrent calls across child processes" name="Jest Worker Process Integration distributes concurrent calls across child processes" time="0.012">
    </testcase>
    <testcase classname="Jest Worker Process Integration sticks parallel calls to children" name="Jest Worker Process Integration sticks parallel calls to children" time="0.013">
    </testcase>
  </testsuite>
  <testsuite name="Watch mode flows" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:15:04" time="0.515" tests="2">
    <testcase classname="Watch mode flows Pressing &quot;P&quot; enters pattern mode" name="Watch mode flows Pressing &quot;P&quot; enters pattern mode" time="0.022">
    </testcase>
    <testcase classname="Watch mode flows Pressing &quot;c&quot; clears the filters" name="Watch mode flows Pressing &quot;c&quot; clears the filters" time="0.008">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:15:05" time="0.419" tests="8">
    <testcase classname=" exposes the right API using default working" name=" exposes the right API using default working" time="0.014">
    </testcase>
    <testcase classname=" exposes the right API using passed worker" name=" exposes the right API using passed worker" time="0.003">
    </testcase>
    <testcase classname=" breaks if any of the forbidden methods is tried to be exposed" name=" breaks if any of the forbidden methods is tried to be exposed" time="0.007">
    </testcase>
    <testcase classname=" works with minimal options" name=" works with minimal options" time="0.017">
    </testcase>
    <testcase classname=" does not let make calls after the farm is ended" name=" does not let make calls after the farm is ended" time="0.003">
    </testcase>
    <testcase classname=" does not let end the farm after it is ended" name=" does not let end the farm after it is ended" time="0.003">
    </testcase>
    <testcase classname=" calls doWork" name=" calls doWork" time="0.003">
    </testcase>
    <testcase classname=" calls getStderr and getStdout from worker" name=" calls getStderr and getStdout from worker" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="Jest Worker Integration" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:15:05" time="0.382" tests="4">
    <testcase classname="Jest Worker Integration calls a single method from the worker" name="Jest Worker Integration calls a single method from the worker" time="0.015">
    </testcase>
    <testcase classname="Jest Worker Integration distributes sequential calls across child processes" name="Jest Worker Integration distributes sequential calls across child processes" time="0.012">
    </testcase>
    <testcase classname="Jest Worker Integration distributes concurrent calls across child processes" name="Jest Worker Integration distributes concurrent calls across child processes" time="0.011">
    </testcase>
    <testcase classname="Jest Worker Integration sticks parallel calls to children" name="Jest Worker Integration sticks parallel calls to children" time="0.008">
    </testcase>
  </testsuite>
  <testsuite name="babel-jest" errors="0" failures="2" skipped="0" timestamp="2018-12-19T21:15:05" time="90.209" tests="8">
    <testcase classname="babel-jest runs transpiled code" name="babel-jest runs transpiled code" time="19.552">
    </testcase>
    <testcase classname="babel-jest instruments only specific files and collects coverage" name="babel-jest instruments only specific files and collects coverage" time="6.403">
    </testcase>
    <testcase classname="no babel-jest fails with syntax error on flow types" name="no babel-jest fails with syntax error on flow types" time="7.323">
      <failure>Error: EPERM: operation not permitted, symlink &apos;C:\Users\kangan\Source\Repos\jest\packages\babel-jest&apos; -&gt; &apos;C:\Users\kangan\AppData\Local\Temp\transform-no-babel-jest\node_modules\babel-jest&apos;
    at Object.symlinkSync (fs.js:902:3)
    at symlinkSync (C:\Users\kangan\Source\Repos\jest\e2e\Utils.js:48:6)
    at Object.beforeEach (C:\Users\kangan\Source\Repos\jest\e2e\__tests__\transform.test.js:58:5)
    at Object.asyncJestLifecycle (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\jasmineAsyncInstall.js:70:37)
    at resolve (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\queueRunner.js:54:12)
    at new Promise (&lt;anonymous&gt;)
    at mapper (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\queueRunner.js:41:19)
    at promise.then (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\queueRunner.js:86:41)</failure>
    </testcase>
    <testcase classname="no babel-jest instrumentation with no babel-jest" name="no babel-jest instrumentation with no babel-jest" time="8.305">
      <failure>Error: EPERM: operation not permitted, symlink &apos;C:\Users\kangan\Source\Repos\jest\packages\babel-jest&apos; -&gt; &apos;C:\Users\kangan\AppData\Local\Temp\transform-no-babel-jest\node_modules\babel-jest&apos;
    at Object.symlinkSync (fs.js:902:3)
    at symlinkSync (C:\Users\kangan\Source\Repos\jest\e2e\Utils.js:48:6)
    at Object.beforeEach (C:\Users\kangan\Source\Repos\jest\e2e\__tests__\transform.test.js:58:5)
    at Object.asyncJestLifecycle (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\jasmineAsyncInstall.js:70:37)
    at resolve (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\queueRunner.js:54:12)
    at new Promise (&lt;anonymous&gt;)
    at mapper (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\queueRunner.js:41:19)
    at promise.then (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\queueRunner.js:86:41)</failure>
    </testcase>
    <testcase classname="custom transformer proprocesses files" name="custom transformer proprocesses files" time="4.075">
    </testcase>
    <testcase classname="custom transformer instruments files" name="custom transformer instruments files" time="4.884">
    </testcase>
    <testcase classname="multiple-transformers transforms dependencies using specific transformers" name="multiple-transformers transforms dependencies using specific transformers" time="32.552">
    </testcase>
    <testcase classname="ecmascript-modules-support runs transpiled code" name="ecmascript-modules-support runs transpiled code" time="6.842">
    </testcase>
  </testsuite>
  <testsuite name="queueRunner" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:16:36" time="0.605" tests="6">
    <testcase classname="queueRunner runs every function in the queue." name="queueRunner runs every function in the queue." time="0.008">
    </testcase>
    <testcase classname="queueRunner exposes `fail` to `next`." name="queueRunner exposes `fail` to `next`." time="0.002">
    </testcase>
    <testcase classname="queueRunner passes errors to `onException`." name="queueRunner passes errors to `onException`." time="0.002">
    </testcase>
    <testcase classname="queueRunner passes an error to `onException` on timeout." name="queueRunner passes an error to `onException` on timeout." time="0.018">
    </testcase>
    <testcase classname="queueRunner calls `fail` with arguments" name="queueRunner calls `fail` with arguments" time="0.001">
    </testcase>
    <testcase classname="queueRunner calls `fail` when done(error) is invoked" name="queueRunner calls `fail` when done(error) is invoked" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="Watch mode flows" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:16:36" time="0.484" tests="1">
    <testcase classname="Watch mode flows Pressing &quot;T&quot; enters pattern mode" name="Watch mode flows Pressing &quot;T&quot; enters pattern mode" time="0.019">
    </testcase>
  </testsuite>
  <testsuite name="getPath()" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:16:37" time="0.534" tests="20">
    <testcase classname="getPath() property exists" name="getPath() property exists" time="0.003">
    </testcase>
    <testcase classname="getPath() property doesnt exist" name="getPath() property doesnt exist" time="0.001">
    </testcase>
    <testcase classname="getPath() property exist but undefined" name="getPath() property exist but undefined" time="0.001">
    </testcase>
    <testcase classname="getPath() property is a getter on class instance" name="getPath() property is a getter on class instance" time="0.001">
    </testcase>
    <testcase classname="getPath() path breaks" name="getPath() path breaks" time="0.001">
    </testcase>
    <testcase classname="getPath() empty object at the end" name="getPath() empty object at the end" time="0.001">
    </testcase>
    <testcase classname="getObjectSubset() expect(getObjectSubset({&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;}, {&quot;a&quot;: &quot;d&quot;})).toEqual({&quot;a&quot;: &quot;b&quot;})" name="getObjectSubset() expect(getObjectSubset({&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;}, {&quot;a&quot;: &quot;d&quot;})).toEqual({&quot;a&quot;: &quot;b&quot;})" time="0.001">
    </testcase>
    <testcase classname="getObjectSubset() expect(getObjectSubset({&quot;a&quot;: [1, 2], &quot;b&quot;: &quot;b&quot;}, {&quot;a&quot;: [3, 4]})).toEqual({&quot;a&quot;: [1, 2]})" name="getObjectSubset() expect(getObjectSubset({&quot;a&quot;: [1, 2], &quot;b&quot;: &quot;b&quot;}, {&quot;a&quot;: [3, 4]})).toEqual({&quot;a&quot;: [1, 2]})" time="0">
    </testcase>
    <testcase classname="getObjectSubset() expect(getObjectSubset([{&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;}], [{&quot;a&quot;: &quot;z&quot;}])).toEqual([{&quot;a&quot;: &quot;b&quot;}])" name="getObjectSubset() expect(getObjectSubset([{&quot;a&quot;: &quot;b&quot;, &quot;c&quot;: &quot;d&quot;}], [{&quot;a&quot;: &quot;z&quot;}])).toEqual([{&quot;a&quot;: &quot;b&quot;}])" time="0.001">
    </testcase>
    <testcase classname="getObjectSubset() expect(getObjectSubset([1, 2], [1, 2, 3])).toEqual([1, 2])" name="getObjectSubset() expect(getObjectSubset([1, 2], [1, 2, 3])).toEqual([1, 2])" time="0">
    </testcase>
    <testcase classname="getObjectSubset() expect(getObjectSubset({&quot;a&quot;: [1]}, {&quot;a&quot;: [1, 2]})).toEqual({&quot;a&quot;: [1]})" name="getObjectSubset() expect(getObjectSubset({&quot;a&quot;: [1]}, {&quot;a&quot;: [1, 2]})).toEqual({&quot;a&quot;: [1]})" time="0.004">
    </testcase>
    <testcase classname="getObjectSubset() expect(getObjectSubset(2015-11-30T00:00:00.000Z, 2016-12-30T00:00:00.000Z)).toEqual(2015-11-30T00:00:00.000Z)" name="getObjectSubset() expect(getObjectSubset(2015-11-30T00:00:00.000Z, 2016-12-30T00:00:00.000Z)).toEqual(2015-11-30T00:00:00.000Z)" time="0">
    </testcase>
    <testcase classname="emptyObject() matches an empty object" name="emptyObject() matches an empty object" time="0.001">
    </testcase>
    <testcase classname="emptyObject() does not match an object with keys" name="emptyObject() does not match an object with keys" time="0">
    </testcase>
    <testcase classname="emptyObject() does not match a non-object" name="emptyObject() does not match a non-object" time="0.001">
    </testcase>
    <testcase classname="subsetEquality() matching object returns true" name="subsetEquality() matching object returns true" time="0">
    </testcase>
    <testcase classname="subsetEquality() object without keys is undefined" name="subsetEquality() object without keys is undefined" time="0">
    </testcase>
    <testcase classname="subsetEquality() objects to not match" name="subsetEquality() objects to not match" time="0.001">
    </testcase>
    <testcase classname="subsetEquality() null does not return errors" name="subsetEquality() null does not return errors" time="0.001">
    </testcase>
    <testcase classname="subsetEquality() undefined does not return errors" name="subsetEquality() undefined does not return errors" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:16:37" time="0.45" tests="9">
    <testcase classname=" is available globally when matcher is unary" name=" is available globally when matcher is unary" time="0.017">
    </testcase>
    <testcase classname=" is available globally when matcher is variadic" name=" is available globally when matcher is variadic" time="0.004">
    </testcase>
    <testcase classname=" exposes matcherUtils in context" name=" exposes matcherUtils in context" time="0.001">
    </testcase>
    <testcase classname=" is ok if there is no message specified" name=" is ok if there is no message specified" time="0.004">
    </testcase>
    <testcase classname=" exposes an equality function to custom matchers" name=" exposes an equality function to custom matchers" time="0.002">
    </testcase>
    <testcase classname=" defines asymmetric unary matchers" name=" defines asymmetric unary matchers" time="0.006">
    </testcase>
    <testcase classname=" defines asymmetric unary matchers that can be prefixed by not" name=" defines asymmetric unary matchers that can be prefixed by not" time="0.004">
    </testcase>
    <testcase classname=" defines asymmetric variadic matchers" name=" defines asymmetric variadic matchers" time="0.004">
    </testcase>
    <testcase classname=" defines asymmetric variadic matchers that can be prefixed by not" name=" defines asymmetric variadic matchers that can be prefixed by not" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="CustomConsole" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:16:38" time="0.682" tests="14">
    <testcase classname="CustomConsole assert do not log when the assertion is truthy" name="CustomConsole assert do not log when the assertion is truthy" time="0.002">
    </testcase>
    <testcase classname="CustomConsole assert do not log when the assertion is truthy and there is a message" name="CustomConsole assert do not log when the assertion is truthy and there is a message" time="0.001">
    </testcase>
    <testcase classname="CustomConsole assert log the assertion error when the assertion is falsy" name="CustomConsole assert log the assertion error when the assertion is falsy" time="0.039">
    </testcase>
    <testcase classname="CustomConsole assert log the assertion error when the assertion is falsy with another message argument" name="CustomConsole assert log the assertion error when the assertion is falsy with another message argument" time="0.001">
    </testcase>
    <testcase classname="CustomConsole count count using the default counter" name="CustomConsole count count using the default counter" time="0">
    </testcase>
    <testcase classname="CustomConsole count count using the a labeled counter" name="CustomConsole count count using the a labeled counter" time="0.001">
    </testcase>
    <testcase classname="CustomConsole count countReset restarts default counter" name="CustomConsole count countReset restarts default counter" time="0.001">
    </testcase>
    <testcase classname="CustomConsole count countReset restarts custom counter" name="CustomConsole count countReset restarts custom counter" time="0.001">
    </testcase>
    <testcase classname="CustomConsole group group without label" name="CustomConsole group group without label" time="0.001">
    </testcase>
    <testcase classname="CustomConsole group group with label" name="CustomConsole group group with label" time="0.001">
    </testcase>
    <testcase classname="CustomConsole group groupEnd remove the indentation of the current group" name="CustomConsole group groupEnd remove the indentation of the current group" time="0">
    </testcase>
    <testcase classname="CustomConsole group groupEnd can not remove the indentation below the starting point" name="CustomConsole group groupEnd can not remove the indentation below the starting point" time="0.001">
    </testcase>
    <testcase classname="CustomConsole time should return the time between time() and timeEnd() on default timer" name="CustomConsole time should return the time between time() and timeEnd() on default timer" time="0.001">
    </testcase>
    <testcase classname="CustomConsole time should return the time between time() and timeEnd() on custom timer" name="CustomConsole time should return the time between time() and timeEnd() on custom timer" time="0">
    </testcase>
  </testsuite>
  <testsuite name="CustomConsole" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:16:39" time="0.625" tests="14">
    <testcase classname="CustomConsole assert do not log when the assertion is truthy" name="CustomConsole assert do not log when the assertion is truthy" time="0.003">
    </testcase>
    <testcase classname="CustomConsole assert do not log when the assertion is truthy and there is a message" name="CustomConsole assert do not log when the assertion is truthy and there is a message" time="0">
    </testcase>
    <testcase classname="CustomConsole assert log the assertion error when the assertion is falsy" name="CustomConsole assert log the assertion error when the assertion is falsy" time="0.005">
    </testcase>
    <testcase classname="CustomConsole assert log the assertion error when the assertion is falsy with another message argument" name="CustomConsole assert log the assertion error when the assertion is falsy with another message argument" time="0.001">
    </testcase>
    <testcase classname="CustomConsole count count using the default counter" name="CustomConsole count count using the default counter" time="0.001">
    </testcase>
    <testcase classname="CustomConsole count count using the a labeled counter" name="CustomConsole count count using the a labeled counter" time="0.001">
    </testcase>
    <testcase classname="CustomConsole count countReset restarts default counter" name="CustomConsole count countReset restarts default counter" time="0.001">
    </testcase>
    <testcase classname="CustomConsole count countReset restarts custom counter" name="CustomConsole count countReset restarts custom counter" time="0">
    </testcase>
    <testcase classname="CustomConsole group group without label" name="CustomConsole group group without label" time="0.002">
    </testcase>
    <testcase classname="CustomConsole group group with label" name="CustomConsole group group with label" time="0.001">
    </testcase>
    <testcase classname="CustomConsole group groupEnd remove the indentation of the current group" name="CustomConsole group groupEnd remove the indentation of the current group" time="0">
    </testcase>
    <testcase classname="CustomConsole group groupEnd can not remove the indentation below the starting point" name="CustomConsole group groupEnd can not remove the indentation below the starting point" time="0.001">
    </testcase>
    <testcase classname="CustomConsole time should return the time between time() and timeEnd() on default timer" name="CustomConsole time should return the time between time() and timeEnd() on default timer" time="0.001">
    </testcase>
    <testcase classname="CustomConsole time should return the time between time() and timeEnd() on custom timer" name="CustomConsole time should return the time between time() and timeEnd() on custom timer" time="0">
    </testcase>
  </testsuite>
  <testsuite name="Custom Reporters Integration" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:16:39" time="48.415" tests="8">
    <testcase classname="Custom Reporters Integration valid string format for adding reporters" name="Custom Reporters Integration valid string format for adding reporters" time="9.544">
    </testcase>
    <testcase classname="Custom Reporters Integration valid array format for adding reporters" name="Custom Reporters Integration valid array format for adding reporters" time="6.482">
    </testcase>
    <testcase classname="Custom Reporters Integration invalid format for adding reporters" name="Custom Reporters Integration invalid format for adding reporters" time="0.906">
    </testcase>
    <testcase classname="Custom Reporters Integration default reporters enabled" name="Custom Reporters Integration default reporters enabled" time="6.162">
    </testcase>
    <testcase classname="Custom Reporters Integration TestReporter with all tests passing" name="Custom Reporters Integration TestReporter with all tests passing" time="5.981">
    </testcase>
    <testcase classname="Custom Reporters Integration TestReporter with all tests failing" name="Custom Reporters Integration TestReporter with all tests failing" time="7.785">
    </testcase>
    <testcase classname="Custom Reporters Integration IncompleteReporter for flexibility" name="Custom Reporters Integration IncompleteReporter for flexibility" time="7.647">
    </testcase>
    <testcase classname="Custom Reporters Integration prints reporter errors" name="Custom Reporters Integration prints reporter errors" time="3.594">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:17:28" time="1.864" tests="4">
    <testcase classname=" snapshots needs update with npm test" name=" snapshots needs update with npm test" time="0.008">
    </testcase>
    <testcase classname=" snapshots needs update with yarn test" name=" snapshots needs update with yarn test" time="0.011">
    </testcase>
    <testcase classname=" snapshots all have results (no update)" name=" snapshots all have results (no update)" time="0.009">
    </testcase>
    <testcase classname=" snapshots all have results (after update)" name=" snapshots all have results (after update)" time="0.016">
    </testcase>
  </testsuite>
  <testsuite name="Stack Trace" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:17:30" time="43.933" tests="7">
    <testcase classname="Stack Trace prints a stack trace for runtime errors" name="Stack Trace prints a stack trace for runtime errors" time="7.854">
    </testcase>
    <testcase classname="Stack Trace does not print a stack trace for runtime errors when --noStackTrace is given" name="Stack Trace does not print a stack trace for runtime errors when --noStackTrace is given" time="6.12">
    </testcase>
    <testcase classname="Stack Trace prints a stack trace for matching errors" name="Stack Trace prints a stack trace for matching errors" time="5.915">
    </testcase>
    <testcase classname="Stack Trace does not print a stack trace for matching errors when --noStackTrace is given" name="Stack Trace does not print a stack trace for matching errors when --noStackTrace is given" time="6.434">
    </testcase>
    <testcase classname="Stack Trace prints a stack trace for errors" name="Stack Trace prints a stack trace for errors" time="8.079">
    </testcase>
    <testcase classname="Stack Trace prints a stack trace for errors without message in stack trace" name="Stack Trace prints a stack trace for errors without message in stack trace" time="5.005">
    </testcase>
    <testcase classname="Stack Trace does not print a stack trace for errors when --noStackTrace is given" name="Stack Trace does not print a stack trace for errors when --noStackTrace is given" time="3.986">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:18:14" time="22.654" tests="5">
    <testcase classname=" works fine when function throws error" name=" works fine when function throws error" time="4.56">
    </testcase>
    <testcase classname=" throws the error if tested function didn&apos;t throw error" name=" throws the error if tested function didn&apos;t throw error" time="4.592">
    </testcase>
    <testcase classname=" accepts custom snapshot name" name=" accepts custom snapshot name" time="4.246">
    </testcase>
    <testcase classname=" cannot be used with .not" name=" cannot be used with .not" time="4.213">
    </testcase>
    <testcase classname=" should support rejecting promises" name=" should support rejecting promises" time="4.217">
    </testcase>
  </testsuite>
  <testsuite name="JSON Reporter" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:18:37" time="9.492" tests="2">
    <testcase classname="JSON Reporter writes test result to sum.result.json" name="JSON Reporter writes test result to sum.result.json" time="4.99">
    </testcase>
    <testcase classname="JSON Reporter outputs coverage report" name="JSON Reporter outputs coverage report" time="4.226">
    </testcase>
  </testsuite>
  <testsuite name=".stringify()" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:18:46" time="0.961" tests="26">
    <testcase classname=".stringify() []" name=".stringify() []" time="0.002">
    </testcase>
    <testcase classname=".stringify() {}" name=".stringify() {}" time="0.001">
    </testcase>
    <testcase classname=".stringify() 1" name=".stringify() 1" time="0.001">
    </testcase>
    <testcase classname=".stringify() 0" name=".stringify() 0" time="0">
    </testcase>
    <testcase classname=".stringify() 1.5" name=".stringify() 1.5" time="0.001">
    </testcase>
    <testcase classname=".stringify() null" name=".stringify() null" time="0.001">
    </testcase>
    <testcase classname=".stringify() undefined" name=".stringify() undefined" time="0">
    </testcase>
    <testcase classname=".stringify() &quot;abc&quot;" name=".stringify() &quot;abc&quot;" time="0.001">
    </testcase>
    <testcase classname=".stringify() Symbol(abc)" name=".stringify() Symbol(abc)" time="0.002">
    </testcase>
    <testcase classname=".stringify() NaN" name=".stringify() NaN" time="0.004">
    </testcase>
    <testcase classname=".stringify() Infinity" name=".stringify() Infinity" time="0.001">
    </testcase>
    <testcase classname=".stringify() -Infinity" name=".stringify() -Infinity" time="0">
    </testcase>
    <testcase classname=".stringify() /ab\.c/gi" name=".stringify() /ab\.c/gi" time="0.001">
    </testcase>
    <testcase classname=".stringify() circular references" name=".stringify() circular references" time="0.001">
    </testcase>
    <testcase classname=".stringify() toJSON error" name=".stringify() toJSON error" time="0.001">
    </testcase>
    <testcase classname=".stringify() toJSON errors when comparing two objects" name=".stringify() toJSON errors when comparing two objects" time="0.009">
    </testcase>
    <testcase classname=".stringify() reduces maxDepth if stringifying very large objects" name=".stringify() reduces maxDepth if stringifying very large objects" time="0.226">
    </testcase>
    <testcase classname=".ensureNumbers() dont throw error when variables are numbers" name=".ensureNumbers() dont throw error when variables are numbers" time="0.001">
    </testcase>
    <testcase classname=".ensureNumbers() throws error when expected is not a number" name=".ensureNumbers() throws error when expected is not a number" time="0">
    </testcase>
    <testcase classname=".ensureNumbers() throws error when actual is not a number" name=".ensureNumbers() throws error when actual is not a number" time="0.001">
    </testcase>
    <testcase classname=".ensureNoExpected() dont throw error when undefined" name=".ensureNoExpected() dont throw error when undefined" time="0">
    </testcase>
    <testcase classname=".ensureNoExpected() throws error when is not undefined" name=".ensureNoExpected() throws error when is not undefined" time="0.001">
    </testcase>
    <testcase classname=".ensureNoExpected() throws error when is not undefined with matcherName" name=".ensureNoExpected() throws error when is not undefined with matcherName" time="0">
    </testcase>
    <testcase classname=".pluralize() one" name=".pluralize() one" time="0.001">
    </testcase>
    <testcase classname=".pluralize() two" name=".pluralize() two" time="0.002">
    </testcase>
    <testcase classname=".pluralize() 20" name=".pluralize() 20" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:18:48" time="0.859" tests="7">
    <testcase classname=" resolves no dependencies for non-existent path" name=" resolves no dependencies for non-existent path" time="0.107">
    </testcase>
    <testcase classname=" resolves dependencies for existing path" name=" resolves dependencies for existing path" time="0.032">
    </testcase>
    <testcase classname=" resolves dependencies for scoped packages" name=" resolves dependencies for scoped packages" time="0.024">
    </testcase>
    <testcase classname=" resolves no inverse dependencies for empty paths set" name=" resolves no inverse dependencies for empty paths set" time="0.012">
    </testcase>
    <testcase classname=" resolves no inverse dependencies for set of non-existent paths" name=" resolves no inverse dependencies for set of non-existent paths" time="0.068">
    </testcase>
    <testcase classname=" resolves inverse dependencies for existing path" name=" resolves inverse dependencies for existing path" time="0.074">
    </testcase>
    <testcase classname=" resolves inverse dependencies from available snapshot" name=" resolves inverse dependencies from available snapshot" time="0.072">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:18:48" time="27.124" tests="4">
    <testcase classname=" works fine when function throws error" name=" works fine when function throws error" time="5.113">
    </testcase>
    <testcase classname=" updates existing snapshot" name=" updates existing snapshot" time="6.565">
    </testcase>
    <testcase classname=" cannot be used with .not" name=" cannot be used with .not" time="5.227">
    </testcase>
    <testcase classname=" should support rejecting promises" name=" should support rejecting promises" time="9.974">
    </testcase>
  </testsuite>
  <testsuite name="wrapAnsiString()" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:19:16" time="1.212" tests="7">
    <testcase classname="wrapAnsiString() wraps a long string containing ansi chars" name="wrapAnsiString() wraps a long string containing ansi chars" time="0.009">
    </testcase>
    <testcase classname="wrapAnsiString() returns the string unaltered if given a terminal width of zero" name="wrapAnsiString() returns the string unaltered if given a terminal width of zero" time="0.002">
    </testcase>
    <testcase classname="trimAndFormatPath() trims dirname" name="trimAndFormatPath() trims dirname" time="0.005">
    </testcase>
    <testcase classname="trimAndFormatPath() trims dirname (longer line width)" name="trimAndFormatPath() trims dirname (longer line width)" time="0.003">
    </testcase>
    <testcase classname="trimAndFormatPath() trims dirname and basename" name="trimAndFormatPath() trims dirname and basename" time="0.004">
    </testcase>
    <testcase classname="trimAndFormatPath() does not trim anything" name="trimAndFormatPath() does not trim anything" time="0.003">
    </testcase>
    <testcase classname="trimAndFormatPath() split at the path.sep index" name="trimAndFormatPath() split at the path.sep index" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:19:17" time="1.833" tests="4">
    <testcase classname=" creates a process object that looks like the original one" name=" creates a process object that looks like the original one" time="0.03">
    </testcase>
    <testcase classname=" fakes require(&quot;process&quot;) so it is equal to &quot;global.process&quot;" name=" fakes require(&quot;process&quot;) so it is equal to &quot;global.process&quot;" time="0.001">
    </testcase>
    <testcase classname=" checks that process.env works as expected on Linux platforms" name=" checks that process.env works as expected on Linux platforms" time="0.015">
    </testcase>
    <testcase classname=" checks that process.env works as expected in Windows platforms" name=" checks that process.env works as expected in Windows platforms" time="0.045">
    </testcase>
  </testsuite>
  <testsuite name="defaults" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:19:19" time="2.112" tests="9">
    <testcase classname="defaults returns cached object if called multiple times" name="defaults returns cached object if called multiple times" time="0.02">
    </testcase>
    <testcase classname="defaults resolveSnapshotPath()" name="defaults resolveSnapshotPath()" time="0.005">
    </testcase>
    <testcase classname="defaults resolveTestPath()" name="defaults resolveTestPath()" time="0">
    </testcase>
    <testcase classname="custom resolver in project config returns cached object if called multiple times" name="custom resolver in project config returns cached object if called multiple times" time="0.32">
    </testcase>
    <testcase classname="custom resolver in project config resolveSnapshotPath()" name="custom resolver in project config resolveSnapshotPath()" time="0.001">
    </testcase>
    <testcase classname="custom resolver in project config resolveTestPath()" name="custom resolver in project config resolveTestPath()" time="0.001">
    </testcase>
    <testcase classname="malformed custom resolver in project config missing resolveSnapshotPath throws " name="malformed custom resolver in project config missing resolveSnapshotPath throws " time="0.13">
    </testcase>
    <testcase classname="malformed custom resolver in project config missing resolveTestPath throws " name="malformed custom resolver in project config missing resolveTestPath throws " time="0.094">
    </testcase>
    <testcase classname="malformed custom resolver in project config inconsistent functions throws " name="malformed custom resolver in project config inconsistent functions throws " time="0.117">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:19:21" time="3.369" tests="3">
    <testcase classname=" injects the serializable module map into each worker in watch mode" name=" injects the serializable module map into each worker in watch mode" time="0.018">
    </testcase>
    <testcase classname=" does not inject the serializable module map in serial mode" name=" does not inject the serializable module map in serial mode" time="0.006">
    </testcase>
    <testcase classname=" assign process.env.JEST_WORKER_ID = 1 when in runInBand mode" name=" assign process.env.JEST_WORKER_ID = 1 when in runInBand mode" time="0.006">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="1" timestamp="2018-12-19T21:19:25" time="0.869" tests="2">
    <testcase classname=" does not work on Windows" name=" does not work on Windows" time="0.03">
    </testcase>
    <testcase classname=" does not require project modules from inside node_modules" name=" does not require project modules from inside node_modules" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:19:26" time="5.977" tests="6">
    <testcase classname=" complains if the value is a primitive" name=" complains if the value is a primitive" time="0.018">
    </testcase>
    <testcase classname=" does not show the GC if hidden" name=" does not show the GC if hidden" time="0.559">
    </testcase>
    <testcase classname=" does not hide the GC if visible" name=" does not hide the GC if visible" time="0.227">
    </testcase>
    <testcase classname=" correctly checks simple leaks" name=" correctly checks simple leaks" time="0.437">
    </testcase>
    <testcase classname=" tests different objects" name=" tests different objects" time="2.835">
    </testcase>
    <testcase classname=" correctly checks more complex leaks" name=" correctly checks more complex leaks" time="1.166">
    </testcase>
  </testsuite>
  <testsuite name="test/it error throwing" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:19:32" time="2.3" tests="8">
    <testcase classname="test/it error throwing it doesn&apos;t throw an error with valid arguments" name="test/it error throwing it doesn&apos;t throw an error with valid arguments" time="0.003">
    </testcase>
    <testcase classname="test/it error throwing it throws error with missing callback function" name="test/it error throwing it throws error with missing callback function" time="0.001">
    </testcase>
    <testcase classname="test/it error throwing it throws an error when first argument isn&apos;t a string" name="test/it error throwing it throws an error when first argument isn&apos;t a string" time="0">
    </testcase>
    <testcase classname="test/it error throwing it throws an error when callback function is not a function" name="test/it error throwing it throws an error when callback function is not a function" time="0.001">
    </testcase>
    <testcase classname="test/it error throwing test doesn&apos;t throw an error with valid arguments" name="test/it error throwing test doesn&apos;t throw an error with valid arguments" time="0">
    </testcase>
    <testcase classname="test/it error throwing test throws error with missing callback function" name="test/it error throwing test throws error with missing callback function" time="0.001">
    </testcase>
    <testcase classname="test/it error throwing test throws an error when first argument isn&apos;t a string" name="test/it error throwing test throws an error when first argument isn&apos;t a string" time="0">
    </testcase>
    <testcase classname="test/it error throwing test throws an error when callback function is not a function" name="test/it error throwing test throws an error when callback function is not a function" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:19:34" time="0.699" tests="2">
    <testcase classname=" file path" name=" file path" time="0.024">
    </testcase>
    <testcase classname=" directory path" name=" directory path" time="0.042">
    </testcase>
  </testsuite>
  <testsuite name="collectCoverageFrom patterns" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:19:35" time="1.452" tests="3">
    <testcase classname="collectCoverageFrom patterns should apply collectCoverageFrom patterns coming from SearchSource" name="collectCoverageFrom patterns should apply collectCoverageFrom patterns coming from SearchSource" time="0.003">
    </testcase>
    <testcase classname="collectCoverageFrom patterns excludes coverage from files outside the global collectCoverageFrom config" name="collectCoverageFrom patterns excludes coverage from files outside the global collectCoverageFrom config" time="0.005">
    </testcase>
    <testcase classname="collectCoverageFrom patterns respects coveragePathIgnorePatterns" name="collectCoverageFrom patterns respects coveragePathIgnorePatterns" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="for multiline test name returns" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:19:36" time="0.454" tests="11">
    <testcase classname="for multiline test name returns test name with highlighted pattern and replaced line breaks" name="for multiline test name returns test name with highlighted pattern and replaced line breaks" time="0.005">
    </testcase>
    <testcase classname="for one line test name with pattern in the head returns test name with highlighted pattern" name="for one line test name with pattern in the head returns test name with highlighted pattern" time="0.002">
    </testcase>
    <testcase classname="for one line test name with pattern in the head returns test name with cutted tail and highlighted pattern" name="for one line test name with pattern in the head returns test name with cutted tail and highlighted pattern" time="0.001">
    </testcase>
    <testcase classname="for one line test name with pattern in the head returns test name with cutted tail and cutted highlighted pattern" name="for one line test name with pattern in the head returns test name with cutted tail and cutted highlighted pattern" time="0.002">
    </testcase>
    <testcase classname="for one line test name pattern in the middle test name with highlighted pattern returns" name="for one line test name pattern in the middle test name with highlighted pattern returns" time="0.002">
    </testcase>
    <testcase classname="for one line test name pattern in the middle test name with cutted tail and highlighted pattern" name="for one line test name pattern in the middle test name with cutted tail and highlighted pattern" time="0.001">
    </testcase>
    <testcase classname="for one line test name pattern in the middle test name with cutted tail and cutted highlighted pattern" name="for one line test name pattern in the middle test name with cutted tail and cutted highlighted pattern" time="0.001">
    </testcase>
    <testcase classname="for one line test name pattern in the middle test name with highlighted cutted" name="for one line test name pattern in the middle test name with highlighted cutted" time="0.005">
    </testcase>
    <testcase classname="for one line test name pattern in the tail returns test name with highlighted pattern" name="for one line test name pattern in the tail returns test name with highlighted pattern" time="0.001">
    </testcase>
    <testcase classname="for one line test name pattern in the tail returns test name with cutted tail and cutted highlighted pattern" name="for one line test name pattern in the tail returns test name with cutted tail and cutted highlighted pattern" time="0.001">
    </testcase>
    <testcase classname="for one line test name pattern in the tail returns test name with highlighted cutted" name="for one line test name pattern in the tail returns test name with highlighted cutted" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:19:37" time="0.317" tests="4">
    <testcase classname=" creates a snapshot summary" name=" creates a snapshot summary" time="0.003">
    </testcase>
    <testcase classname=" creates a snapshot summary after an update" name=" creates a snapshot summary after an update" time="0.002">
    </testcase>
    <testcase classname=" creates a snapshot summary with multiple snapshot being written/updated" name=" creates a snapshot summary with multiple snapshot being written/updated" time="0.002">
    </testcase>
    <testcase classname=" returns nothing if there are no updates" name=" returns nothing if there are no updates" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="3" timestamp="2018-12-19T21:19:37" time="0.34" tests="4">
    <testcase classname=" does not work on Jasmine" name=" does not work on Jasmine" time="0.005">
    </testcase>
    <testcase classname="Test Retries retries failed tests" name="Test Retries retries failed tests" time="0">
      <skipped/>
    </testcase>
    <testcase classname="Test Retries reporter shows more than 1 invocation if test is retried" name="Test Retries reporter shows more than 1 invocation if test is retried" time="0">
      <skipped/>
    </testcase>
    <testcase classname="Test Retries reporter shows 1 invocation if tests are not retried" name="Test Retries reporter shows 1 invocation if tests are not retried" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="WorkerPool" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:19:37" time="0.392" tests="2">
    <testcase classname="WorkerPool should create a ChildProcessWorker and send to it" name="WorkerPool should create a ChildProcessWorker and send to it" time="0.003">
    </testcase>
    <testcase classname="WorkerPool should create a NodeThreadWorker and send to it" name="WorkerPool should create a NodeThreadWorker and send to it" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:19:38" time="51.065" tests="3">
    <testcase classname=" exceeds the timeout set using jasmine.DEFAULT_TIMEOUT_INTERVAL" name=" exceeds the timeout set using jasmine.DEFAULT_TIMEOUT_INTERVAL" time="22.254">
    </testcase>
    <testcase classname=" does not exceed the timeout using jasmine.DEFAULT_TIMEOUT_INTERVAL" name=" does not exceed the timeout using jasmine.DEFAULT_TIMEOUT_INTERVAL" time="19.468">
    </testcase>
    <testcase classname=" can read and write jasmine.DEFAULT_TIMEOUT_INTERVAL" name=" can read and write jasmine.DEFAULT_TIMEOUT_INTERVAL" time="9.095">
    </testcase>
  </testsuite>
  <testsuite name="Using V8 implementation 0" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:20:29" time="0.596" tests="34">
    <testcase classname="Using V8 implementation 0 throws the error with an invalid serialization" name="Using V8 implementation 0 throws the error with an invalid serialization" time="0.004">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 0 serializes/deserializes in memory" name="Using V8 implementation 0 Object 0 serializes/deserializes in memory" time="0.001">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 0 serializes/deserializes in disk" name="Using V8 implementation 0 Object 0 serializes/deserializes in disk" time="0.002">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 1 serializes/deserializes in memory" name="Using V8 implementation 0 Object 1 serializes/deserializes in memory" time="0.001">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 1 serializes/deserializes in disk" name="Using V8 implementation 0 Object 1 serializes/deserializes in disk" time="0.004">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 2 serializes/deserializes in memory" name="Using V8 implementation 0 Object 2 serializes/deserializes in memory" time="0.001">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 2 serializes/deserializes in disk" name="Using V8 implementation 0 Object 2 serializes/deserializes in disk" time="0.008">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 3 serializes/deserializes in memory" name="Using V8 implementation 0 Object 3 serializes/deserializes in memory" time="0.001">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 3 serializes/deserializes in disk" name="Using V8 implementation 0 Object 3 serializes/deserializes in disk" time="0.008">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 4 serializes/deserializes in memory" name="Using V8 implementation 0 Object 4 serializes/deserializes in memory" time="0.001">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 4 serializes/deserializes in disk" name="Using V8 implementation 0 Object 4 serializes/deserializes in disk" time="0.007">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 5 serializes/deserializes in memory" name="Using V8 implementation 0 Object 5 serializes/deserializes in memory" time="0">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 5 serializes/deserializes in disk" name="Using V8 implementation 0 Object 5 serializes/deserializes in disk" time="0.007">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 6 serializes/deserializes in memory" name="Using V8 implementation 0 Object 6 serializes/deserializes in memory" time="0.001">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 6 serializes/deserializes in disk" name="Using V8 implementation 0 Object 6 serializes/deserializes in disk" time="0.011">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 7 serializes/deserializes in memory" name="Using V8 implementation 0 Object 7 serializes/deserializes in memory" time="0.004">
    </testcase>
    <testcase classname="Using V8 implementation 0 Object 7 serializes/deserializes in disk" name="Using V8 implementation 0 Object 7 serializes/deserializes in disk" time="0.008">
    </testcase>
    <testcase classname="Using V8 implementation 1 throws the error with an invalid serialization" name="Using V8 implementation 1 throws the error with an invalid serialization" time="0.004">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 0 serializes/deserializes in memory" name="Using V8 implementation 1 Object 0 serializes/deserializes in memory" time="0.004">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 0 serializes/deserializes in disk" name="Using V8 implementation 1 Object 0 serializes/deserializes in disk" time="0.003">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 1 serializes/deserializes in memory" name="Using V8 implementation 1 Object 1 serializes/deserializes in memory" time="0.001">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 1 serializes/deserializes in disk" name="Using V8 implementation 1 Object 1 serializes/deserializes in disk" time="0.003">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 2 serializes/deserializes in memory" name="Using V8 implementation 1 Object 2 serializes/deserializes in memory" time="0.001">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 2 serializes/deserializes in disk" name="Using V8 implementation 1 Object 2 serializes/deserializes in disk" time="0.009">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 3 serializes/deserializes in memory" name="Using V8 implementation 1 Object 3 serializes/deserializes in memory" time="0.001">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 3 serializes/deserializes in disk" name="Using V8 implementation 1 Object 3 serializes/deserializes in disk" time="0.007">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 4 serializes/deserializes in memory" name="Using V8 implementation 1 Object 4 serializes/deserializes in memory" time="0.001">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 4 serializes/deserializes in disk" name="Using V8 implementation 1 Object 4 serializes/deserializes in disk" time="0.011">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 5 serializes/deserializes in memory" name="Using V8 implementation 1 Object 5 serializes/deserializes in memory" time="0.001">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 5 serializes/deserializes in disk" name="Using V8 implementation 1 Object 5 serializes/deserializes in disk" time="0.007">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 6 serializes/deserializes in memory" name="Using V8 implementation 1 Object 6 serializes/deserializes in memory" time="0.003">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 6 serializes/deserializes in disk" name="Using V8 implementation 1 Object 6 serializes/deserializes in disk" time="0.018">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 7 serializes/deserializes in memory" name="Using V8 implementation 1 Object 7 serializes/deserializes in memory" time="0.001">
    </testcase>
    <testcase classname="Using V8 implementation 1 Object 7 serializes/deserializes in disk" name="Using V8 implementation 1 Object 7 serializes/deserializes in disk" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="check" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:20:30" time="1.341" tests="8">
    <testcase classname="check returns true if the arguments are valid" name="check returns true if the arguments are valid" time="0.002">
    </testcase>
    <testcase classname="check raises an exception if runInBand and maxWorkers are both specified" name="check raises an exception if runInBand and maxWorkers are both specified" time="0">
    </testcase>
    <testcase classname="check raises an exception if onlyChanged and watchAll are both specified" name="check raises an exception if onlyChanged and watchAll are both specified" time="0.001">
    </testcase>
    <testcase classname="check raises an exception when lastCommit and watchAll are both specified" name="check raises an exception when lastCommit and watchAll are both specified" time="0">
    </testcase>
    <testcase classname="check raises an exception if findRelatedTests is specified with no file paths" name="check raises an exception if findRelatedTests is specified with no file paths" time="0.001">
    </testcase>
    <testcase classname="check raises an exception if maxWorkers is specified with no number" name="check raises an exception if maxWorkers is specified with no number" time="0">
    </testcase>
    <testcase classname="check raises an exception if config is not a valid JSON string" name="check raises an exception if config is not a valid JSON string" time="0.001">
    </testcase>
    <testcase classname="buildArgv should return only camelcased args " name="buildArgv should return only camelcased args " time="0.144">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:20:31" time="30.345" tests="3">
    <testcase classname=" triggers unexpected token error message for non-JS assets" name=" triggers unexpected token error message for non-JS assets" time="5.978">
    </testcase>
    <testcase classname=" triggers unexpected token error message for untranspiled node_modules" name=" triggers unexpected token error message for untranspiled node_modules" time="5.224">
    </testcase>
    <testcase classname=" does not trigger unexpected token error message for regular syntax errors" name=" does not trigger unexpected token error message for regular syntax errors" time="18.93">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:21:02" time="55.627" tests="2">
    <testcase classname=" can press &quot;p&quot; to filter by file name" name=" can press &quot;p&quot; to filter by file name" time="27.236">
    </testcase>
    <testcase classname=" can press &quot;t&quot; to filter by test name" name=" can press &quot;t&quot; to filter by test name" time="27.655">
    </testcase>
  </testsuite>
  <testsuite name="iterators" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:21:57" time="0.578" tests="4">
    <testcase classname="iterators works for arrays" name="iterators works for arrays" time="0.008">
    </testcase>
    <testcase classname="iterators works for custom iterables" name="iterators works for custom iterables" time="0.007">
    </testcase>
    <testcase classname="iterators works for Sets" name="iterators works for Sets" time="0.003">
    </testcase>
    <testcase classname="iterators works for Maps" name="iterators works for Maps" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:21:58" time="0.658" tests="4">
    <testcase classname=" is valid when it is a file inside roots" name=" is valid when it is a file inside roots" time="0.003">
    </testcase>
    <testcase classname=" is not valid when it is a snapshot file" name=" is not valid when it is a snapshot file" time="0.002">
    </testcase>
    <testcase classname=" is not valid when it is a file in the coverage dir" name=" is not valid when it is a file in the coverage dir" time="0.001">
    </testcase>
    <testcase classname=" is not valid when it is a file match one of the watchPathIgnorePatterns" name=" is not valid when it is a file match one of the watchPathIgnorePatterns" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:21:59" time="1.956" tests="1">
    <testcase classname=" exits the process after test are done but before timers complete" name=" exits the process after test are done but before timers complete" time="1.309">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:22:01" time="28.284" tests="5">
    <testcase classname=" prints message about flag on slow tests" name=" prints message about flag on slow tests" time="8.455">
    </testcase>
    <testcase classname=" prints message about flag on forceExit" name=" prints message about flag on forceExit" time="3.775">
    </testcase>
    <testcase classname=" prints out info about open handlers" name=" prints out info about open handlers" time="5.008">
    </testcase>
    <testcase classname=" does not report promises" name=" does not report promises" time="5.002">
    </testcase>
    <testcase classname=" prints out info about open handlers from inside tests" name=" prints out info about open handlers from inside tests" time="5.514">
    </testcase>
  </testsuite>
  <testsuite name="Runtime" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:22:29" time="1.83" tests="4">
    <testcase classname="Runtime uses NODE_PATH to find modules" name="Runtime uses NODE_PATH to find modules" time="0.623">
    </testcase>
    <testcase classname="Runtime uses modulePaths to find modules" name="Runtime uses modulePaths to find modules" time="0.364">
    </testcase>
    <testcase classname="Runtime finds modules in NODE_PATH containing multiple paths" name="Runtime finds modules in NODE_PATH containing multiple paths" time="0.334">
    </testcase>
    <testcase classname="Runtime does not find modules if NODE_PATH is relative" name="Runtime does not find modules if NODE_PATH is relative" time="0.272">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:22:31" time="0.268" tests="2">
    <testcase classname=" normal output, everything goes to stdout" name=" normal output, everything goes to stdout" time="0.032">
    </testcase>
    <testcase classname=" when using stderr as output, no stdout call is made" name=" when using stderr as output, no stdout call is made" time="0.015">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="3" timestamp="2018-12-19T21:22:31" time="0.46" tests="4">
    <testcase classname=" does not work on Windows" name=" does not work on Windows" time="0.004">
    </testcase>
    <testcase classname=" beforeEach is executed before each test in current/child describe blocks" name=" beforeEach is executed before each test in current/child describe blocks" time="0.001">
      <skipped/>
    </testcase>
    <testcase classname=" multiple before each hooks in one describe are executed in the right order" name=" multiple before each hooks in one describe are executed in the right order" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" beforeAll is exectued correctly" name=" beforeAll is exectued correctly" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:22:32" time="19.681" tests="3">
    <testcase classname=" works with jest.config.js" name=" works with jest.config.js" time="9.468">
    </testcase>
    <testcase classname=" traverses directory tree up until it finds jest.config" name=" traverses directory tree up until it finds jest.config" time="9.026">
    </testcase>
    <testcase classname=" invalid JS in jest.config.js" name=" invalid JS in jest.config.js" time="0.754">
    </testcase>
  </testsuite>
  <testsuite name="expectationResultFactory" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:22:51" time="0.354" tests="5">
    <testcase classname="expectationResultFactory returns the result if passed." name="expectationResultFactory returns the result if passed." time="0.003">
    </testcase>
    <testcase classname="expectationResultFactory returns the result if failed." name="expectationResultFactory returns the result if failed." time="0.02">
    </testcase>
    <testcase classname="expectationResultFactory returns the result if failed (with `message`)." name="expectationResultFactory returns the result if failed (with `message`)." time="0.001">
    </testcase>
    <testcase classname="expectationResultFactory returns the result if failed (with `error`)." name="expectationResultFactory returns the result if failed (with `error`)." time="0.001">
    </testcase>
    <testcase classname="expectationResultFactory returns the result if failed (with `error` as a string)." name="expectationResultFactory returns the result if failed (with `error` as a string)." time="0">
    </testcase>
  </testsuite>
  <testsuite name="getCallsite" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:22:52" time="0.297" tests="3">
    <testcase classname="getCallsite without source map" name="getCallsite without source map" time="0.001">
    </testcase>
    <testcase classname="getCallsite ignores errors when fs throws" name="getCallsite ignores errors when fs throws" time="0.002">
    </testcase>
    <testcase classname="getCallsite reads source map file to determine line and column" name="getCallsite reads source map file to determine line and column" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:22:52" time="45.422" tests="8">
    <testcase classname=" suite without mock name, mock called" name=" suite without mock name, mock called" time="8.573">
    </testcase>
    <testcase classname=" suite without mock name, mock not called" name=" suite without mock name, mock not called" time="5.226">
    </testcase>
    <testcase classname=" suite with mock name, expect mock not called" name=" suite with mock name, expect mock not called" time="5.805">
    </testcase>
    <testcase classname=" suite with mock name, mock called, expect fail" name=" suite with mock name, mock called, expect fail" time="5.228">
    </testcase>
    <testcase classname=" suite with mock name, mock called 5 times" name=" suite with mock name, mock called 5 times" time="5.072">
    </testcase>
    <testcase classname=" suite with mock name, mock not called 5 times, expect fail" name=" suite with mock name, mock not called 5 times, expect fail" time="5.083">
    </testcase>
    <testcase classname=" suite with mock name, mock called" name=" suite with mock name, mock called" time="5.202">
    </testcase>
    <testcase classname=" suite with mock name, mock not called" name=" suite with mock name, mock not called" time="4.983">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:23:38" time="37.418" tests="7">
    <testcase classname=" works with passing tests" name=" works with passing tests" time="5.206">
    </testcase>
    <testcase classname=" shows error message when not enough arguments are supplied to tests" name=" shows error message when not enough arguments are supplied to tests" time="4.487">
    </testcase>
    <testcase classname=" shows the correct errors in stderr when failing tests" name=" shows the correct errors in stderr when failing tests" time="4.934">
    </testcase>
    <testcase classname=" shows only the tests with .only as being ran" name=" shows only the tests with .only as being ran" time="5.016">
    </testcase>
    <testcase classname=" shows only the tests without .skip as being ran" name=" shows only the tests without .skip as being ran" time="4.686">
    </testcase>
    <testcase classname=" runs only the describe.only.each tests" name=" runs only the describe.only.each tests" time="5.168">
    </testcase>
    <testcase classname=" formats args with pretty format when given %p" name=" formats args with pretty format when given %p" time="7.698">
    </testcase>
  </testsuite>
  <testsuite name="Runtime" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:24:15" time="1.728" tests="4">
    <testcase classname="Runtime jest.fn creates mock functions" name="Runtime jest.fn creates mock functions" time="0.919">
    </testcase>
    <testcase classname="Runtime jest.fn creates mock functions with mock implementations" name="Runtime jest.fn creates mock functions with mock implementations" time="0.289">
    </testcase>
    <testcase classname="Runtime jest.isMockFunction recognizes a mocked function" name="Runtime jest.isMockFunction recognizes a mocked function" time="0.104">
    </testcase>
    <testcase classname="Runtime jest.clearAllMocks clears all mocks" name="Runtime jest.clearAllMocks clears all mocks" time="0.062">
    </testcase>
  </testsuite>
  <testsuite name="fastPath.relative" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:24:17" time="0.226" tests="5">
    <testcase classname="fastPath.relative should get relative paths inside the root" name="fastPath.relative should get relative paths inside the root" time="0.001">
    </testcase>
    <testcase classname="fastPath.relative should get relative paths outside the root" name="fastPath.relative should get relative paths outside the root" time="0.001">
    </testcase>
    <testcase classname="fastPath.relative should get relative paths outside the root when start with same word" name="fastPath.relative should get relative paths outside the root when start with same word" time="0.001">
    </testcase>
    <testcase classname="fastPath.resolve should get the absolute path for paths inside the root" name="fastPath.resolve should get the absolute path for paths inside the root" time="0">
    </testcase>
    <testcase classname="fastPath.resolve should get the absolute path for paths outside the root" name="fastPath.resolve should get the absolute path for paths outside the root" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="3" timestamp="2018-12-19T21:24:17" time="0.202" tests="4">
    <testcase classname=" does not work on Windows" name=" does not work on Windows" time="0.001">
    </testcase>
    <testcase classname=" tests are not marked done until their parent afterAll runs" name=" tests are not marked done until their parent afterAll runs" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" describe block cannot have hooks and no tests" name=" describe block cannot have hooks and no tests" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" describe block _can_ have hooks if a child describe block has tests" name=" describe block _can_ have hooks if a child describe block has tests" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:24:17" time="20.707" tests="3">
    <testcase classname=" globalTeardown is triggered once after all test suites" name=" globalTeardown is triggered once after all test suites" time="9.318">
    </testcase>
    <testcase classname=" jest throws an error when globalTeardown does not export a function" name=" jest throws an error when globalTeardown does not export a function" time="7.498">
    </testcase>
    <testcase classname=" globalTeardown function gets jest config object as a parameter" name=" globalTeardown function gets jest config object as a parameter" time="3.632">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:24:38" time="9.986" tests="1">
    <testcase classname=" Tests are executed only once even in an MPR" name=" Tests are executed only once even in an MPR" time="9.553">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:24:48" time="11.083" tests="2">
    <testcase classname=" defaults to null for location" name=" defaults to null for location" time="4.845">
    </testcase>
    <testcase classname=" adds correct location info when provided with flag" name=" adds correct location info when provided with flag" time="6.004">
    </testcase>
  </testsuite>
  <testsuite name="replacePathSepForRegex()" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:24:59" time="0.745" tests="8">
    <testcase classname="replacePathSepForRegex() posix should return the path" name="replacePathSepForRegex() posix should return the path" time="0.002">
    </testcase>
    <testcase classname="replacePathSepForRegex() win32 should replace POSIX path separators" name="replacePathSepForRegex() win32 should replace POSIX path separators" time="0.002">
    </testcase>
    <testcase classname="replacePathSepForRegex() win32 should escape Windows path separators" name="replacePathSepForRegex() win32 should escape Windows path separators" time="0">
    </testcase>
    <testcase classname="replacePathSepForRegex() win32 should not escape an escaped dot" name="replacePathSepForRegex() win32 should not escape an escaped dot" time="0.002">
    </testcase>
    <testcase classname="replacePathSepForRegex() win32 should not escape an escaped regexp symbol" name="replacePathSepForRegex() win32 should not escape an escaped regexp symbol" time="0">
    </testcase>
    <testcase classname="replacePathSepForRegex() win32 should escape Windows path separators inside groups" name="replacePathSepForRegex() win32 should escape Windows path separators inside groups" time="0">
    </testcase>
    <testcase classname="replacePathSepForRegex() win32 should escape Windows path separator at the beginning" name="replacePathSepForRegex() win32 should escape Windows path separator at the beginning" time="0">
    </testcase>
    <testcase classname="replacePathSepForRegex() win32 should not escape several already escaped path separators" name="replacePathSepForRegex() win32 should not escape several already escaped path separators" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="No tests are found" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:25:00" time="13.462" tests="5">
    <testcase classname="No tests are found fails the test suite in standard situation" name="No tests are found fails the test suite in standard situation" time="2.66">
    </testcase>
    <testcase classname="No tests are found doesn&apos;t fail the test suite if --passWithNoTests passed" name="No tests are found doesn&apos;t fail the test suite if --passWithNoTests passed" time="2.174">
    </testcase>
    <testcase classname="No tests are found doesn&apos;t fail the test suite if using --lastCommit" name="No tests are found doesn&apos;t fail the test suite if using --lastCommit" time="2.773">
    </testcase>
    <testcase classname="No tests are found doesn&apos;t fail the test suite if using --onlyChanged" name="No tests are found doesn&apos;t fail the test suite if using --onlyChanged" time="3.136">
    </testcase>
    <testcase classname="No tests are found doesn&apos;t fail the test suite if using --findRelatedTests" name="No tests are found doesn&apos;t fail the test suite if using --findRelatedTests" time="2.301">
    </testcase>
  </testsuite>
  <testsuite name="setupFilesAfterEnv" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:25:14" time="24.121" tests="2">
    <testcase classname="setupFilesAfterEnv requires multiple setup files before each file in the suite" name="setupFilesAfterEnv requires multiple setup files before each file in the suite" time="13.802">
    </testcase>
    <testcase classname="setupFilesAfterEnv requires setup files *after* the test runners are required" name="setupFilesAfterEnv requires setup files *after* the test runners are required" time="9.824">
    </testcase>
  </testsuite>
  <testsuite name="Runtime" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:25:38" time="3.093" tests="4">
    <testcase classname="Runtime uses configured moduleDirectories" name="Runtime uses configured moduleDirectories" time="1.671">
    </testcase>
    <testcase classname="Runtime resolves packages" name="Runtime resolves packages" time="0.32">
    </testcase>
    <testcase classname="Runtime finds closest module from moduleDirectories" name="Runtime finds closest module from moduleDirectories" time="0.429">
    </testcase>
    <testcase classname="Runtime only checks the configured directories" name="Runtime only checks the configured directories" time="0.226">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:25:41" time="3.261" tests="8">
    <testcase classname=" works with resolves" name=" works with resolves" time="0.009">
    </testcase>
    <testcase classname=" works with promises" name=" works with promises" time="0.001">
    </testcase>
    <testcase classname=" works with async/await" name=" works with async/await" time="0.003">
    </testcase>
    <testcase classname=" works with async/await and resolves" name=" works with async/await and resolves" time="0.001">
    </testcase>
    <testcase classname=" tests error with rejects" name=" tests error with rejects" time="0.001">
    </testcase>
    <testcase classname=" tests error with promises" name=" tests error with promises" time="0.002">
    </testcase>
    <testcase classname=" tests error with async/await" name=" tests error with async/await" time="0.002">
    </testcase>
    <testcase classname=" tests error with async/await and rejects" name=" tests error with async/await and rejects" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:25:44" time="0.353" tests="2">
    <testcase classname=" Returns true when running on interactive environment" name=" Returns true when running on interactive environment" time="0.08">
    </testcase>
    <testcase classname=" Returns false when running on a non-interactive environment" name=" Returns false when running on a non-interactive environment" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:25:46" time="27.758" tests="5">
    <testcase classname=" renders correctly" name=" renders correctly" time="11.62">
    </testcase>
    <testcase classname=" renders the ActivityIndicator component" name=" renders the ActivityIndicator component" time="0.092">
    </testcase>
    <testcase classname=" renders the Image component" name=" renders the Image component" time="0.65">
    </testcase>
    <testcase classname=" renders the TextInput component" name=" renders the TextInput component" time="1.664">
    </testcase>
    <testcase classname=" renders the ListView component" name=" renders the ListView component" time="6.797">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:26:14" time="32.01" tests="4">
    <testcase classname=" console printing" name=" console printing" time="7.557">
    </testcase>
    <testcase classname=" console printing with --verbose" name=" console printing with --verbose" time="8.295">
    </testcase>
    <testcase classname=" does not print to console with --silent" name=" does not print to console with --silent" time="6.382">
    </testcase>
    <testcase classname=" the jsdom console is the same as the test console" name=" the jsdom console is the same as the test console" time="9.422">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:26:46" time="26.865" tests="5">
    <testcase classname=" config as JSON" name=" config as JSON" time="2.735">
    </testcase>
    <testcase classname=" works with sane config JSON" name=" works with sane config JSON" time="6.268">
    </testcase>
    <testcase classname=" watchman config option is respected over default argv" name=" watchman config option is respected over default argv" time="4.54">
    </testcase>
    <testcase classname=" config from argv is respected with sane config JSON" name=" config from argv is respected with sane config JSON" time="5.033">
    </testcase>
    <testcase classname=" works with jsdom testEnvironmentOptions config JSON" name=" works with jsdom testEnvironmentOptions config JSON" time="7.995">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:27:13" time="16.857" tests="3">
    <testcase classname=" globalSetup is triggered once before all test suites" name=" globalSetup is triggered once before all test suites" time="10.502">
    </testcase>
    <testcase classname=" jest throws an error when globalSetup does not export a function" name=" jest throws an error when globalSetup does not export a function" time="1.891">
    </testcase>
    <testcase classname=" globalSetup function gets jest config object as a parameter" name=" globalSetup function gets jest config object as a parameter" time="3.996">
    </testcase>
  </testsuite>
  <testsuite name="Runtime" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:27:30" time="1.192" tests="2">
    <testcase classname="Runtime genMockFromModule does not cause side effects in the rest of the module system when generating a mock" name="Runtime genMockFromModule does not cause side effects in the rest of the module system when generating a mock" time="0.592">
    </testcase>
    <testcase classname="Runtime creates mock objects in the right environment" name="Runtime creates mock objects in the right environment" time="0.232">
    </testcase>
  </testsuite>
  <testsuite name="test/it error throwing" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:27:31" time="0.319" tests="6">
    <testcase classname="test/it error throwing it throws error with missing callback function" name="test/it error throwing it throws error with missing callback function" time="0.002">
    </testcase>
    <testcase classname="test/it error throwing it throws an error when first argument isn&apos;t a string" name="test/it error throwing it throws an error when first argument isn&apos;t a string" time="0.001">
    </testcase>
    <testcase classname="test/it error throwing it throws an error when callback function is not a function" name="test/it error throwing it throws an error when callback function is not a function" time="0.001">
    </testcase>
    <testcase classname="test/it error throwing test throws error with missing callback function" name="test/it error throwing test throws error with missing callback function" time="0.001">
    </testcase>
    <testcase classname="test/it error throwing test throws an error when first argument isn&apos;t a string" name="test/it error throwing test throws an error when first argument isn&apos;t a string" time="0.002">
    </testcase>
    <testcase classname="test/it error throwing test throws an error when callback function is not a function" name="test/it error throwing test throws an error when callback function is not a function" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="FailedTestsCache" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:27:32" time="0.242" tests="1">
    <testcase classname="FailedTestsCache should filter tests" name="FailedTestsCache should filter tests" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="4" timestamp="2018-12-19T21:27:32" time="0.256" tests="5">
    <testcase classname=" does not work on Windows" name=" does not work on Windows" time="0.002">
    </testcase>
    <testcase classname="Runtime cli fails with no path" name="Runtime cli fails with no path" time="0">
      <skipped/>
    </testcase>
    <testcase classname="Runtime cli displays script output" name="Runtime cli displays script output" time="0">
      <skipped/>
    </testcase>
    <testcase classname="Runtime cli always disables automocking" name="Runtime cli always disables automocking" time="0">
      <skipped/>
    </testcase>
    <testcase classname="Runtime cli throws script errors" name="Runtime cli throws script errors" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:27:32" time="11.316" tests="1">
    <testcase classname=" can press &quot;u&quot; to update snapshots" name=" can press &quot;u&quot; to update snapshots" time="11.03">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:27:44" time="123.394" tests="24">
    <testcase classname=" fail.test.js errors in errorOnDeprecated mode" name=" fail.test.js errors in errorOnDeprecated mode" time="5.621">
    </testcase>
    <testcase classname=" jasmine.addMatchers.test.js errors in errorOnDeprecated mode" name=" jasmine.addMatchers.test.js errors in errorOnDeprecated mode" time="4.844">
    </testcase>
    <testcase classname=" jasmine.any.test.js errors in errorOnDeprecated mode" name=" jasmine.any.test.js errors in errorOnDeprecated mode" time="5.474">
    </testcase>
    <testcase classname=" jasmine.anything.test.js errors in errorOnDeprecated mode" name=" jasmine.anything.test.js errors in errorOnDeprecated mode" time="5.085">
    </testcase>
    <testcase classname=" jasmine.arrayContaining.test.js errors in errorOnDeprecated mode" name=" jasmine.arrayContaining.test.js errors in errorOnDeprecated mode" time="5.333">
    </testcase>
    <testcase classname=" jasmine.createSpy.test.js errors in errorOnDeprecated mode" name=" jasmine.createSpy.test.js errors in errorOnDeprecated mode" time="4.98">
    </testcase>
    <testcase classname=" jasmine.objectContaining.test.js errors in errorOnDeprecated mode" name=" jasmine.objectContaining.test.js errors in errorOnDeprecated mode" time="5.023">
    </testcase>
    <testcase classname=" jasmine.stringMatching.test.js errors in errorOnDeprecated mode" name=" jasmine.stringMatching.test.js errors in errorOnDeprecated mode" time="5.187">
    </testcase>
    <testcase classname=" pending.test.js errors in errorOnDeprecated mode" name=" pending.test.js errors in errorOnDeprecated mode" time="5.661">
    </testcase>
    <testcase classname=" spyOn.test.js errors in errorOnDeprecated mode" name=" spyOn.test.js errors in errorOnDeprecated mode" time="4.996">
    </testcase>
    <testcase classname=" spyOnProperty.test.js errors in errorOnDeprecated mode" name=" spyOnProperty.test.js errors in errorOnDeprecated mode" time="4.933">
    </testcase>
    <testcase classname=" DEFAULT_TIMEOUT_INTERVAL.test.js errors in errorOnDeprecated mode" name=" DEFAULT_TIMEOUT_INTERVAL.test.js errors in errorOnDeprecated mode" time="4.93">
    </testcase>
    <testcase classname=" fail.test.js errors when not in errorOnDeprecated mode" name=" fail.test.js errors when not in errorOnDeprecated mode" time="5.34">
    </testcase>
    <testcase classname=" jasmine.addMatchers.test.js passes when not in errorOnDeprecated mode" name=" jasmine.addMatchers.test.js passes when not in errorOnDeprecated mode" time="5.027">
    </testcase>
    <testcase classname=" jasmine.any.test.js passes when not in errorOnDeprecated mode" name=" jasmine.any.test.js passes when not in errorOnDeprecated mode" time="5.129">
    </testcase>
    <testcase classname=" jasmine.anything.test.js passes when not in errorOnDeprecated mode" name=" jasmine.anything.test.js passes when not in errorOnDeprecated mode" time="5.128">
    </testcase>
    <testcase classname=" jasmine.arrayContaining.test.js passes when not in errorOnDeprecated mode" name=" jasmine.arrayContaining.test.js passes when not in errorOnDeprecated mode" time="5.053">
    </testcase>
    <testcase classname=" jasmine.createSpy.test.js passes when not in errorOnDeprecated mode" name=" jasmine.createSpy.test.js passes when not in errorOnDeprecated mode" time="5.112">
    </testcase>
    <testcase classname=" jasmine.objectContaining.test.js passes when not in errorOnDeprecated mode" name=" jasmine.objectContaining.test.js passes when not in errorOnDeprecated mode" time="5.04">
    </testcase>
    <testcase classname=" jasmine.stringMatching.test.js passes when not in errorOnDeprecated mode" name=" jasmine.stringMatching.test.js passes when not in errorOnDeprecated mode" time="4.997">
    </testcase>
    <testcase classname=" pending.test.js passes when not in errorOnDeprecated mode" name=" pending.test.js passes when not in errorOnDeprecated mode" time="5.168">
    </testcase>
    <testcase classname=" spyOn.test.js passes when not in errorOnDeprecated mode" name=" spyOn.test.js passes when not in errorOnDeprecated mode" time="4.929">
    </testcase>
    <testcase classname=" spyOnProperty.test.js errors when not in errorOnDeprecated mode" name=" spyOnProperty.test.js errors when not in errorOnDeprecated mode" time="5.213">
    </testcase>
    <testcase classname=" DEFAULT_TIMEOUT_INTERVAL.test.js passes when not in errorOnDeprecated mode" name=" DEFAULT_TIMEOUT_INTERVAL.test.js passes when not in errorOnDeprecated mode" time="4.935">
    </testcase>
  </testsuite>
  <testsuite name="Runtime" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:29:47" time="0.923" tests="2">
    <testcase classname="Runtime requireModule emulates a node stack trace during module load" name="Runtime requireModule emulates a node stack trace during module load" time="0.608">
    </testcase>
    <testcase classname="Runtime requireModule emulates a node stack trace during function execution" name="Runtime requireModule emulates a node stack trace during function execution" time="0.094">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:29:48" time="0.221" tests="4">
    <testcase classname=" maps special values to valid options" name=" maps special values to valid options" time="0.001">
    </testcase>
    <testcase classname=" maps regular values to themselves" name=" maps regular values to themselves" time="0">
    </testcase>
    <testcase classname=" works with string objects" name=" works with string objects" time="0.001">
    </testcase>
    <testcase classname=" explicit flags override those from --config" name=" explicit flags override those from --config" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:29:48" time="13.18" tests="1">
    <testcase classname=" can press &quot;f&quot; to run only failed tests" name=" can press &quot;f&quot; to run only failed tests" time="12.958">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:30:02" time="15.083" tests="2">
    <testcase classname=" exceeds the timeout" name=" exceeds the timeout" time="7.393">
    </testcase>
    <testcase classname=" does not exceed the timeout" name=" does not exceed the timeout" time="7.287">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:30:17" time="0.512" tests="3">
    <testcase classname=" calls handler on change value" name=" calls handler on change value" time="0.01">
    </testcase>
    <testcase classname=" calls handler on success prompt" name=" calls handler on success prompt" time="0.002">
    </testcase>
    <testcase classname=" calls handler on cancel prompt" name=" calls handler on cancel prompt" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="ConvertAnsi plugin" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:30:17" time="0.278" tests="6">
    <testcase classname="ConvertAnsi plugin supports style.red" name="ConvertAnsi plugin supports style.red" time="0.002">
    </testcase>
    <testcase classname="ConvertAnsi plugin supports style.green" name="ConvertAnsi plugin supports style.green" time="0.005">
    </testcase>
    <testcase classname="ConvertAnsi plugin supports style.reset" name="ConvertAnsi plugin supports style.reset" time="0">
    </testcase>
    <testcase classname="ConvertAnsi plugin supports style.bold" name="ConvertAnsi plugin supports style.bold" time="0">
    </testcase>
    <testcase classname="ConvertAnsi plugin supports style.dim" name="ConvertAnsi plugin supports style.dim" time="0.001">
    </testcase>
    <testcase classname="ConvertAnsi plugin does not support other colors" name="ConvertAnsi plugin does not support other colors" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:30:18" time="0.324" tests="5">
    <testcase classname=" return a list of path" name=" return a list of path" time="0.002">
    </testcase>
    <testcase classname=" handle missing snapshot object" name=" handle missing snapshot object" time="0.001">
    </testcase>
    <testcase classname=" handle missing testResults object" name=" handle missing testResults object" time="0.001">
    </testcase>
    <testcase classname=" return empty if not failed tests" name=" return empty if not failed tests" time="0.001">
    </testcase>
    <testcase classname=" return empty if not failed snapshot tests" name=" return empty if not failed snapshot tests" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:30:18" time="0.286" tests="3">
    <testcase classname=" stack trace points to correct location when using matchers" name=" stack trace points to correct location when using matchers" time="0.004">
    </testcase>
    <testcase classname=" stack trace points to correct location when using nested matchers" name=" stack trace points to correct location when using nested matchers" time="0.034">
    </testcase>
    <testcase classname=" stack trace points to correct location when throwing from a custom matcher" name=" stack trace points to correct location when throwing from a custom matcher" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="2" timestamp="2018-12-19T21:30:18" time="0.263" tests="3">
    <testcase classname=" does not work on Windows" name=" does not work on Windows" time="0.004">
    </testcase>
    <testcase classname=" CLI accepts exact file names if matchers matched" name=" CLI accepts exact file names if matchers matched" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" CLI skips exact file names if no matchers matched" name=" CLI skips exact file names if no matchers matched" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="pTimeout" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:30:19" time="0.242" tests="3">
    <testcase classname="pTimeout calls `clearTimeout` and resolves when `promise` resolves." name="pTimeout calls `clearTimeout` and resolves when `promise` resolves." time="0.002">
    </testcase>
    <testcase classname="pTimeout calls `clearTimeout` and rejects when `promise` rejects." name="pTimeout calls `clearTimeout` and rejects when `promise` rejects." time="0.001">
    </testcase>
    <testcase classname="pTimeout calls `onTimeout` on timeout." name="pTimeout calls `onTimeout` on timeout." time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:30:19" time="15.16" tests="1">
    <testcase classname=" understands dependencies using jest.requireActual" name=" understands dependencies using jest.requireActual" time="14.773">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:30:34" time="14.319" tests="1">
    <testcase classname=" understands dependencies using jest.requireMock" name=" understands dependencies using jest.requireMock" time="14.059">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:30:49" time="6.863" tests="2">
    <testcase classname=" works with passing tests" name=" works with passing tests" time="5.593">
    </testcase>
    <testcase classname=" throws error for unknown dashed &amp; camelcase args" name=" throws error for unknown dashed &amp; camelcase args" time="0.786">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:30:56" time="0.645" tests="2">
    <testcase classname=" resolves to the result of generateEmptyCoverage upon success" name=" resolves to the result of generateEmptyCoverage upon success" time="0.317">
    </testcase>
    <testcase classname=" throws errors on invalid JavaScript" name=" throws errors on invalid JavaScript" time="0.019">
    </testcase>
  </testsuite>
  <testsuite name="isError" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:30:56" time="0.267" tests="4">
    <testcase classname="isError should not assume objects are errors" name="isError should not assume objects are errors" time="0.002">
    </testcase>
    <testcase classname="isError should detect simple error instances" name="isError should detect simple error instances" time="0.001">
    </testcase>
    <testcase classname="isError should detect errors from another context" name="isError should detect errors from another context" time="0.029">
    </testcase>
    <testcase classname="isError should detect DOMException errors from another context" name="isError should detect DOMException errors from another context" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="Runtime" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:30:57" time="1.417" tests="2">
    <testcase classname="Runtime jest.spyOn calls the original function" name="Runtime jest.spyOn calls the original function" time="1.082">
    </testcase>
    <testcase classname="Runtime jest.spyOnProperty calls the original function" name="Runtime jest.spyOnProperty calls the original function" time="0.102">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:30:58" time="14.753" tests="1">
    <testcase classname=" runs tests by exact path" name=" runs tests by exact path" time="14.5">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:31:13" time="0.335" tests="5">
    <testcase classname=" When offset is -1" name=" When offset is -1" time="0.001">
    </testcase>
    <testcase classname=" When offset is in the first set of items" name=" When offset is in the first set of items" time="0.001">
    </testcase>
    <testcase classname=" When offset is in the middle of the list" name=" When offset is in the middle of the list" time="0.006">
    </testcase>
    <testcase classname=" When offset is at the end of the list" name=" When offset is at the end of the list" time="0.001">
    </testcase>
    <testcase classname=" When offset is at the end and size is smaller than max" name=" When offset is at the end and size is smaller than max" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:31:13" time="0.68" tests="3">
    <testcase classname=" throw matcher can take func" name=" throw matcher can take func" time="0.002">
    </testcase>
    <testcase classname="throw matcher from promise can take error" name="throw matcher from promise can take error" time="0.001">
    </testcase>
    <testcase classname="throw matcher from promise can take custom error" name="throw matcher from promise can take custom error" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="timerGame" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:31:14" time="2.067" tests="3">
    <testcase classname="timerGame waits 1 second before ending the game" name="timerGame waits 1 second before ending the game" time="0.055">
    </testcase>
    <testcase classname="timerGame calls the callback after 1 second via runAllTimers" name="timerGame calls the callback after 1 second via runAllTimers" time="0.005">
    </testcase>
    <testcase classname="timerGame calls the callback after 1 second via advanceTimersByTime" name="timerGame calls the callback after 1 second via advanceTimersByTime" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="1" timestamp="2018-12-19T21:31:16" time="0.229" tests="2">
    <testcase classname=" does not work on Windows" name=" does not work on Windows" time="0.003">
    </testcase>
    <testcase classname=" --showConfig outputs config info and exits" name=" --showConfig outputs config info and exits" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="Snapshot serializers" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:31:16" time="12.746" tests="2">
    <testcase classname="Snapshot serializers renders snapshot" name="Snapshot serializers renders snapshot" time="4.084">
    </testcase>
    <testcase classname="Snapshot serializers compares snapshots correctly" name="Snapshot serializers compares snapshots correctly" time="8.445">
    </testcase>
  </testsuite>
  <testsuite name="getMaxWorkers" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:31:29" time="0.266" tests="7">
    <testcase classname="getMaxWorkers Returns 1 when runInBand" name="getMaxWorkers Returns 1 when runInBand" time="0.001">
    </testcase>
    <testcase classname="getMaxWorkers Returns 1 when the OS CPUs are not available" name="getMaxWorkers Returns 1 when the OS CPUs are not available" time="0.001">
    </testcase>
    <testcase classname="getMaxWorkers Returns the `maxWorkers` when specified" name="getMaxWorkers Returns the `maxWorkers` when specified" time="0.001">
    </testcase>
    <testcase classname="getMaxWorkers Returns based on the number of cpus" name="getMaxWorkers Returns based on the number of cpus" time="0.001">
    </testcase>
    <testcase classname="getMaxWorkers % based 50% = 2 workers" name="getMaxWorkers % based 50% = 2 workers" time="0.001">
    </testcase>
    <testcase classname="getMaxWorkers % based &lt; 0 workers should become 1" name="getMaxWorkers % based &lt; 0 workers should become 1" time="0">
    </testcase>
    <testcase classname="getMaxWorkers % based 0% shouldn&apos;t break" name="getMaxWorkers % based 0% shouldn&apos;t break" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="4" timestamp="2018-12-19T21:31:30" time="0.382" tests="5">
    <testcase classname=" does not work on Jasmine" name=" does not work on Jasmine" time="0.003">
    </testcase>
    <testcase classname=" hook in empty describe" name=" hook in empty describe" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" hook in describe with skipped test" name=" hook in describe with skipped test" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" hook in empty nested describe" name=" hook in empty nested describe" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" multiple hooks in empty describe" name=" multiple hooks in empty describe" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:31:30" time="2.183" tests="2">
    <testcase classname=" calls into $.ajax with the correct params" name=" calls into $.ajax with the correct params" time="0.186">
    </testcase>
    <testcase classname=" calls the callback when $.ajax requests are finished" name=" calls the callback when $.ajax requests are finished" time="0.029">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:31:32" time="21.785" tests="4">
    <testcase classname=" works with all statuses" name=" works with all statuses" time="5.779">
    </testcase>
    <testcase classname=" shows error messages when called with no arguments" name=" shows error messages when called with no arguments" time="5.565">
    </testcase>
    <testcase classname=" shows error messages when called with multiple arguments" name=" shows error messages when called with multiple arguments" time="5.011">
    </testcase>
    <testcase classname=" shows error messages when called with invalid argument" name=" shows error messages when called with invalid argument" time="5.048">
    </testcase>
  </testsuite>
  <testsuite name="Runtime" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:31:54" time="1.424" tests="2">
    <testcase classname="Runtime internalModule loads modules and applies transforms" name="Runtime internalModule loads modules and applies transforms" time="0.481">
    </testcase>
    <testcase classname="Runtime internalModule loads internal modules without applying transforms" name="Runtime internalModule loads internal modules without applying transforms" time="0.521">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:31:56" time="0.374" tests="3">
    <testcase classname=" Retrieves the snapshot status" name=" Retrieves the snapshot status" time="0.004">
    </testcase>
    <testcase classname=" Shows no snapshot updates if all snapshots matched" name=" Shows no snapshot updates if all snapshots matched" time="0.002">
    </testcase>
    <testcase classname=" Retrieves the snapshot status after a snapshot update" name=" Retrieves the snapshot status after a snapshot update" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="Dynamic test filtering" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:31:56" time="31.101" tests="4">
    <testcase classname="Dynamic test filtering uses the default JSON option" name="Dynamic test filtering uses the default JSON option" time="9.021">
    </testcase>
    <testcase classname="Dynamic test filtering uses the CLI option" name="Dynamic test filtering uses the CLI option" time="8.654">
    </testcase>
    <testcase classname="Dynamic test filtering ingores the filter if requested to do so" name="Dynamic test filtering ingores the filter if requested to do so" time="10.999">
    </testcase>
    <testcase classname="Dynamic test filtering throws when you return clowny stuff" name="Dynamic test filtering throws when you return clowny stuff" time="2.148">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:32:27" time="11.627" tests="1">
    <testcase classname=" exits the process after test are done but before timers complete" name=" exits the process after test are done but before timers complete" time="11.146">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:32:39" time="8.756" tests="2">
    <testcase classname=" show error message with matching files" name=" show error message with matching files" time="7.637">
    </testcase>
    <testcase classname=" show error message when no js moduleFileExtensions" name=" show error message when no js moduleFileExtensions" time="0.849">
    </testcase>
  </testsuite>
  <testsuite name="NodeEnvironment" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:32:48" time="0.578" tests="4">
    <testcase classname="NodeEnvironment uses a copy of the process object" name="NodeEnvironment uses a copy of the process object" time="0.008">
    </testcase>
    <testcase classname="NodeEnvironment exposes process.on" name="NodeEnvironment exposes process.on" time="0.004">
    </testcase>
    <testcase classname="NodeEnvironment exposes global.global" name="NodeEnvironment exposes global.global" time="0.003">
    </testcase>
    <testcase classname="NodeEnvironment should configure setTimeout/setInterval to use the node api" name="NodeEnvironment should configure setTimeout/setInterval to use the node api" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:32:48" time="36.353" tests="1">
    <testcase classname=" code coverage for transform instrumented code" name=" code coverage for transform instrumented code" time="36.095">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:33:25" time="2.772" tests="4">
    <testcase classname=" renders correctly" name=" renders correctly" time="0.03">
    </testcase>
    <testcase classname=" renders as an anchor when no page is set" name=" renders as an anchor when no page is set" time="0.002">
    </testcase>
    <testcase classname=" properly escapes quotes" name=" properly escapes quotes" time="0.002">
    </testcase>
    <testcase classname=" changes the class when hovered" name=" changes the class when hovered" time="0.006">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:33:28" time="9.44" tests="1">
    <testcase classname=" maps code coverage against original source" name=" maps code coverage against original source" time="9.195">
    </testcase>
  </testsuite>
  <testsuite name="--listTests flag" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:33:37" time="4.508" tests="2">
    <testcase classname="--listTests flag causes tests to be printed in different lines" name="--listTests flag causes tests to be printed in different lines" time="2.411">
    </testcase>
    <testcase classname="--listTests flag causes tests to be printed out as JSON when using the --json flag" name="--listTests flag causes tests to be printed out as JSON when using the --json flag" time="1.752">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:33:42" time="0.234" tests="4">
    <testcase classname=" should remove jest config if exists" name=" should remove jest config if exists" time="0.002">
    </testcase>
    <testcase classname=" should add test script when there are no scripts" name=" should add test script when there are no scripts" time="0.001">
    </testcase>
    <testcase classname=" should add test script when there are scripts" name=" should add test script when there are scripts" time="0">
    </testcase>
    <testcase classname=" should not add test script when { shouldModifyScripts: false }" name=" should not add test script when { shouldModifyScripts: false }" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="define mock per test" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:33:42" time="1.896" tests="2">
    <testcase classname="define mock per test uses mocked module" name="define mock per test uses mocked module" time="0.008">
    </testcase>
    <testcase classname="define mock per test uses actual module" name="define mock per test uses actual module" time="0.054">
    </testcase>
  </testsuite>
  <testsuite name="Runtime" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:33:44" time="0.694" tests="1">
    <testcase classname="Runtime requireModule installs source maps if available" name="Runtime requireModule installs source maps if available" time="0.475">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:33:45" time="37.352" tests="1">
    <testcase classname=" prints a message with path pattern at the end" name=" prints a message with path pattern at the end" time="37.101">
    </testcase>
  </testsuite>
  <testsuite name="Jasmine2Reporter" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:34:22" time="0.372" tests="1">
    <testcase classname="Jasmine2Reporter reports nested suites" name="Jasmine2Reporter reports nested suites" time="0.006">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:34:22" time="1.328" tests="1">
    <testcase classname=" Returns source string with inline maps when no transformOptions is passed" name=" Returns source string with inline maps when no transformOptions is passed" time="0.209">
    </testcase>
  </testsuite>
  <testsuite name="test/it.todo error throwing" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:34:24" time="0.246" tests="3">
    <testcase classname="test/it.todo error throwing todo throws error when given no arguments" name="test/it.todo error throwing todo throws error when given no arguments" time="0.001">
    </testcase>
    <testcase classname="test/it.todo error throwing todo throws error when given more than one argument" name="test/it.todo error throwing todo throws error when given more than one argument" time="0.001">
    </testcase>
    <testcase classname="test/it.todo error throwing todo throws error when given none string description" name="test/it.todo error throwing todo throws error when given none string description" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="Runtime Internal Module Registry" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:34:24" time="5.556" tests="1">
    <testcase classname="Runtime Internal Module Registry correctly makes use of internal module registry when requiring modules" name="Runtime Internal Module Registry correctly makes use of internal module registry when requiring modules" time="5.34">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:34:30" time="14.377" tests="1">
    <testcase classname=" exits with a specified code when test fail" name=" exits with a specified code when test fail" time="14.131">
    </testcase>
  </testsuite>
  <testsuite name="Custom snapshot resolver" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:34:44" time="5.279" tests="1">
    <testcase classname="Custom snapshot resolver Resolves snapshot files using custom resolver" name="Custom snapshot resolver Resolves snapshot files using custom resolver" time="4.836">
    </testcase>
  </testsuite>
  <testsuite name="Symbol in objects" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:34:49" time="0.232" tests="3">
    <testcase classname="Symbol in objects should compare objects with Symbol keys" name="Symbol in objects should compare objects with Symbol keys" time="0.002">
    </testcase>
    <testcase classname="Symbol in objects should compare objects with mixed keys and Symbol" name="Symbol in objects should compare objects with mixed keys and Symbol" time="0.001">
    </testcase>
    <testcase classname="Symbol in objects should compare objects with different Symbol keys" name="Symbol in objects should compare objects with different Symbol keys" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:34:50" time="0.259" tests="3">
    <testcase classname=" prints the jest version" name=" prints the jest version" time="0.002">
    </testcase>
    <testcase classname=" prints the test framework name" name=" prints the test framework name" time="0.001">
    </testcase>
    <testcase classname=" prints the config object" name=" prints the config object" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:34:50" time="8.51" tests="1">
    <testcase classname=" no tests found message is redirected to stderr" name=" no tests found message is redirected to stderr" time="8.242">
    </testcase>
  </testsuite>
  <testsuite name=".getType()" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:34:59" time="0.518" tests="13">
    <testcase classname=".getType() null" name=".getType() null" time="0.001">
    </testcase>
    <testcase classname=".getType() undefined" name=".getType() undefined" time="0">
    </testcase>
    <testcase classname=".getType() object" name=".getType() object" time="0.002">
    </testcase>
    <testcase classname=".getType() array" name=".getType() array" time="0.005">
    </testcase>
    <testcase classname=".getType() number" name=".getType() number" time="0">
    </testcase>
    <testcase classname=".getType() string" name=".getType() string" time="0.001">
    </testcase>
    <testcase classname=".getType() function" name=".getType() function" time="0">
    </testcase>
    <testcase classname=".getType() boolean" name=".getType() boolean" time="0">
    </testcase>
    <testcase classname=".getType() symbol" name=".getType() symbol" time="0">
    </testcase>
    <testcase classname=".getType() regexp" name=".getType() regexp" time="0.001">
    </testcase>
    <testcase classname=".getType() map" name=".getType() map" time="0">
    </testcase>
    <testcase classname=".getType() set" name=".getType() set" time="0.001">
    </testcase>
    <testcase classname=".getType() date" name=".getType() date" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:34:59" time="0.583" tests="1">
    <testcase classname=" generates an empty coverage object for a file without running it" name=" generates an empty coverage object for a file without running it" time="0.211">
    </testcase>
  </testsuite>
  <testsuite name=".assertions()" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:00" time="0.231" tests="6">
    <testcase classname=".assertions() does not throw" name=".assertions() does not throw" time="0.002">
    </testcase>
    <testcase classname=".assertions() redeclares different assertion count" name=".assertions() redeclares different assertion count" time="0">
    </testcase>
    <testcase classname=".assertions() expects no assertions" name=".assertions() expects no assertions" time="0.001">
    </testcase>
    <testcase classname=".hasAssertions() does not throw if there is an assertion" name=".hasAssertions() does not throw if there is an assertion" time="0.001">
    </testcase>
    <testcase classname=".hasAssertions() throws if passed parameters" name=".hasAssertions() throws if passed parameters" time="0.001">
    </testcase>
    <testcase classname=".hasAssertions() hasAssertions not leaking to global state" name=".hasAssertions() hasAssertions not leaking to global state" time="0">
    </testcase>
  </testsuite>
  <testsuite name="Environment override" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:00" time="17.77" tests="4">
    <testcase classname="Environment override uses jsdom when specified" name="Environment override uses jsdom when specified" time="7.783">
    </testcase>
    <testcase classname="Environment override uses node as default from package.json" name="Environment override uses node as default from package.json" time="5.017">
    </testcase>
    <testcase classname="Environment override uses node when specified" name="Environment override uses node when specified" time="3.904">
    </testcase>
    <testcase classname="Environment override fails when the env is not available" name="Environment override fails when the env is not available" time="0.841">
    </testcase>
  </testsuite>
  <testsuite name="jest --clearCache" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:18" time="7.759" tests="2">
    <testcase classname="jest --clearCache normal run results in cache directory being written" name="jest --clearCache normal run results in cache directory being written" time="6.232">
    </testcase>
    <testcase classname="jest --clearCache clearCache results in deleted directory and exit status 0" name="jest --clearCache clearCache results in deleted directory and exit status 0" time="1.116">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:26" time="0.386" tests="1">
    <testcase classname=" displays a user after a click" name=" displays a user after a click" time="0.104">
    </testcase>
  </testsuite>
  <testsuite name="resolve" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:26" time="1.019" tests="2">
    <testcase classname="resolve respects &quot;browser&quot; dependency when browser:true configured" name="resolve respects &quot;browser&quot; dependency when browser:true configured" time="0.484">
    </testcase>
    <testcase classname="resolve doesn&apos;t resolve &quot;browser&quot; dependency by default" name="resolve doesn&apos;t resolve &quot;browser&quot; dependency by default" time="0.269">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:27" time="0.462" tests="2">
    <testcase classname=" returns the passed object" name=" returns the passed object" time="0.129">
    </testcase>
    <testcase classname=" turns a V8 global object into a Node global object" name=" turns a V8 global object into a Node global object" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:28" time="0.412" tests="3">
    <testcase classname=" validates yargs special options" name=" validates yargs special options" time="0.003">
    </testcase>
    <testcase classname=" fails for unknown option" name=" fails for unknown option" time="0.005">
    </testcase>
    <testcase classname=" fails for multiple unknown options" name=" fails for multiple unknown options" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:28" time="0.612" tests="1">
    <testcase classname=" instruments files" name=" instruments files" time="0.086">
    </testcase>
  </testsuite>
  <testsuite name="runJest" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:29" time="0.581" tests="2">
    <testcase classname="runJest when watch is set then exit process" name="runJest when watch is set then exit process" time="0.009">
    </testcase>
    <testcase classname="runJest when watch is set then an error message is printed" name="runJest when watch is set then an error message is printed" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:30" time="8.751" tests="1">
    <testcase classname=" prints console.logs when run with forceExit" name=" prints console.logs when run with forceExit" time="8.488">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="2" timestamp="2018-12-19T21:35:38" time="0.272" tests="3">
    <testcase classname=" does not work on Windows" name=" does not work on Windows" time="0.003">
    </testcase>
    <testcase classname=" simple test" name=" simple test" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" failures" name=" failures" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:39" time="0.28" tests="1">
    <testcase classname=" schedules a 10-second timer after 1 second" name=" schedules a 10-second timer after 1 second" time="0.072">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:39" time="0.23" tests="1">
    <testcase classname=" does a partial mock" name=" does a partial mock" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:39" time="12.608" tests="2">
    <testcase classname=" works with passing tests" name=" works with passing tests" time="6.779">
    </testcase>
    <testcase classname=" shows the correct errors in stderr when failing tests" name=" shows the correct errors in stderr when failing tests" time="5.549">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:52" time="0.844" tests="1">
    <testcase classname=" works with jest.config.js" name=" works with jest.config.js" time="0.632">
    </testcase>
  </testsuite>
  <testsuite name="Coverage Report" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:53" time="5.221" tests="2">
    <testcase classname="Coverage Report outputs coverage report" name="Coverage Report outputs coverage report" time="2.303">
    </testcase>
    <testcase classname="File path not found in mulit-project scenario outputs coverage report" name="File path not found in mulit-project scenario outputs coverage report" time="2.67">
    </testcase>
  </testsuite>
  <testsuite name="formatTestResults" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:58" time="0.33" tests="1">
    <testcase classname="formatTestResults includes test full name" name="formatTestResults includes test full name" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="validate pattern function" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:58" time="0.248" tests="4">
    <testcase classname="validate pattern function without passed args returns true" name="validate pattern function without passed args returns true" time="0.002">
    </testcase>
    <testcase classname="validate pattern function returns true for empty pattern" name="validate pattern function returns true for empty pattern" time="0.001">
    </testcase>
    <testcase classname="validate pattern function returns true for valid pattern" name="validate pattern function returns true for valid pattern" time="0">
    </testcase>
    <testcase classname="validate pattern function returns false for invalid pattern" name="validate pattern function returns false for invalid pattern" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="getPlatformExtension" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:59" time="0.224" tests="1">
    <testcase classname="getPlatformExtension should get platform ext" name="getPlatformExtension should get platform ext" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:35:59" time="2.339" tests="1">
    <testcase classname=" CheckboxWithLabel changes the text after click" name=" CheckboxWithLabel changes the text after click" time="0.043">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:01" time="5.52" tests="1">
    <testcase classname=" logs memory usage" name=" logs memory usage" time="5.287">
    </testcase>
  </testsuite>
  <testsuite name="normalizePathSep" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:07" time="0.191" tests="2">
    <testcase classname="normalizePathSep does nothing on posix" name="normalizePathSep does nothing on posix" time="0.003">
    </testcase>
    <testcase classname="normalizePathSep replace slashes on windows" name="normalizePathSep replace slashes on windows" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="test/it.todo error throwing" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:07" time="0.213" tests="3">
    <testcase classname="test/it.todo error throwing it throws error when given no arguments" name="test/it.todo error throwing it throws error when given no arguments" time="0.001">
    </testcase>
    <testcase classname="test/it.todo error throwing it throws error when given more than one argument" name="test/it.todo error throwing it throws error when given more than one argument" time="0.001">
    </testcase>
    <testcase classname="test/it.todo error throwing it throws error when given none string description" name="test/it.todo error throwing it throws error when given none string description" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:08" time="3.999" tests="1">
    <testcase classname=" CheckboxWithLabel changes the text after click" name=" CheckboxWithLabel changes the text after click" time="0.016">
    </testcase>
  </testsuite>
  <testsuite name="beforeEach hooks error throwing" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:12" time="0.348" tests="32">
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when &quot;String&quot; is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when &quot;String&quot; is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when 1 is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when 1 is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when [] is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when [] is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when {} is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when {} is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when Symbol(hello) is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when Symbol(hello) is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when true is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when true is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when null is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when null is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when undefined is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when undefined is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when &quot;String&quot; is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when &quot;String&quot; is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when 1 is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when 1 is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when [] is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when [] is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when {} is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when {} is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when Symbol(hello) is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when Symbol(hello) is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when true is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when true is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when null is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when null is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when undefined is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when undefined is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when &quot;String&quot; is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when &quot;String&quot; is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when 1 is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when 1 is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when [] is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when [] is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when {} is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when {} is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when Symbol(hello) is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when Symbol(hello) is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when true is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when true is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when null is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when null is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when undefined is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when undefined is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when &quot;String&quot; is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when &quot;String&quot; is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when 1 is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when 1 is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when [] is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when [] is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when {} is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when {} is provided as a first argument to it" time="0.008">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when Symbol(hello) is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when Symbol(hello) is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when true is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when true is provided as a first argument to it" time="0.002">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when null is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when null is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when undefined is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when undefined is provided as a first argument to it" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:12" time="15.36" tests="2">
    <testcase classname=" moduleNameMapper wrong configuration" name=" moduleNameMapper wrong configuration" time="7.505">
    </testcase>
    <testcase classname=" moduleNameMapper correct configuration" name=" moduleNameMapper correct configuration" time="7.61">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:27" time="7.482" tests="1">
    <testcase classname=" Prints deprecation warnings for CLI flags" name=" Prints deprecation warnings for CLI flags" time="7.274">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:35" time="8.189" tests="1">
    <testcase classname=" " name=" " time="7.856">
    </testcase>
  </testsuite>
  <testsuite name="array" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:43" time="0.982" tests="6">
    <testcase classname="array .add returns the result of adding 0 to 0" name="array .add returns the result of adding 0 to 0" time="0.002">
    </testcase>
    <testcase classname="array .add returns the result of adding 0 to 1" name="array .add returns the result of adding 0 to 1" time="0.001">
    </testcase>
    <testcase classname="array .add returns the result of adding 1 to 1" name="array .add returns the result of adding 1 to 1" time="0.001">
    </testcase>
    <testcase classname="template .add returns 0 when given 0 and 0" name="template .add returns 0 when given 0 and 0" time="0.001">
    </testcase>
    <testcase classname="template .add returns 1 when given 0 and 1" name="template .add returns 1 when given 0 and 1" time="0.001">
    </testcase>
    <testcase classname="template .add returns 2 when given 1 and 1" name="template .add returns 2 when given 1 and 1" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="async jasmine with pending during test" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:44" time="6.363" tests="1">
    <testcase classname="async jasmine with pending during test should be reported as a pending test" name="async jasmine with pending during test should be reported as a pending test" time="6.003">
    </testcase>
  </testsuite>
  <testsuite name="beforeEach hooks error throwing" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:51" time="0.257" tests="32">
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when &quot;String&quot; is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when &quot;String&quot; is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when 1 is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when 1 is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when [] is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when [] is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when {} is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when {} is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when Symbol(hello) is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when Symbol(hello) is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when true is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when true is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when null is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when null is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeEach hooks error throwing beforeEach throws an error when undefined is provided as a first argument to it" name="beforeEach hooks error throwing beforeEach throws an error when undefined is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when &quot;String&quot; is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when &quot;String&quot; is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when 1 is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when 1 is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when [] is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when [] is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when {} is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when {} is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when Symbol(hello) is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when Symbol(hello) is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when true is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when true is provided as a first argument to it" time="0.002">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when null is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when null is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="beforeAll hooks error throwing beforeAll throws an error when undefined is provided as a first argument to it" name="beforeAll hooks error throwing beforeAll throws an error when undefined is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when &quot;String&quot; is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when &quot;String&quot; is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when 1 is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when 1 is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when [] is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when [] is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when {} is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when {} is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when Symbol(hello) is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when Symbol(hello) is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when true is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when true is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when null is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when null is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="afterEach hooks error throwing afterEach throws an error when undefined is provided as a first argument to it" name="afterEach hooks error throwing afterEach throws an error when undefined is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when &quot;String&quot; is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when &quot;String&quot; is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when 1 is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when 1 is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when [] is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when [] is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when {} is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when {} is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when Symbol(hello) is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when Symbol(hello) is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when true is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when true is provided as a first argument to it" time="0.001">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when null is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when null is provided as a first argument to it" time="0">
    </testcase>
    <testcase classname="afterAll hooks error throwing afterAll throws an error when undefined is provided as a first argument to it" name="afterAll hooks error throwing afterAll throws an error when undefined is provided as a first argument to it" time="0">
    </testcase>
  </testsuite>
  <testsuite name="Repl" errors="0" failures="0" skipped="1" timestamp="2018-12-19T21:36:51" time="0.208" tests="2">
    <testcase classname="Repl does not work on Windows" name="Repl does not work on Windows" time="0.002">
    </testcase>
    <testcase classname="Repl cli runs without errors" name="Repl cli runs without errors" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:51" time="5.712" tests="1">
    <testcase classname=" require.resolve with paths" name=" require.resolve with paths" time="5.492">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:57" time="0.222" tests="1">
    <testcase classname=" mocks async functions" name=" mocks async functions" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="ErrorWithStack" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:57" time="0.468" tests="1">
    <testcase classname="ErrorWithStack calls Error.captureStackTrace with given callsite when capture exists" name="ErrorWithStack calls Error.captureStackTrace with given callsite when capture exists" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:36:58" time="10.645" tests="2">
    <testcase classname=" overriding native promise does not freeze Jest" name=" overriding native promise does not freeze Jest" time="6.37">
    </testcase>
    <testcase classname=" has a duration even if time is faked" name=" has a duration even if time is faked" time="4.019">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:37:09" time="9.037" tests="1">
    <testcase classname=" runs tests in only test.js and spec.js" name=" runs tests in only test.js and spec.js" time="8.57">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:37:18" time="8.342" tests="1">
    <testcase classname=" processes stack traces and code frames with source maps" name=" processes stack traces and code frames with source maps" time="8.114">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:37:26" time="8.012" tests="1">
    <testcase classname=" triggers setup/teardown hooks" name=" triggers setup/teardown hooks" time="7.492">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:37:34" time="0.285" tests="1">
    <testcase classname=" matcher returns matcher name, expected and actual values" name=" matcher returns matcher name, expected and actual values" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="JSDomEnvironment" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:37:34" time="5.172" tests="1">
    <testcase classname="JSDomEnvironment should configure setTimeout/setInterval to use the browser api" name="JSDomEnvironment should configure setTimeout/setInterval to use the browser api" time="0.034">
    </testcase>
  </testsuite>
  <testsuite name="Runtime requireModule with no extension" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:37:40" time="0.786" tests="1">
    <testcase classname="Runtime requireModule with no extension throws error pointing out file with extension" name="Runtime requireModule with no extension throws error pointing out file with extension" time="0.409">
    </testcase>
  </testsuite>
  <testsuite name="listFilesInDirectorySync" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:37:41" time="2.232" tests="1">
    <testcase classname="listFilesInDirectorySync includes all files in the directory in the summary" name="listFilesInDirectorySync includes all files in the directory in the summary" time="0.143">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:37:43" time="25.144" tests="1">
    <testcase classname=" sucessfully runs the tests inside `babel-plugin-jest-hoist/`" name=" sucessfully runs the tests inside `babel-plugin-jest-hoist/`" time="24.923">
    </testcase>
  </testsuite>
  <testsuite name="jest --debug" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:38:08" time="6.932" tests="1">
    <testcase classname="jest --debug outputs debugging info before running the test" name="jest --debug outputs debugging info before running the test" time="6.662">
    </testcase>
  </testsuite>
  <testsuite name="isBuiltinModule" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:38:15" time="0.237" tests="4">
    <testcase classname="isBuiltinModule should return true for the `path` module" name="isBuiltinModule should return true for the `path` module" time="0.002">
    </testcase>
    <testcase classname="isBuiltinModule should return false for the `chalk` module" name="isBuiltinModule should return false for the `chalk` module" time="0.001">
    </testcase>
    <testcase classname="isBuiltinModule should return true for the `_http_common` module" name="isBuiltinModule should return true for the `_http_common` module" time="0">
    </testcase>
    <testcase classname="isBuiltinModule should return false for any internal node builtins" name="isBuiltinModule should return false for any internal node builtins" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="Fake promises" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:38:15" time="11.389" tests="2">
    <testcase classname="Fake promises should be possible to resolve with fake timers using immediates" name="Fake promises should be possible to resolve with fake timers using immediates" time="5.522">
    </testcase>
    <testcase classname="Fake promises should be possible to resolve with fake timers using asap" name="Fake promises should be possible to resolve with fake timers using asap" time="5.627">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:38:27" time="6.011" tests="1">
    <testcase classname=" prints useful error for requires after test is done" name=" prints useful error for requires after test is done" time="5.496">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:38:33" time="4.338" tests="1">
    <testcase classname=" CheckboxWithLabel changes the text after click" name=" CheckboxWithLabel changes the text after click" time="0.017">
    </testcase>
  </testsuite>
  <testsuite name="JSON Reporter" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:38:37" time="5.636" tests="1">
    <testcase classname="JSON Reporter fails the test suite if it contains no tests" name="JSON Reporter fails the test suite if it contains no tests" time="5.399">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:38:43" time="6.35" tests="1">
    <testcase classname=" testNamePattern" name=" testNamePattern" time="6.124">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:38:49" time="2.291" tests="1">
    <testcase classname=" CheckboxWithLabel changes the text after click" name=" CheckboxWithLabel changes the text after click" time="0.059">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:38:52" time="7.945" tests="1">
    <testcase classname=" respects testEnvironment docblock" name=" respects testEnvironment docblock" time="7.552">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:39:00" time="5.715" tests="1">
    <testcase classname=" works with custom matchers" name=" works with custom matchers" time="5.489">
    </testcase>
  </testsuite>
  <testsuite name="isRegExpSupported" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:39:06" time="0.191" tests="2">
    <testcase classname="isRegExpSupported should return true when passing valid regular expression" name="isRegExpSupported should return true when passing valid regular expression" time="0.002">
    </testcase>
    <testcase classname="isRegExpSupported should return false when passing an invalid regular expression" name="isRegExpSupported should return false when passing an invalid regular expression" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:39:06" time="8.305" tests="1">
    <testcase classname=" instruments and collects coverage for typescript files" name=" instruments and collects coverage for typescript files" time="8.104">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:39:14" time="5.746" tests="1">
    <testcase classname=" testNamePattern skipped" name=" testNamePattern skipped" time="5.542">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:39:20" time="10.996" tests="2">
    <testcase classname=" run timers after resetAllMocks test" name=" run timers after resetAllMocks test" time="5.437">
    </testcase>
    <testcase classname=" run timers with resetMocks in config test" name=" run timers with resetMocks in config test" time="5.367">
    </testcase>
  </testsuite>
  <testsuite name="getMockName" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:39:31" time="0.192" tests="1">
    <testcase classname="getMockName extracts mock name from file path" name="getMockName extracts mock name from file path" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:39:31" time="6.328" tests="1">
    <testcase classname=" testNamePattern" name=" testNamePattern" time="6.047">
    </testcase>
  </testsuite>
  <testsuite name="Suite" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:39:38" time="0.377" tests="1">
    <testcase classname="Suite doesn&apos;t throw on addExpectationResult when there are no children" name="Suite doesn&apos;t throw on addExpectationResult when there are no children" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:39:38" time="11.949" tests="2">
    <testcase classname=" suite with auto-restore" name=" suite with auto-restore" time="5.758">
    </testcase>
    <testcase classname=" suite without auto-restore" name=" suite without auto-restore" time="5.99">
    </testcase>
  </testsuite>
  <testsuite name="timers" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:39:50" time="0.19" tests="2">
    <testcase classname="timers should work before calling resetAllMocks" name="timers should work before calling resetAllMocks" time="0.003">
    </testcase>
    <testcase classname="timers should not break after calling resetAllMocks" name="timers should not break after calling resetAllMocks" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:39:50" time="12.006" tests="2">
    <testcase classname=" suite with auto-reset" name=" suite with auto-reset" time="5.952">
    </testcase>
    <testcase classname=" suite without auto-reset" name=" suite without auto-reset" time="5.847">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:40:02" time="11.329" tests="2">
    <testcase classname=" suite with auto-clear" name=" suite with auto-clear" time="5.554">
    </testcase>
    <testcase classname=" suite without auto-clear" name=" suite without auto-clear" time="5.547">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:40:14" time="1.901" tests="2">
    <testcase classname=" implementation created by automock" name=" implementation created by automock" time="0.001">
    </testcase>
    <testcase classname=" implementation created by jest.genMockFromModule" name=" implementation created by jest.genMockFromModule" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="Regex Char In Path" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:40:16" time="5.527" tests="1">
    <testcase classname="Regex Char In Path parses paths containing regex chars correctly" name="Regex Char In Path parses paths containing regex chars correctly" time="5.327">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:40:21" time="4.561" tests="1">
    <testcase classname=" Verbose Reporter" name=" Verbose Reporter" time="4.36">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:40:26" time="5.994" tests="1">
    <testcase classname=" prints a usable stack trace even if no Error.captureStackTrace" name=" prints a usable stack trace even if no Error.captureStackTrace" time="5.781">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:40:32" time="6.18" tests="1">
    <testcase classname=" provides `require.main` set to test suite module" name=" provides `require.main` set to test suite module" time="5.884">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="1" skipped="0" timestamp="2018-12-19T21:40:38" time="4.808" tests="1">
    <testcase classname=" should transform linked modules" name=" should transform linked modules" time="4.581">
      <failure>Error: expect(received).toBe(expected) // Object.is equality

Expected: true
Received: false
    at Object.toBe (C:\Users\kangan\Source\Repos\jest\e2e\__tests__\transform-linked-modules.test.js:19:26)
    at Object.asyncJestTest (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\jasmineAsyncInstall.js:121:37)
    at resolve (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\queueRunner.js:54:12)
    at new Promise (&lt;anonymous&gt;)
    at mapper (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\queueRunner.js:41:19)
    at promise.then (C:\Users\kangan\Source\Repos\jest\packages\jest-jasmine2\build\queueRunner.js:86:41)</failure>
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:40:43" time="5.995" tests="1">
    <testcase classname=" supports NODE_PATH" name=" supports NODE_PATH" time="5.795">
    </testcase>
  </testsuite>
  <testsuite name="Correct BeforeAll run" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:40:49" time="8.384" tests="1">
    <testcase classname="Correct BeforeAll run ensures the BeforeAll of ignored suite is not run" name="Correct BeforeAll run ensures the BeforeAll of ignored suite is not run" time="7.914">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:40:58" time="7.723" tests="1">
    <testcase classname=" useRealTimers cancels &quot;timers&quot;: &quot;fake&quot; for whole test file" name=" useRealTimers cancels &quot;timers&quot;: &quot;fake&quot; for whole test file" time="7.453">
    </testcase>
  </testsuite>
  <testsuite name="Fake Chalk" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:41:05" time="0.24" tests="2">
    <testcase classname="Fake Chalk returns input when invoked" name="Fake Chalk returns input when invoked" time="0.002">
    </testcase>
    <testcase classname="Fake Chalk supports chaining" name="Fake Chalk supports chaining" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:41:06" time="16.026" tests="2">
    <testcase classname=" supports json preset" name=" supports json preset" time="7.941">
    </testcase>
    <testcase classname=" supports js preset" name=" supports js preset" time="7.516">
    </testcase>
  </testsuite>
  <testsuite name="Correct beforeEach order" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:41:22" time="7.699" tests="1">
    <testcase classname="Correct beforeEach order ensures the correct order for beforeEach" name="Correct beforeEach order ensures the correct order for beforeEach" time="7.487">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:41:30" time="0.482" tests="2">
    <testcase classname=" if utils are mocked" name=" if utils are mocked" time="0.004">
    </testcase>
    <testcase classname=" mocked implementation" name=" mocked implementation" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:41:30" time="7.93" tests="1">
    <testcase classname=" does not crash when expect involving a DOM node fails" name=" does not crash when expect involving a DOM node fails" time="7.697">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:41:38" time="1.354" tests="1">
    <testcase classname=" readConfig() throws when an object is passed without a file path" name=" readConfig() throws when an object is passed without a file path" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="Common globals" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:41:40" time="0.169" tests="1">
    <testcase classname="Common globals check process" name="Common globals check process" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:41:40" time="5.75" tests="1">
    <testcase classname=" suite with invalid assertions in afterAll" name=" suite with invalid assertions in afterAll" time="5.54">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:41:46" time="0.212" tests="2">
    <testcase classname=" JSON is available in the global scope" name=" JSON is available in the global scope" time="0.002">
    </testcase>
    <testcase classname=" JSON.parse creates objects from within this context" name=" JSON.parse creates objects from within this context" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:41:46" time="5.639" tests="1">
    <testcase classname=" setImmediate" name=" setImmediate" time="5.448">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:41:51" time="5.812" tests="1">
    <testcase classname=" jest.resetModules should not error when _isMockFunction is defined but not boolean" name=" jest.resetModules should not error when _isMockFunction is defined but not boolean" time="5.589">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:41:57" time="5.698" tests="1">
    <testcase classname=" suite with test cases that contain malformed sourcemaps" name=" suite with test cases that contain malformed sourcemaps" time="5.48">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:42:03" time="5.795" tests="1">
    <testcase classname=" prints stack trace pointing to process.exit call" name=" prints stack trace pointing to process.exit call" time="5.338">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:42:09" time="5.881" tests="1">
    <testcase classname=" expect works correctly with RegExps created inside a VM" name=" expect works correctly with RegExps created inside a VM" time="5.653">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:42:15" time="7.723" tests="1">
    <testcase classname=" module.parent should be null in test files" name=" module.parent should be null in test files" time="7.519">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:42:23" time="0.34" tests="1">
    <testcase classname=" renders correctly" name=" renders correctly" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:42:23" time="8.48" tests="1">
    <testcase classname=" works with nested event loops" name=" works with nested event loops" time="8.269">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:42:31" time="8.299" tests="1">
    <testcase classname=" use the custom resolver" name=" use the custom resolver" time="8.08">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:42:40" time="5.926" tests="1">
    <testcase classname=" resolve node module" name=" resolve node module" time="5.719">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:42:46" time="5.688" tests="1">
    <testcase classname=" mock works with generator" name=" mock works with generator" time="5.474">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:42:52" time="6.305" tests="1">
    <testcase classname=" require.resolve.paths" name=" require.resolve.paths" time="6.094">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:42:58" time="8.933" tests="1">
    <testcase classname=" resolve platform modules" name=" resolve platform modules" time="8.692">
    </testcase>
  </testsuite>
  <testsuite name="matchers" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:07" time="0.266" tests="1">
    <testcase classname="matchers proxies matchers to expect" name="matchers proxies matchers to expect" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:07" time="0.213" tests="1">
    <testcase classname=" v8 module" name=" v8 module" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:07" time="0.286" tests="1">
    <testcase classname=" does a full mock" name=" does a full mock" time="0.01">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:08" time="0.273" tests="1">
    <testcase classname=" Symbol deletion" name=" Symbol deletion" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:08" time="0.327" tests="1">
    <testcase classname=" readConfigs() throws when called without project paths" name=" readConfigs() throws when called without project paths" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:09" time="0.497" tests="1">
    <testcase classname=" globals are properly defined" name=" globals are properly defined" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="timers" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:09" time="0.212" tests="1">
    <testcase classname="timers should work before calling resetAllMocks" name="timers should work before calling resetAllMocks" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:10" time="0.372" tests="2">
    <testcase classname=" adds 1 + 2 to equal 3 in TScript" name=" adds 1 + 2 to equal 3 in TScript" time="0.078">
    </testcase>
    <testcase classname=" adds 1 + 2 to equal 3 in JavaScript" name=" adds 1 + 2 to equal 3 in JavaScript" time="0.039">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:10" time="0.212" tests="2">
    <testcase classname=" adds 1 + 2 to equal 3 in Typescript" name=" adds 1 + 2 to equal 3 in Typescript" time="0.003">
    </testcase>
    <testcase classname=" adds 1 + 2 to equal 3 in JavaScript" name=" adds 1 + 2 to equal 3 in JavaScript" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:10" time="0.219" tests="1">
    <testcase classname=" stub" name=" stub" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:10" time="0.231" tests="1">
    <testcase classname=" stub" name=" stub" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:11" time="0.225" tests="1">
    <testcase classname=" global.test" name=" global.test" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:11" time="0.327" tests="1">
    <testcase classname=" if user model is mocked" name=" if user model is mocked" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:11" time="0.222" tests="1">
    <testcase classname=" if orginal user model" name=" if orginal user model" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:12" time="0.235" tests="1">
    <testcase classname=" original implementation" name=" original implementation" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:12" time="0.327" tests="1">
    <testcase classname=" subtracts 5 - 1 to equal 4 in TypeScript" name=" subtracts 5 - 1 to equal 4 in TypeScript" time="0.081">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:12" time="0.291" tests="1">
    <testcase classname=" get configuration defaults" name=" get configuration defaults" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:13" time="2.638" tests="1">
    <testcase classname=" works with `import`" name=" works with `import`" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:15" time="0.442" tests="1">
    <testcase classname=" if lodash head is mocked" name=" if lodash head is mocked" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:16" time="2.355" tests="1">
    <testcase classname=" adds 1 + 2 to equal 3" name=" adds 1 + 2 to equal 3" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:18" time="0.228" tests="1">
    <testcase classname=" should pass" name=" should pass" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2018-12-19T21:43:19" time="0.219" tests="1">
    <testcase classname=" should pass" name=" should pass" time="0">
    </testcase>
  </testsuite>
</testsuites>